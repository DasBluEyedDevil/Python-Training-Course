{
  "lesson_id": "08_05",
  "title": "Input Validation and Defensive Programming",
  "module_id": 8,
  "order_index": 5,
  "description": "Master input validation techniques, learn defensive programming practices, and understand EAFP vs. LBYL approaches to writing robust, production-ready code.",
  "estimated_minutes": 30,
  "content_blocks": [
    {
      "type": "the_simplifier",
      "title": "The Concept: The Bouncer at the Door",
      "content": "Imagine you're a bouncer at an exclusive club. Do you:\n\n**A) Let everyone in and deal with problems later?** (No validation)\n- Drunk people start fights → chaos\n- Underage people drink → legal problems  \n- Result: Club gets shut down\n\n**B) Check EVERYTHING at the door?** (Input validation)\n- ID check → Prevent underage entry\n- Sobriety check → Prevent drunk people\n- Dress code check → Maintain standards\n- Result: Safe, enjoyable club\n\nThis is **defensive programming** - assume EVERYTHING can go wrong, and guard against it.\n\n**Two Philosophies:**\n\n**LBYL (Look Before You Leap):**\n\"Check ID before letting them in\"\n```python\nif age >= 21:  # Check first\n    serve_drink()  # Then act\nelse:\n    deny_entry()\n```\n\n**EAFP (Easier to Ask Forgiveness than Permission):**\n\"Let them order, catch the error if they're underage\"\n```python\ntry:\n    serve_drink()  # Try it\nexcept UnderageError:  # Handle error\n    deny_entry()\n```\n\n**Python prefers EAFP** for many situations (it's more Pythonic), but **validation is still crucial**.\n\n**Real-world scenarios:**\n\n1. **User registration:**\n   - Validate email format, password strength, age\n   - Don't just trust user input!\n\n2. **API endpoints:**\n   - Validate all request parameters\n   - Check data types, ranges, required fields\n\n3. **File processing:**\n   - Validate file exists, correct format, not too large\n   - Don't assume file is perfect\n\n**Defensive programming checklist:**\n- ✅ Validate ALL user input (never trust it)\n- ✅ Check types (is it an int when you expect int?)\n- ✅ Check ranges (is age between 0-120?)\n- ✅ Check formats (is email valid? Is date parseable?)\n- ✅ Provide helpful error messages (tell users what's wrong)\n- ✅ Have fallback values when appropriate"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Input Validation Patterns",
      "code": "# Example 1: Basic input validation\nprint(\"=== Basic Input Validation ===\")\n\ndef get_age_from_user(user_input):\n    \"\"\"Validate and convert age input.\"\"\"\n    \n    # Step 1: Check if input is empty\n    if not user_input or user_input.strip() == \"\":\n        raise ValueError(\"Age cannot be empty\")\n    \n    # Step 2: Try to convert to integer\n    try:\n        age = int(user_input.strip())\n    except ValueError:\n        raise ValueError(f\"Age must be a number, got '{user_input}'\")\n    \n    # Step 3: Validate range\n    if age < 0:\n        raise ValueError(f\"Age cannot be negative (got {age})\")\n    if age > 120:\n        raise ValueError(f\"Age seems unrealistic (got {age})\")\n    \n    return age\n\n# Test cases\ntest_inputs = [\"25\", \"  30  \", \"\", \"abc\", \"-5\", \"200\"]\n\nfor test_input in test_inputs:\n    print(f\"\\nInput: '{test_input}'\")\n    try:\n        age = get_age_from_user(test_input)\n        print(f\"  ✓ Valid age: {age}\")\n    except ValueError as e:\n        print(f\"  ✗ Invalid: {e}\")\n\n# Example 2: EAFP vs LBYL\nprint(\"\\n\\n=== EAFP vs LBYL Comparison ===\")\n\nmy_dict = {\"name\": \"Alice\", \"age\": 25}\n\n# LBYL (Look Before You Leap)\nprint(\"\\nLBYL approach:\")\nif \"email\" in my_dict:\n    email = my_dict[\"email\"]\n    print(f\"Email: {email}\")\nelse:\n    print(\"No email found\")\n    email = \"no-email@example.com\"\n\nprint(f\"Result: {email}\")\n\n# EAFP (Easier to Ask Forgiveness than Permission) - More Pythonic!\nprint(\"\\nEAFP approach:\")\ntry:\n    email = my_dict[\"email\"]\n    print(f\"Email: {email}\")\nexcept KeyError:\n    print(\"No email found\")\n    email = \"no-email@example.com\"\n\nprint(f\"Result: {email}\")\n\n# Or even better - using .get() for simple cases\nprint(\"\\nBest approach (for dicts):\")\nemail = my_dict.get(\"email\", \"no-email@example.com\")\nprint(f\"Result: {email}\")\n\n# Example 3: Comprehensive validation function\nprint(\"\\n\\n=== Comprehensive Email Validation ===\")\n\ndef validate_email(email):\n    \"\"\"Validate email with multiple checks.\"\"\"\n    \n    # Check 1: Not empty\n    if not email or not email.strip():\n        return False, \"Email cannot be empty\"\n    \n    email = email.strip()\n    \n    # Check 2: Contains @\n    if \"@\" not in email:\n        return False, \"Email must contain @\"\n    \n    # Check 3: Has content before and after @\n    parts = email.split(\"@\")\n    if len(parts) != 2:\n        return False, \"Email must have exactly one @\"\n    \n    local, domain = parts\n    \n    if not local:\n        return False, \"Email must have content before @\"\n    if not domain:\n        return False, \"Email must have content after @\"\n    \n    # Check 4: Domain has a dot\n    if \".\" not in domain:\n        return False, \"Domain must contain a dot (e.g., gmail.com)\"\n    \n    # Check 5: Domain parts are not empty\n    domain_parts = domain.split(\".\")\n    if any(part == \"\" for part in domain_parts):\n        return False, \"Domain parts cannot be empty\"\n    \n    # All checks passed!\n    return True, \"Valid email\"\n\n# Test email validation\ntest_emails = [\n    \"alice@example.com\",\n    \"bob@company.co.uk\",\n    \"\",\n    \"no-at-sign.com\",\n    \"@example.com\",\n    \"user@\",\n    \"user@@example.com\",\n    \"user@nodot\",\n    \"user@example.\",\n]\n\nfor email in test_emails:\n    is_valid, message = validate_email(email)\n    status = \"✓\" if is_valid else \"✗\"\n    print(f\"{status} '{email}': {message}\")\n\n# Example 4: Defensive programming in practice\nprint(\"\\n\\n=== Defensive Programming Example ===\")\n\ndef calculate_discount(price, discount_percent=0, coupon_code=None):\n    \"\"\"Calculate price with discount - defensive version.\"\"\"\n    \n    # Validate price\n    if not isinstance(price, (int, float)):\n        raise TypeError(f\"Price must be a number, got {type(price).__name__}\")\n    if price < 0:\n        raise ValueError(f\"Price cannot be negative (got {price})\")\n    \n    # Validate discount percent\n    if not isinstance(discount_percent, (int, float)):\n        raise TypeError(f\"Discount must be a number, got {type(discount_percent).__name__}\")\n    if not 0 <= discount_percent <= 100:\n        raise ValueError(f\"Discount must be 0-100% (got {discount_percent})\")\n    \n    # Validate coupon code (optional)\n    if coupon_code is not None and not isinstance(coupon_code, str):\n        raise TypeError(\"Coupon code must be a string\")\n    \n    # Apply discount\n    discount_amount = price * (discount_percent / 100)\n    discounted_price = price - discount_amount\n    \n    # Apply coupon if provided\n    if coupon_code:\n        coupon_code = coupon_code.strip().upper()\n        if coupon_code == \"SAVE10\":\n            discounted_price *= 0.9  # Extra 10% off\n            print(f\"  Coupon '{coupon_code}' applied: -10%\")\n    \n    return round(discounted_price, 2)\n\n# Test defensive function\nprint(\"\\nTest 1: Valid inputs\")\ntry:\n    result = calculate_discount(100, 20, \"SAVE10\")\n    print(f\"  Final price: ${result}\\n\")\nexcept (TypeError, ValueError) as e:\n    print(f\"  Error: {e}\\n\")\n\nprint(\"Test 2: Invalid price type\")\ntry:\n    result = calculate_discount(\"100\", 20)\n    print(f\"  Final price: ${result}\\n\")\nexcept (TypeError, ValueError) as e:\n    print(f\"  Error: {e}\\n\")\n\nprint(\"Test 3: Invalid discount range\")\ntry:\n    result = calculate_discount(100, 150)\n    print(f\"  Final price: ${result}\\n\")\nexcept (TypeError, ValueError) as e:\n    print(f\"  Error: {e}\\n\")\n\nprint(\"Test 4: Invalid coupon type\")\ntry:\n    result = calculate_discount(100, 20, 12345)\n    print(f\"  Final price: ${result}\\n\")\nexcept (TypeError, ValueError) as e:\n    print(f\"  Error: {e}\\n\")",
      "explanation": "The code demonstrates:\n1. **Step-by-step validation** (check empty, type, range)\n2. **EAFP vs. LBYL** approaches (Python prefers EAFP)\n3. **Comprehensive validation** with helpful error messages\n4. **Type checking** with isinstance()\n5. **Range validation** to ensure values are reasonable\n6. **Defensive programming** that assumes inputs are wrong until proven right",
      "output": "=== Basic Input Validation ===\n\nInput: '25'\n  ✓ Valid age: 25\n\nInput: '  30  '\n  ✓ Valid age: 30\n\nInput: ''\n  ✗ Invalid: Age cannot be empty\n\nInput: 'abc'\n  ✗ Invalid: Age must be a number, got 'abc'\n\nInput: '-5'\n  ✗ Invalid: Age cannot be negative (got -5)\n\nInput: '200'\n  ✗ Invalid: Age seems unrealistic (got 200)\n\n\n=== EAFP vs LBYL Comparison ===\n\nLBYL approach:\nNo email found\nResult: no-email@example.com\n\nEAFP approach:\nNo email found\nResult: no-email@example.com\n\nBest approach (for dicts):\nResult: no-email@example.com\n\n\n=== Comprehensive Email Validation ===\n✓ 'alice@example.com': Valid email\n✓ 'bob@company.co.uk': Valid email\n✗ '': Email cannot be empty\n✗ 'no-at-sign.com': Email must contain @\n✗ '@example.com': Email must have content before @\n✗ 'user@': Email must have content after @\n✗ 'user@@example.com': Email must have exactly one @\n✗ 'user@nodot': Domain must contain a dot (e.g., gmail.com)\n✗ 'user@example.': Domain parts cannot be empty\n\n\n=== Defensive Programming Example ===\n\nTest 1: Valid inputs\n  Coupon 'SAVE10' applied: -10%\n  Final price: $72.0\n\nTest 2: Invalid price type\n  Error: Price must be a number, got str\n\nTest 3: Invalid discount range\n  Error: Discount must be 0-100% (got 150)\n\nTest 4: Invalid coupon type\n  Error: Coupon code must be a string"
    },
    {
      "type": "the_simplifier",
      "title": "Syntax Breakdown: Validation Patterns",
      "content": "**Input Validation Checklist:**\n\n**1. Check for empty/null:**\n```python\nif not value or value.strip() == \"\":\n    raise ValueError(\"Input cannot be empty\")\n```\n\n**2. Type validation:**\n```python\n# Check if value is the right type\nif not isinstance(value, int):\n    raise TypeError(f\"Expected int, got {type(value).__name__}\")\n\n# Accept multiple types\nif not isinstance(price, (int, float)):\n    raise TypeError(\"Price must be a number\")\n```\n\n**3. Range validation:**\n```python\n# Check numeric range\nif not 0 <= age <= 120:\n    raise ValueError(f\"Age must be 0-120, got {age}\")\n\n# Check string length\nif len(password) < 8:\n    raise ValueError(\"Password must be at least 8 characters\")\n```\n\n**4. Format validation:**\n```python\n# Email contains @\nif \"@\" not in email:\n    raise ValueError(\"Invalid email format\")\n\n# String is numeric\nif not value.isdigit():\n    raise ValueError(\"Must contain only digits\")\n```\n\n**5. Sanitization (clean the input):**\n```python\n# Remove whitespace\nvalue = value.strip()\n\n# Convert to lowercase for comparison\nvalue = value.lower()\n\n# Remove dangerous characters\nvalue = value.replace(\";\", \"\").replace(\"--\", \"\")\n```\n\n**EAFP vs LBYL:**\n\n**LBYL (Look Before You Leap):**\n```python\n# Check condition first, then act\nif key in dictionary:\n    value = dictionary[key]\nelse:\n    value = default\n\nif os.path.exists(filename):\n    with open(filename) as f:\n        data = f.read()\n```\n\n**EAFP (Easier to Ask Forgiveness than Permission):**\n```python\n# Try it, handle errors if they occur\ntry:\n    value = dictionary[key]\nexcept KeyError:\n    value = default\n\ntry:\n    with open(filename) as f:\n        data = f.read()\nexcept FileNotFoundError:\n    data = None\n```\n\n**When to use each:**\n\n**Use LBYL when:**\n- Simple conditions (if key in dict)\n- Readability matters more than performance\n- You want to avoid exceptions in common cases\n\n**Use EAFP when:**\n- The success case is more common than failure\n- Race conditions possible (file might be deleted between check and use)\n- More Pythonic (\"ask forgiveness\")\n\n**Defensive Programming Best Practices:**\n\n```python\ndef robust_function(param1, param2=None):\n    \"\"\"Template for defensive programming.\"\"\"\n    \n    # 1. Validate all parameters\n    if param1 is None:\n        raise ValueError(\"param1 is required\")\n    \n    if not isinstance(param1, str):\n        raise TypeError(\"param1 must be a string\")\n    \n    # 2. Sanitize input\n    param1 = param1.strip()\n    \n    # 3. Check business rules\n    if len(param1) < 3:\n        raise ValueError(\"param1 must be at least 3 characters\")\n    \n    # 4. Handle optional parameters\n    if param2 is None:\n        param2 = default_value\n    \n    # 5. Use try/except for risky operations\n    try:\n        result = risky_operation(param1)\n    except SomeError as e:\n        # Log and handle\n        logger.error(f\"Operation failed: {e}\")\n        return None\n    \n    return result\n```\n\n**Type hints (Python 3.5+) help with validation:**\n```python\ndef process_user(name: str, age: int) -> dict:\n    \"\"\"Type hints document expected types.\"\"\"\n    # Still need runtime validation!\n    if not isinstance(name, str):\n        raise TypeError(\"name must be str\")\n    return {\"name\": name, \"age\": age}\n```"
    },
    {
      "type": "the_coder",
      "title": "Interactive Exercise: Build a User Registration Validator",
      "instruction": "Create a user registration validator that checks:\n1. **Username:** 3-20 characters, alphanumeric only, not empty\n2. **Email:** Valid format (contains @ and .)\n3. **Age:** Integer between 13-120\n4. **Password:** At least 8 characters\n\nReturn True if all valid, raise appropriate exceptions if any validation fails.\n\n**Your task:**\nImplement validate_registration() with comprehensive validation.\n\n**Starter code:**",
      "starter_code": "def validate_registration(username, email, age, password):\n    \"\"\"Validate user registration data.\"\"\"\n    \n    # TODO: Validate username\n    # - Not empty (after stripping)\n    # - 3-20 characters\n    # - Only letters and numbers (use .isalnum())\n    \n    # TODO: Validate email\n    # - Not empty\n    # - Contains @\n    # - Contains . after @\n    \n    # TODO: Validate age\n    # - Is an integer (isinstance)\n    # - Between 13-120\n    \n    # TODO: Validate password\n    # - Not empty\n    # - At least 8 characters\n    \n    return True\n\n# Test cases\ntest_cases = [\n    (\"alice123\", \"alice@example.com\", 25, \"SecurePass123\"),  # Valid\n    (\"\", \"alice@example.com\", 25, \"SecurePass123\"),  # Empty username\n    (\"ab\", \"alice@example.com\", 25, \"SecurePass123\"),  # Short username\n    (\"alice123\", \"invalid-email\", 25, \"SecurePass123\"),  # Invalid email\n    (\"alice123\", \"alice@example.com\", 10, \"SecurePass123\"),  # Too young\n    (\"alice123\", \"alice@example.com\", 25, \"short\"),  # Short password\n]\n\nfor i, (user, email, age, pwd) in enumerate(test_cases, 1):\n    print(f\"\\nTest {i}: user='{user}', email='{email}', age={age}\")\n    try:\n        if validate_registration(user, email, age, pwd):\n            print(\"  ✓ Registration valid\")\n    except (ValueError, TypeError) as e:\n        print(f\"  ✗ {e}\")",
      "hint": "Use if not username.strip(): for empty check, if not 3 <= len(username) <= 20: for length, if not username.isalnum(): for alphanumeric check. Similar pattern for other fields."
    },
    {
      "type": "the_coder",
      "title": "Solution & Common Mistakes",
      "solution_code": "def validate_registration(username, email, age, password):\n    \"\"\"Validate user registration data with comprehensive checks.\n    \n    Args:\n        username: User's chosen username (str)\n        email: User's email address (str)\n        age: User's age (int)\n        password: User's password (str)\n        \n    Returns:\n        True if all validations pass\n        \n    Raises:\n        ValueError: If any validation fails\n        TypeError: If types are incorrect\n    \"\"\"\n    \n    # === Username Validation ===\n    \n    # Type check\n    if not isinstance(username, str):\n        raise TypeError(\"Username must be a string\")\n    \n    # Empty check\n    username = username.strip()\n    if not username:\n        raise ValueError(\"Username cannot be empty\")\n    \n    # Length check\n    if not 3 <= len(username) <= 20:\n        raise ValueError(\n            f\"Username must be 3-20 characters (got {len(username)})\"\n        )\n    \n    # Alphanumeric check\n    if not username.isalnum():\n        raise ValueError(\n            \"Username must contain only letters and numbers (no spaces or symbols)\"\n        )\n    \n    # === Email Validation ===\n    \n    # Type check\n    if not isinstance(email, str):\n        raise TypeError(\"Email must be a string\")\n    \n    # Empty check\n    email = email.strip()\n    if not email:\n        raise ValueError(\"Email cannot be empty\")\n    \n    # Contains @\n    if \"@\" not in email:\n        raise ValueError(\"Email must contain @\")\n    \n    # Has content before and after @\n    parts = email.split(\"@\")\n    if len(parts) != 2 or not parts[0] or not parts[1]:\n        raise ValueError(\"Email format invalid\")\n    \n    # Domain has a dot\n    domain = parts[1]\n    if \".\" not in domain:\n        raise ValueError(\"Email domain must contain a dot (e.g., example.com)\")\n    \n    # === Age Validation ===\n    \n    # Type check\n    if not isinstance(age, int):\n        raise TypeError(f\"Age must be an integer, got {type(age).__name__}\")\n    \n    # Range check\n    if not 13 <= age <= 120:\n        raise ValueError(\n            f\"Age must be between 13-120 (got {age})\"\n        )\n    \n    # === Password Validation ===\n    \n    # Type check\n    if not isinstance(password, str):\n        raise TypeError(\"Password must be a string\")\n    \n    # Empty check (don't strip passwords - spaces might be intentional!)\n    if not password:\n        raise ValueError(\"Password cannot be empty\")\n    \n    # Length check\n    if len(password) < 8:\n        raise ValueError(\n            f\"Password must be at least 8 characters (got {len(password)})\"\n        )\n    \n    # All validations passed!\n    return True\n\n# Comprehensive test cases\nprint(\"=== User Registration Validation Tests ===\")\n\ntest_cases = [\n    # (username, email, age, password, description)\n    (\"alice123\", \"alice@example.com\", 25, \"SecurePass123\", \"Valid registration\"),\n    (\"\", \"alice@example.com\", 25, \"SecurePass123\", \"Empty username\"),\n    (\"ab\", \"alice@example.com\", 25, \"SecurePass123\", \"Username too short\"),\n    (\"this_username_is_way_too_long\", \"alice@example.com\", 25, \"SecurePass123\", \"Username too long\"),\n    (\"user name\", \"alice@example.com\", 25, \"SecurePass123\", \"Username has space\"),\n    (\"alice123\", \"invalid-email\", 25, \"SecurePass123\", \"No @ in email\"),\n    (\"alice123\", \"@example.com\", 25, \"SecurePass123\", \"Email missing local part\"),\n    (\"alice123\", \"alice@\", 25, \"SecurePass123\", \"Email missing domain\"),\n    (\"alice123\", \"alice@example\", 25, \"SecurePass123\", \"Email domain no dot\"),\n    (\"alice123\", \"alice@example.com\", 10, \"SecurePass123\", \"Age too young\"),\n    (\"alice123\", \"alice@example.com\", 150, \"SecurePass123\", \"Age too old\"),\n    (\"alice123\", \"alice@example.com\", \"25\", \"SecurePass123\", \"Age is string\"),\n    (\"alice123\", \"alice@example.com\", 25, \"short\", \"Password too short\"),\n    (\"bob456\", \"bob@test.co.uk\", 18, \"LongSecurePassword\", \"Valid registration 2\"),\n]\n\nfor i, (user, email, age, pwd, description) in enumerate(test_cases, 1):\n    print(f\"\\nTest {i}: {description}\")\n    print(f\"  Data: user='{user}', email='{email}', age={age}\")\n    try:\n        if validate_registration(user, email, age, pwd):\n            print(f\"  ✓ Registration accepted\")\n    except (ValueError, TypeError) as e:\n        print(f\"  ✗ Rejected: {e}\")",
      "explanation": "The solution demonstrates comprehensive defensive programming:\n1. **Type validation** for all parameters using isinstance()\n2. **Empty checks** after stripping whitespace (except password!)\n3. **Range validation** for length and age\n4. **Format validation** for email structure\n5. **Clear, specific error messages** that tell users exactly what's wrong\n\nNote: Passwords are NOT stripped because spaces might be intentional!",
      "output": "=== User Registration Validation Tests ===\n\nTest 1: Valid registration\n  Data: user='alice123', email='alice@example.com', age=25\n  ✓ Registration accepted\n\nTest 2: Empty username\n  Data: user='', email='alice@example.com', age=25\n  ✗ Rejected: Username cannot be empty\n\nTest 3: Username too short\n  Data: user='ab', email='alice@example.com', age=25\n  ✗ Rejected: Username must be 3-20 characters (got 2)\n\nTest 4: Username too long\n  Data: user='this_username_is_way_too_long', email='alice@example.com', age=25\n  ✗ Rejected: Username must contain only letters and numbers (no spaces or symbols)\n\nTest 5: Username has space\n  Data: user='user name', email='alice@example.com', age=25\n  ✗ Rejected: Username must contain only letters and numbers (no spaces or symbols)\n\nTest 6: No @ in email\n  Data: user='alice123', email='invalid-email', age=25\n  ✗ Rejected: Email must contain @\n\nTest 7: Email missing local part\n  Data: user='alice123', email='@example.com', age=25\n  ✗ Rejected: Email format invalid\n\nTest 8: Email missing domain\n  Data: user='alice123', email='alice@', age=25\n  ✗ Rejected: Email format invalid\n\nTest 9: Email domain no dot\n  Data: user='alice123', email='alice@example', age=25\n  ✗ Rejected: Email domain must contain a dot (e.g., example.com)\n\nTest 10: Age too young\n  Data: user='alice123', email='alice@example.com', age=10\n  ✗ Rejected: Age must be between 13-120 (got 10)\n\nTest 11: Age too old\n  Data: user='alice123', email='alice@example.com', age=150\n  ✗ Rejected: Age must be between 13-120 (got 150)\n\nTest 12: Age is string\n  Data: user='alice123', email='alice@example.com', age=25\n  ✗ Rejected: Age must be an integer, got str\n\nTest 13: Password too short\n  Data: user='alice123', email='alice@example.com', age=25\n  ✗ Rejected: Password must be at least 8 characters (got 5)\n\nTest 14: Valid registration 2\n  Data: user='bob456', email='bob@test.co.uk', age=18\n  ✓ Registration accepted",
      "common_mistakes": [
        {
          "mistake": "Not checking for empty strings after stripping",
          "wrong_code": "if username:\n    # Still could be just spaces!",
          "correct_code": "username = username.strip()\nif not username:\n    raise ValueError(\"Empty\")",
          "explanation": "Always strip() first, THEN check if empty. A string of just spaces is truthy in Python but becomes empty after stripping. Check both: if not value or not value.strip()."
        },
        {
          "mistake": "Stripping passwords",
          "wrong_code": "password = password.strip()\nif len(password) < 8:\n    raise ValueError(\"Too short\")",
          "correct_code": "# Don't strip passwords!\nif len(password) < 8:\n    raise ValueError(\"Too short\")",
          "explanation": "Don't strip passwords! Leading/trailing spaces might be intentional and part of the password. Only strip usernames, emails, and display text."
        },
        {
          "mistake": "Using == True instead of truthiness",
          "wrong_code": "if username.isalnum() == True:  # Redundant",
          "correct_code": "if username.isalnum():  # Pythonic",
          "explanation": "Don't compare to True/False explicitly. if value: and if not value: are more Pythonic and shorter than if value == True: and if value == False:."
        },
        {
          "mistake": "Not providing helpful error messages",
          "wrong_code": "if len(username) < 3:\n    raise ValueError(\"Invalid\")  # Not helpful!",
          "correct_code": "if len(username) < 3:\n    raise ValueError(\n        f\"Username too short: must be 3+ chars, got {len(username)}\"\n    )",
          "explanation": "Error messages should be SPECIFIC and ACTIONABLE. Tell users: (1) what's wrong, (2) what's expected, (3) what they provided. This helps them fix the error."
        },
        {
          "mistake": "Forgetting type validation",
          "wrong_code": "def validate(age):\n    if age < 0:  # Crashes if age is a string!\n        raise ValueError(\"Negative\")",
          "correct_code": "def validate(age):\n    if not isinstance(age, int):\n        raise TypeError(\"Age must be int\")\n    if age < 0:\n        raise ValueError(\"Negative\")",
          "explanation": "Always validate types BEFORE using type-specific operations. if age < 0 will crash with TypeError if age is a string. Check type first with isinstance()."
        },
        {
          "mistake": "Validating in the wrong order",
          "wrong_code": "# Check length before checking if it exists!\nif len(username) < 3:\n    raise ValueError(\"Too short\")\nif not username:  # Should be first!\n    raise ValueError(\"Empty\")",
          "correct_code": "# Check existence first\nif not username:\n    raise ValueError(\"Empty\")\nif len(username) < 3:\n    raise ValueError(\"Too short\")",
          "explanation": "Validate in the right order: (1) not None, (2) not empty, (3) correct type, (4) correct format/range. Checking len() on None crashes. Check existence/type before using type-specific methods."
        }
      ]
    },
    {
      "type": "key_takeaways",
      "title": "Key Takeaways",
      "takeaways": [
        "**Always validate user input** - never trust it! Check type, format, range, and empty/null values before using input.",
        "**Defensive programming:** Assume everything can go wrong. Validate parameters, check types, handle edge cases, provide defaults.",
        "**Validation order:** (1) Check not None/empty, (2) Check type with isinstance(), (3) Sanitize (strip, lower), (4) Check format/range.",
        "**EAFP (Easier to Ask Forgiveness than Permission)** is more Pythonic than LBYL. Try the operation, catch exceptions if they occur.",
        "**LBYL (Look Before You Leap)** is okay for simple checks (if key in dict:) where readability matters more than performance.",
        "**Type checking:** Use isinstance(value, type) to check types. Can check multiple types: isinstance(x, (int, float)).",
        "**Provide actionable error messages:** Tell users what's wrong, what's expected, and what they provided. 'Age must be 13-120, got 10' beats 'Invalid age'.",
        "**Sanitize input:** Use .strip() to remove whitespace, .lower() for case-insensitive comparison. But DON'T strip passwords!",
        "**Range validation:** Always check numeric ranges (0 <= age <= 120), string lengths (3 <= len(username) <= 20), and limits."
      ]
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "What does EAFP stand for in Python programming?",
        "options": [
          "Execute And Fix Programming",
          "Easier to Ask Forgiveness than Permission",
          "Error And Failure Prevention",
          "Evaluate All Function Parameters"
        ],
        "correct_answer": 1,
        "explanation": "EAFP (Easier to Ask Forgiveness than Permission) means trying an operation and handling exceptions if they occur, rather than checking conditions first. This is the Pythonic approach: try: dictionary[key] except KeyError: handle_it() instead of if key in dictionary: value = dictionary[key]."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "What should you do BEFORE checking the length of a user input string?",
        "options": [
          "Convert it to lowercase",
          "Check if it's None and strip whitespace",
          "Check if it contains numbers",
          "Nothing - check length first"
        ],
        "correct_answer": 1,
        "explanation": "Always check if the string is None and strip whitespace BEFORE checking length. If you check len() on None, you'll get an error. Strip first because '   ' has length 3 but is effectively empty. Order: check None → strip → check if empty → check length."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "Why is it important to validate input types with isinstance() before performing operations?",
        "options": [
          "It makes code run faster",
          "It prevents TypeError exceptions when operations are performed on wrong types",
          "It's required by Python syntax",
          "It automatically converts types"
        ],
        "correct_answer": 1,
        "explanation": "Validating types with isinstance() prevents TypeError exceptions. For example, if you try age < 0 when age is a string '25', Python raises TypeError. Check isinstance(age, int) first to ensure it's a number before comparing. Type validation should happen before type-specific operations."
      }
    ]
  }
}
