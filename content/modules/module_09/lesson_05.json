{
  "lesson_id": "09_05",
  "title": "File Paths and Directory Operations",
  "module_id": 9,
  "order_index": 5,
  "description": "Master file system navigation with pathlib. Learn to work with file paths portably across Windows/Mac/Linux, create directories, list files, and manage the file system programmatically.",
  "estimated_minutes": 30,
  "content_blocks": [
    {
      "type": "the_simplifier",
      "title": "The Concept: GPS for Your File System",
      "content": "**The Problem: Hardcoded Paths Break**\n\n```python\n# Windows path\nfile = open('C:\\\\Users\\\\Alice\\\\Documents\\\\data.txt')\n\n# Mac/Linux path  \nfile = open('/home/alice/documents/data.txt')\n\n# Breaks when you share code!\n```\n\n**Real-world analogy: Street Addresses**\n\nImagine giving directions:\n- ‚ùå \"Go to 123 Main St, Apartment 4B\" (hardcoded - only works in one city)\n- ‚úÖ \"Go to my_home/living_room/couch\" (relative - works anywhere)\n\n**pathlib is your GPS for files:**\n- Cross-platform (works on Windows, Mac, Linux)\n- Relative paths (\"start from current location\")\n- Path operations (join, split, check existence)\n- Directory operations (create, list, delete)\n\n**Key concepts:**\n\n**1. Absolute vs Relative Paths:**\n```python\n# Absolute (full address from root)\n/home/alice/projects/myapp/data.txt\nC:\\Users\\Alice\\Projects\\myapp\\data.txt\n\n# Relative (from current location)\ndata.txt\n./data.txt\n../other_folder/file.txt\n```\n\n**2. Path Components:**\n```python\n/home/alice/projects/myapp/data.txt\n‚îÇ     ‚îÇ     ‚îÇ        ‚îÇ      ‚îÇ\n‚îÇ     ‚îÇ     ‚îÇ        ‚îÇ      ‚îî‚îÄ filename\n‚îÇ     ‚îÇ     ‚îÇ        ‚îî‚îÄ parent directory\n‚îÇ     ‚îÇ     ‚îî‚îÄ grandparent directory\n‚îÇ     ‚îî‚îÄ great-grandparent\n‚îî‚îÄ root\n```\n\n**3. Special paths:**\n- `.` = current directory\n- `..` = parent directory  \n- `~` = home directory\n- `/` = root directory (Unix)\n- `C:\\` = drive root (Windows)\n\n**Why pathlib over string concatenation:**\n\n‚ùå **Don't do this:**\n```python\npath = 'folder' + '/' + 'file.txt'  # Breaks on Windows!\npath = 'C:\\\\Users\\\\' + name  # Escape chars nightmare\n```\n\n‚úÖ **Do this:**\n```python\nfrom pathlib import Path\npath = Path('folder') / 'file.txt'  # Works everywhere!\n```"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Working with Paths",
      "code": "from pathlib import Path\nimport os\n\n# Example 1: Creating paths\nprint(\"=== Creating Paths ===\")\n\n# Current directory\ncurrent = Path.cwd()  # cwd = current working directory\nprint(f\"Current directory: {current}\")\n\n# Home directory\nhome = Path.home()\nprint(f\"Home directory: {home}\")\n\n# Build path with / operator (cross-platform!)\ndata_file = Path('data') / 'users.txt'\nprint(f\"Data file path: {data_file}\")\n\n# Multiple levels\nconfig_path = Path('config') / 'settings' / 'app.json'\nprint(f\"Config path: {config_path}\\n\")\n\n# Example 2: Path information\nprint(\"=== Path Information ===\")\n\npath = Path('projects/myapp/src/main.py')\n\nprint(f\"Full path: {path}\")\nprint(f\"Name: {path.name}\")  # main.py\nprint(f\"Stem: {path.stem}\")  # main (without extension)\nprint(f\"Suffix: {path.suffix}\")  # .py\nprint(f\"Parent: {path.parent}\")  # projects/myapp/src\nprint(f\"Parents[0]: {path.parents[0]}\")  # immediate parent\nprint(f\"Parents[1]: {path.parents[1]}\")  # grandparent\nprint(f\"Parts: {path.parts}\\n\")  # ('projects', 'myapp', 'src', 'main.py')\n\n# Example 3: Checking existence\nprint(\"=== Checking Existence ===\")\n\n# Create a test file\ntest_file = Path('test.txt')\ntest_file.write_text('Hello, World!')\n\nprint(f\"test.txt exists: {test_file.exists()}\")\nprint(f\"test.txt is file: {test_file.is_file()}\")\nprint(f\"test.txt is directory: {test_file.is_dir()}\")\n\n# Check non-existent\nfake = Path('nonexistent.txt')\nprint(f\"nonexistent.txt exists: {fake.exists()}\\n\")\n\n# Example 4: Creating directories\nprint(\"=== Creating Directories ===\")\n\n# Create single directory\nPath('output').mkdir(exist_ok=True)\nprint(\"‚úì Created 'output' directory\")\n\n# Create nested directories\nPath('data/processed/2024').mkdir(parents=True, exist_ok=True)\nprint(\"‚úì Created nested 'data/processed/2024' directories\\n\")\n\n# Example 5: Listing directory contents\nprint(\"=== Listing Directory Contents ===\")\n\n# List all items in current directory\nprint(\"Files in current directory:\")\nfor item in Path('.').iterdir():\n    if item.is_file():\n        print(f\"  üìÑ {item.name}\")\n\nprint(\"\\nDirectories in current directory:\")\nfor item in Path('.').iterdir():\n    if item.is_dir():\n        print(f\"  üìÅ {item.name}\")\n\n# Example 6: Glob patterns (finding files)\nprint(\"\\n=== Finding Files with Glob ===\")\n\n# Create some test files\nfor i in range(3):\n    (Path('output') / f'file{i}.txt').write_text(f'Content {i}')\n    (Path('output') / f'data{i}.json').write_text('{}')\n\nprint(\"Created test files in output/\")\n\n# Find all .txt files\nprint(\"\\nAll .txt files in output/:\")\nfor file in Path('output').glob('*.txt'):\n    print(f\"  - {file.name}\")\n\n# Find all .json files\nprint(\"\\nAll .json files in output/:\")\nfor file in Path('output').glob('*.json'):\n    print(f\"  - {file.name}\")\n\n# Recursive glob (search subdirectories too)\nprint(\"\\nAll .txt files (recursive):\")\nfor file in Path('.').rglob('*.txt'):\n    print(f\"  - {file}\")\n\nprint(\"\")\n\n# Example 7: Reading and writing with Path\nprint(\"=== Reading/Writing with Path ===\")\n\ndata_path = Path('data.txt')\n\n# Write text\ndata_path.write_text('Line 1\\nLine 2\\nLine 3\\n')\nprint(\"‚úì Wrote data.txt\")\n\n# Read text\ncontent = data_path.read_text()\nprint(\"\\nContent:\")\nprint(content)\n\n# Read lines\nlines = data_path.read_text().splitlines()\nprint(f\"Number of lines: {len(lines)}\\n\")\n\n# Example 8: Absolute vs Relative paths\nprint(\"=== Absolute vs Relative Paths ===\")\n\nrelative = Path('data/file.txt')\nprint(f\"Relative: {relative}\")\nprint(f\"Absolute: {relative.resolve()}\")\nprint(f\"Is absolute: {relative.is_absolute()}\")\n\nabsolute = Path.cwd() / 'data' / 'file.txt'\nprint(f\"\\nAbsolute: {absolute}\")\nprint(f\"Is absolute: {absolute.is_absolute()}\\n\")\n\n# Example 9: Joining paths safely\nprint(\"=== Joining Paths (Cross-Platform) ===\")\n\nbase = Path('projects')\nsubdir = 'myapp'\nfilename = 'config.json'\n\n# Method 1: / operator\npath1 = base / subdir / filename\nprint(f\"Using /: {path1}\")\n\n# Method 2: joinpath\npath2 = base.joinpath(subdir, filename)\nprint(f\"Using joinpath: {path2}\")\n\nprint(\"\\n‚úì Both create correct path for your OS!\")\nprint(\"(Forward slashes on Unix, backslashes on Windows)\")",
      "explanation": "**Key Path operations:**\n\n1. **Path.cwd()** - Current working directory\n2. **Path.home()** - User's home directory\n3. **Path() / 'file'** - Join paths (cross-platform!)\n4. **.exists()** - Check if path exists\n5. **.is_file() / .is_dir()** - Check type\n6. **.mkdir()** - Create directory\n7. **.glob(pattern)** - Find files matching pattern\n8. **.rglob(pattern)** - Recursive glob (search subdirectories)\n9. **.read_text() / .write_text()** - Quick file I/O\n10. **.resolve()** - Convert to absolute path\n\n**mkdir parameters:**\n- `parents=True` - Create parent directories if needed\n- `exist_ok=True` - Don't error if directory already exists",
      "output": "=== Creating Paths ===\nCurrent directory: /home/user/Python-Training-Course\nHome directory: /home/user\nData file path: data/users.txt\nConfig path: config/settings/app.json\n\n=== Path Information ===\nFull path: projects/myapp/src/main.py\nName: main.py\nStem: main\nSuffix: .py\nParent: projects/myapp/src\nParents[0]: projects/myapp/src\nParents[1]: projects/myapp\nParts: ('projects', 'myapp', 'src', 'main.py')\n\n=== Checking Existence ===\ntest.txt exists: True\ntest.txt is file: True\ntest.txt is directory: False\nnonexistent.txt exists: False\n\n=== Creating Directories ===\n‚úì Created 'output' directory\n‚úì Created nested 'data/processed/2024' directories\n\n=== Listing Directory Contents ===\nFiles in current directory:\n  üìÑ test.txt\n  üìÑ data.txt\n\nDirectories in current directory:\n  üìÅ output\n  üìÅ data\n  üìÅ content\n\n=== Finding Files with Glob ===\nCreated test files in output/\n\nAll .txt files in output/:\n  - file0.txt\n  - file1.txt\n  - file2.txt\n\nAll .json files in output/:\n  - data0.json\n  - data1.json\n  - data2.json\n\nAll .txt files (recursive):\n  - test.txt\n  - data.txt\n  - output/file0.txt\n  - output/file1.txt\n  - output/file2.txt\n\n=== Reading/Writing with Path ===\n‚úì Wrote data.txt\n\nContent:\nLine 1\nLine 2\nLine 3\n\nNumber of lines: 3\n\n=== Absolute vs Relative Paths ===\nRelative: data/file.txt\nAbsolute: /home/user/Python-Training-Course/data/file.txt\nIs absolute: False\n\nAbsolute: /home/user/Python-Training-Course/data/file.txt\nIs absolute: True\n\n=== Joining Paths (Cross-Platform) ===\nUsing /: projects/myapp/config.json\nUsing joinpath: projects/myapp/config.json\n\n‚úì Both create correct path for your OS!\n(Forward slashes on Unix, backslashes on Windows)"
    },
    {
      "type": "the_simplifier",
      "title": "Syntax Breakdown: pathlib Operations",
      "content": "**Import pathlib:**\n```python\nfrom pathlib import Path\n```\n\n**Creating paths:**\n```python\n# Current directory\nPath.cwd()\n\n# Home directory\nPath.home()\n\n# From string\nPath('folder/file.txt')\nPath('/absolute/path/file.txt')\n\n# Join paths (cross-platform!)\nPath('folder') / 'subfolder' / 'file.txt'\n```\n\n**Path information:**\n```python\npath = Path('projects/myapp/src/main.py')\n\npath.name      # 'main.py' (filename)\npath.stem      # 'main' (filename without extension)\npath.suffix    # '.py' (extension)\npath.parent    # Path('projects/myapp/src')\npath.parts     # ('projects', 'myapp', 'src', 'main.py')\n```\n\n**Checking existence:**\n```python\npath.exists()   # True if exists\npath.is_file()  # True if file\npath.is_dir()   # True if directory\npath.is_absolute()  # True if absolute path\n```\n\n**Creating directories:**\n```python\n# Create directory\nPath('output').mkdir()\n\n# Create with parents\nPath('data/processed/2024').mkdir(parents=True)\n\n# Don't error if exists\nPath('output').mkdir(exist_ok=True)\n\n# Both options\nPath('data/logs').mkdir(parents=True, exist_ok=True)\n```\n\n**Listing directory:**\n```python\n# List all items\nfor item in Path('.').iterdir():\n    print(item)\n\n# List only files\nfor item in Path('.').iterdir():\n    if item.is_file():\n        print(item)\n\n# List only directories\nfor item in Path('.').iterdir():\n    if item.is_dir():\n        print(item)\n```\n\n**Finding files (glob):**\n```python\n# All .txt files in directory\nfor file in Path('folder').glob('*.txt'):\n    print(file)\n\n# All .py files (recursive)\nfor file in Path('.').rglob('*.py'):\n    print(file)\n\n# Specific pattern\nfor file in Path('.').glob('data_*.csv'):\n    print(file)\n```\n\n**Reading/Writing:**\n```python\npath = Path('file.txt')\n\n# Write text\npath.write_text('Hello, World!')\n\n# Read text\ncontent = path.read_text()\n\n# Write bytes\npath.write_bytes(b'\\x00\\x01\\x02')\n\n# Read bytes\ndata = path.read_bytes()\n```\n\n**Path conversions:**\n```python\n# Relative to absolute\nrelative = Path('data/file.txt')\nabsolute = relative.resolve()\n\n# Path to string\npath_str = str(path)\n```\n\n**Deleting:**\n```python\n# Delete file\nPath('file.txt').unlink()\n\n# Delete empty directory\nPath('folder').rmdir()\n\n# Delete directory with contents (need shutil)\nimport shutil\nshutil.rmtree('folder')\n```\n\n**Common patterns:**\n\n**1. Process all files in directory:**\n```python\nfor file in Path('data').glob('*.csv'):\n    # Process each CSV file\n    content = file.read_text()\n    process(content)\n```\n\n**2. Create directory structure:**\n```python\nbase = Path('project')\n(base / 'src').mkdir(parents=True, exist_ok=True)\n(base / 'tests').mkdir(exist_ok=True)\n(base / 'data').mkdir(exist_ok=True)\n```\n\n**3. Safe file operations:**\n```python\npath = Path('data.txt')\n\nif path.exists():\n    content = path.read_text()\nelse:\n    print('File not found')\n```\n\n**Why pathlib is better:**\n\n‚ùå **Old way (os module):**\n```python\nimport os\npath = os.path.join('folder', 'file.txt')\nif os.path.exists(path):\n    with open(path) as f:\n        content = f.read()\n```\n\n‚úÖ **New way (pathlib):**\n```python\nfrom pathlib import Path\npath = Path('folder') / 'file.txt'\nif path.exists():\n    content = path.read_text()\n```"
    },
    {
      "type": "the_coder",
      "title": "Interactive Exercise: Project File Organizer",
      "instruction": "Create a file organizer that:\n1. Creates a project directory structure\n2. Finds all files of specific types\n3. Organizes files into folders by type\n4. Lists all files in the organized structure\n\n**Project structure to create:**\n```\nproject/\n  ‚îú‚îÄ‚îÄ images/\n  ‚îú‚îÄ‚îÄ documents/\n  ‚îú‚îÄ‚îÄ code/\n  ‚îî‚îÄ‚îÄ data/\n```\n\n**Your task:**\nImplement the functions below.\n\n**Starter code:**",
      "starter_code": "from pathlib import Path\n\ndef create_project_structure(base_path):\n    \"\"\"Create project directory structure.\n    \n    Args:\n        base_path: Base directory path (string or Path)\n    \"\"\"\n    # TODO: Convert to Path object\n    # TODO: Create base directory\n    # TODO: Create subdirectories: images, documents, code, data\n    # Use mkdir(parents=True, exist_ok=True)\n    pass\n\ndef find_files_by_extension(directory, extension):\n    \"\"\"Find all files with specific extension.\n    \n    Args:\n        directory: Directory to search\n        extension: File extension (e.g., '.txt', '.py')\n        \n    Returns:\n        list: List of Path objects\n    \"\"\"\n    # TODO: Convert directory to Path\n    # TODO: Use glob to find files with extension\n    # TODO: Return list of matching files\n    pass\n\ndef organize_files(source_dir, dest_dir):\n    \"\"\"Organize files by type into folders.\n    \n    Args:\n        source_dir: Source directory with mixed files\n        dest_dir: Destination directory (project structure)\n    \"\"\"\n    # TODO: Define file type mappings\n    # Images: .jpg, .png, .gif ‚Üí images/\n    # Documents: .txt, .pdf, .doc ‚Üí documents/\n    # Code: .py, .js, .html ‚Üí code/\n    # Data: .csv, .json, .xml ‚Üí data/\n    \n    # TODO: For each file in source_dir:\n    #   - Get file extension\n    #   - Determine destination folder\n    #   - Copy or move file to destination\n    pass\n\ndef list_project_files(project_dir):\n    \"\"\"List all files in project structure.\n    \n    Args:\n        project_dir: Project directory path\n    \"\"\"\n    # TODO: For each subdirectory:\n    #   - Print directory name\n    #   - List files in that directory\n    pass\n\n# Test your functions\nprint(\"=== File Organizer ===\")\n\nprint(\"\\n1. Creating project structure...\")\ncreate_project_structure('my_project')\n\nprint(\"\\n2. Creating test files...\")\n# Create some test files\ntest_files = [\n    'photo1.jpg', 'photo2.png',\n    'document.txt', 'report.pdf',\n    'script.py', 'app.js',\n    'data.csv', 'config.json'\n]\n\nfor filename in test_files:\n    Path(filename).write_text(f'Content of {filename}')\nprint(f\"‚úì Created {len(test_files)} test files\")\n\nprint(\"\\n3. Finding .jpg files...\")\njpg_files = find_files_by_extension('.', '.jpg')\nfor f in jpg_files:\n    print(f\"  - {f.name}\")\n\nprint(\"\\n4. Organizing files...\")\norganize_files('.', 'my_project')\n\nprint(\"\\n5. Project structure:\")\nlist_project_files('my_project')",
      "hint": "Use Path(dir).mkdir(parents=True, exist_ok=True) to create directories. Use Path(dir).glob('*' + extension) to find files. Use file.rename() or shutil.copy() to move files."
    },
    {
      "type": "the_coder",
      "title": "Solution & Common Mistakes",
      "solution_code": "from pathlib import Path\nimport shutil\n\ndef create_project_structure(base_path):\n    \"\"\"Create project directory structure.\"\"\"\n    base = Path(base_path)\n    \n    # Create subdirectories\n    folders = ['images', 'documents', 'code', 'data']\n    \n    for folder in folders:\n        (base / folder).mkdir(parents=True, exist_ok=True)\n    \n    print(f\"‚úì Created project structure at '{base}'\")\n    print(f\"  Folders: {', '.join(folders)}\")\n\ndef find_files_by_extension(directory, extension):\n    \"\"\"Find all files with specific extension.\"\"\"\n    dir_path = Path(directory)\n    \n    # Add dot if not present\n    if not extension.startswith('.'):\n        extension = '.' + extension\n    \n    # Find all matching files\n    files = list(dir_path.glob(f'*{extension}'))\n    \n    return files\n\ndef organize_files(source_dir, dest_dir):\n    \"\"\"Organize files by type into folders.\"\"\"\n    source = Path(source_dir)\n    dest = Path(dest_dir)\n    \n    # File type mappings\n    type_map = {\n        'images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp'],\n        'documents': ['.txt', '.pdf', '.doc', '.docx'],\n        'code': ['.py', '.js', '.html', '.css', '.java'],\n        'data': ['.csv', '.json', '.xml', '.yaml']\n    }\n    \n    moved_count = 0\n    \n    # Process each file\n    for file in source.iterdir():\n        if not file.is_file():\n            continue\n        \n        # Get file extension\n        ext = file.suffix.lower()\n        \n        # Find destination folder\n        dest_folder = None\n        for folder, extensions in type_map.items():\n            if ext in extensions:\n                dest_folder = folder\n                break\n        \n        # Move file if type matched\n        if dest_folder:\n            dest_path = dest / dest_folder / file.name\n            shutil.copy2(file, dest_path)\n            print(f\"  Moved {file.name} ‚Üí {dest_folder}/\")\n            moved_count += 1\n    \n    print(f\"\\n‚úì Organized {moved_count} files\")\n\ndef list_project_files(project_dir):\n    \"\"\"List all files in project structure.\"\"\"\n    project = Path(project_dir)\n    \n    for folder in sorted(project.iterdir()):\n        if folder.is_dir():\n            files = list(folder.glob('*'))\n            file_count = len(files)\n            \n            print(f\"\\nüìÅ {folder.name}/ ({file_count} files)\")\n            \n            for file in sorted(files):\n                if file.is_file():\n                    size = file.stat().st_size\n                    print(f\"  üìÑ {file.name} ({size} bytes)\")\n\n# ============================================================================\n# Comprehensive Testing\n# ============================================================================\n\nprint(\"=\" * 70)\nprint(\"FILE ORGANIZER - Project Structure Manager\")\nprint(\"=\" * 70)\n\nprint(\"\\n1. Creating project structure...\")\nprint(\"-\" * 70)\ncreate_project_structure('my_project')\n\nprint(\"\\n2. Creating test files...\")\nprint(\"-\" * 70)\n\ntest_files = {\n    'vacation.jpg': 'JPEG image data',\n    'screenshot.png': 'PNG image data',\n    'notes.txt': 'Meeting notes\\nTodo list',\n    'report.pdf': 'PDF document data',\n    'calculator.py': 'print(\"Hello, Python!\")',\n    'website.html': '<html><body>Hello</body></html>',\n    'sales.csv': 'Date,Amount\\n2024-01-01,100',\n    'config.json': '{\"debug\": true}',\n    'README.md': '# My Project',  # Won't be organized\n    'data.xml': '<root><item>value</item></root>'\n}\n\nfor filename, content in test_files.items():\n    Path(filename).write_text(content)\n\nprint(f\"‚úì Created {len(test_files)} test files\")\n\nprint(\"\\n3. Finding specific file types...\")\nprint(\"-\" * 70)\n\nprint(\"Image files (.jpg, .png):\")\nfor ext in ['.jpg', '.png']:\n    files = find_files_by_extension('.', ext)\n    for f in files:\n        print(f\"  - {f.name}\")\n\nprint(\"\\nPython files:\")\npy_files = find_files_by_extension('.', '.py')\nfor f in py_files:\n    print(f\"  - {f.name}\")\n\nprint(\"\\n4. Organizing files into project structure...\")\nprint(\"-\" * 70)\norganize_files('.', 'my_project')\n\nprint(\"\\n5. Final project structure:\")\nprint(\"=\" * 70)\nlist_project_files('my_project')\n\nprint(\"\\n\" + \"=\" * 70)\nprint(\"‚úì File organization complete!\")\nprint(f\"Project location: {Path('my_project').resolve()}\")\nprint(\"=\" * 70)",
      "explanation": "The solution demonstrates:\n\n**Key techniques:**\n1. **mkdir(parents=True, exist_ok=True)** - Safely create directories\n2. **glob()** - Find files by pattern\n3. **iterdir()** - List directory contents\n4. **suffix** - Get file extension\n5. **shutil.copy2()** - Copy files preserving metadata\n6. **stat().st_size** - Get file size\n\n**File organization pattern:**\n- Define type mappings (extension ‚Üí folder)\n- Iterate through files\n- Match extension to folder\n- Copy to destination\n\n**Why pathlib is perfect for this:**\n- Cross-platform paths\n- Clean syntax with / operator\n- Built-in methods for common operations\n- Object-oriented approach",
      "output": "======================================================================\nFILE ORGANIZER - Project Structure Manager\n======================================================================\n\n1. Creating project structure...\n----------------------------------------------------------------------\n‚úì Created project structure at 'my_project'\n  Folders: images, documents, code, data\n\n2. Creating test files...\n----------------------------------------------------------------------\n‚úì Created 10 test files\n\n3. Finding specific file types...\n----------------------------------------------------------------------\nImage files (.jpg, .png):\n  - vacation.jpg\n  - screenshot.png\n\nPython files:\n  - calculator.py\n\n4. Organizing files into project structure...\n----------------------------------------------------------------------\n  Moved vacation.jpg ‚Üí images/\n  Moved screenshot.png ‚Üí images/\n  Moved notes.txt ‚Üí documents/\n  Moved report.pdf ‚Üí documents/\n  Moved calculator.py ‚Üí code/\n  Moved website.html ‚Üí code/\n  Moved sales.csv ‚Üí data/\n  Moved config.json ‚Üí data/\n  Moved data.xml ‚Üí data/\n\n‚úì Organized 9 files\n\n5. Final project structure:\n======================================================================\n\nüìÅ code/ (2 files)\n  üìÑ calculator.py (25 bytes)\n  üìÑ website.html (29 bytes)\n\nüìÅ data/ (3 files)\n  üìÑ config.json (16 bytes)\n  üìÑ data.xml (28 bytes)\n  üìÑ sales.csv (28 bytes)\n\nüìÅ documents/ (2 files)\n  üìÑ notes.txt (24 bytes)\n  üìÑ report.pdf (18 bytes)\n\nüìÅ images/ (2 files)\n  üìÑ screenshot.png (14 bytes)\n  üìÑ vacation.jpg (15 bytes)\n\n======================================================================\n‚úì File organization complete!\nProject location: /home/user/Python-Training-Course/my_project\n======================================================================",
      "common_mistakes": [
        {
          "mistake": "Using string concatenation instead of / operator",
          "wrong_code": "path = 'folder' + '/' + 'file.txt'  # Breaks on Windows!",
          "correct_code": "path = Path('folder') / 'file.txt'  # Cross-platform",
          "explanation": "Always use the / operator to join paths. It automatically uses the correct separator for your OS (/ on Unix, \\\\ on Windows). String concatenation with '/' only works on Unix."
        },
        {
          "mistake": "Not using exist_ok=True when creating directories",
          "wrong_code": "Path('output').mkdir()  # Errors if exists!",
          "correct_code": "Path('output').mkdir(exist_ok=True)",
          "explanation": "mkdir() raises FileExistsError if directory already exists. Always use exist_ok=True unless you specifically want to error on existing directories. Similarly, use parents=True to create parent directories."
        },
        {
          "mistake": "Forgetting to convert strings to Path objects",
          "wrong_code": "files = 'folder'.glob('*.txt')  # Error!",
          "correct_code": "files = Path('folder').glob('*.txt')",
          "explanation": "String objects don't have Path methods like glob(), iterdir(), etc. Always convert strings to Path objects with Path(string_path) before using Path methods."
        },
        {
          "mistake": "Using hardcoded path separators",
          "wrong_code": "path = 'C:\\\\Users\\\\name\\\\file.txt'  # Windows only!",
          "correct_code": "path = Path.home() / 'file.txt'  # Cross-platform",
          "explanation": "Never hardcode path separators (/ or \\\\). Use Path() and the / operator for cross-platform code. Path('C:\\\\...') only works on Windows; Path('/home/...') only works on Unix."
        },
        {
          "mistake": "Not checking if path exists before operations",
          "wrong_code": "content = Path('file.txt').read_text()  # May crash!",
          "correct_code": "path = Path('file.txt')\nif path.exists():\n    content = path.read_text()\nelse:\n    print('File not found')",
          "explanation": "Always check exists() before reading/writing. Even if file existed earlier, it might be deleted by another process. Use exists(), is_file(), or is_dir() to check first."
        }
      ]
    },
    {
      "type": "key_takeaways",
      "title": "Key Takeaways",
      "takeaways": [
        "**from pathlib import Path** - Modern, cross-platform way to work with file paths. Replaces old os.path module.",
        "**Path() / 'file'** - Join paths with / operator. Works on Windows, Mac, Linux automatically. Better than string concatenation.",
        "**Path.cwd()** - Current working directory. **Path.home()** - User's home directory. Starting points for paths.",
        "**.mkdir(parents=True, exist_ok=True)** - Safely create directories. parents=True creates parent dirs, exist_ok=True doesn't error if exists.",
        "**.glob(pattern)** - Find files matching pattern. **.rglob(pattern)** - Recursive glob (search subdirectories too).",
        "**.exists(), .is_file(), .is_dir()** - Check if path exists and what type it is. Always check before operations.",
        "**.name, .stem, .suffix, .parent** - Get path components. name=filename, stem=filename without extension, suffix=extension, parent=parent directory.",
        "**.read_text() / .write_text()** - Quick file I/O. For simple text files, easier than open().",
        "**.iterdir()** - List directory contents. Returns Path objects for each item. Use .is_file() or .is_dir() to filter.",
        "**Cross-platform:** pathlib handles path differences between OS automatically. Write once, works everywhere!"
      ]
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "What's the advantage of using Path() / 'file' over string concatenation?",
        "options": [
          "It's faster",
          "It automatically uses the correct path separator for your OS (cross-platform)",
          "It uses less memory",
          "It's required by Python"
        ],
        "correct_answer": 1,
        "explanation": "Path() / 'file' automatically uses the correct path separator for your OS - forward slash (/) on Unix/Mac, backslash (\\) on Windows. String concatenation with '/' only works on Unix. The / operator makes code cross-platform."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "What does mkdir(parents=True, exist_ok=True) do?",
        "options": [
          "Only creates the directory if it doesn't exist",
          "Creates parent directories if needed AND doesn't error if directory exists",
          "Deletes existing directory and creates new one",
          "Creates directory only if parent exists"
        ],
        "correct_answer": 1,
        "explanation": "parents=True creates parent directories if they don't exist (like mkdir -p). exist_ok=True doesn't raise an error if the directory already exists. Together, they make mkdir() safe to call multiple times."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "What's the difference between glob() and rglob()?",
        "options": [
          "glob is faster than rglob",
          "glob searches current directory only, rglob searches recursively (subdirectories too)",
          "glob is for files, rglob is for directories",
          "They're the same"
        ],
        "correct_answer": 1,
        "explanation": "glob() searches only in the specified directory. rglob() (recursive glob) searches the directory AND all subdirectories. Use glob('*.txt') for current directory, rglob('*.txt') to find all .txt files everywhere below."
      }
    ]
  }
}
