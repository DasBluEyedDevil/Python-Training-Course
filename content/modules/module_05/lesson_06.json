{
  "title": "Mini-Project: Student Grade Analytics System",
  "estimated_time": "40 minutes",
  "concept": "<p>You're building a <strong>Student Grade Analytics System</strong> that processes student data, calculates statistics, and generates reports. This project combines everything from Module 5:</p><ul><li><strong>Lists</strong>: Store students and grades</li><li><strong>Tuples</strong>: Immutable student records</li><li><strong>Slicing</strong>: Extract data ranges</li><li><strong>List Methods</strong>: Sort, filter, manipulate data</li><li><strong>List Comprehensions</strong>: Transform and filter efficiently</li></ul><h3>Project Overview:</h3><pre style='background-color: #f0f0f0; padding: 10px;'>=== Student Grade Analytics System ===\n\n1. Data Management\n   - Store student records as tuples (id, name, grades)\n   - Add/remove students\n   - Update grades\n\n2. Grade Analysis\n   - Calculate averages, highs, lows\n   - Find honor roll students\n   - Identify students needing help\n\n3. Report Generation\n   - Generate formatted reports\n   - Display statistics\n   - Create visualizations (text-based)\n\n4. Data Transformations\n   - Apply grade curves\n   - Filter by performance\n   - Sort by various criteria\n</pre><h3>Technical Requirements:</h3><ol><li><strong>Student Record</strong>: Tuple of (id, name, [grades])</li><li><strong>Grade List</strong>: List of test scores per student</li><li><strong>Class Data</strong>: List of student tuples</li><li><strong>Statistics</strong>: Calculated using list comprehensions</li><li><strong>Filtering</strong>: Use slicing and comprehensions</li></ol><h3>Features You'll Implement:</h3><h4>1. Data Storage</h4><pre><code># Each student is a tuple:\n(101, \"Alice\", [85, 92, 88, 95, 90])\n(102, \"Bob\", [78, 82, 75, 88, 80])\n\n# Why tuples?\n# - Student ID and name shouldn't change\n# - Grade list CAN change (it's nested, not part of tuple immutability)\n</code></pre><h4>2. Calculations with Comprehensions</h4><pre><code># Average grade per student\naverages = [sum(grades)/len(grades) for (id, name, grades) in students]\n\n# Students with A averages\na_students = [(name, avg) for (id, name, grades), avg in zip(students, averages) if avg >= 90]\n\n# All grades flattened\nall_grades = [grade for (id, name, grades) in students for grade in grades]\n</code></pre><h4>3. Slicing for Reports</h4><pre><code># Top 3 students\ntop_3 = sorted_students[:3]\n\n# Bottom quarter\nbottom_quarter = sorted_students[:len(sorted_students)//4]\n\n# Middle range\nmiddle = sorted_students[len(sorted_students)//4:3*len(sorted_students)//4]\n</code></pre><h4>4. Text-Based Visualizations</h4><pre><code># Grade distribution bar chart\nfor student_id, name, grades in students:\n    avg = sum(grades) / len(grades)\n    bar_length = int(avg / 5)  # Each * = 5 points\n    bar = \"*\" * bar_length\n    print(f\"{name:15} {avg:5.1f} {bar}\")\n\n# Output:\n# Alice           90.0 ******************\n# Bob             80.6 ****************\n</code></pre><h3>Sample Workflow:</h3><pre><code>1. Load student data (or generate sample data)\n2. Display all students with their averages\n3. Calculate class statistics (min, max, mean, median)\n4. Generate honor roll (avg >= 90)\n5. Identify at-risk students (avg < 70)\n6. Apply grade curve (add 5 points to all grades)\n7. Show top/bottom performers\n8. Create grade distribution chart\n9. Export report\n</code></pre><h3>Skills You'll Practice:</h3><ul><li>Working with nested data structures</li><li>Tuple unpacking in loops</li><li>List comprehensions with filters</li><li>Slicing for data extraction</li><li>Sorting with custom keys</li><li>Data aggregation and statistics</li><li>Text formatting and output</li></ul>",

  "code_example": {
    "code": "# Mini-Project: Student Grade Analytics System\n# Complete implementation demonstrating all Module 5 concepts\n\nprint(\"=\" * 70)\nprint(\"STUDENT GRADE ANALYTICS SYSTEM\")\nprint(\"=\" * 70)\nprint()\n\n# ========================================\n# PART 1: DATA SETUP\n# ========================================\n\nprint(\"=== Part 1: Data Setup ===\")\nprint()\n\n# Student records: (ID, Name, [Grades])\n# Using tuples because ID and name shouldn't change\nstudents = [\n    (101, \"Alice Johnson\", [85, 92, 88, 95, 90]),\n    (102, \"Bob Smith\", [78, 82, 75, 88, 80]),\n    (103, \"Charlie Brown\", [92, 95, 98, 94, 96]),\n    (104, \"Diana Ross\", [68, 72, 65, 70, 73]),\n    (105, \"Eve Adams\", [88, 91, 85, 92, 89]),\n    (106, \"Frank Miller\", [55, 62, 58, 60, 65]),\n    (107, \"Grace Lee\", [95, 98, 92, 97, 94]),\n    (108, \"Henry Davis\", [82, 85, 88, 81, 84])\n]\n\nprint(f\"Loaded {len(students)} student records\")\nprint(f\"Sample record: {students[0]}\")\nprint()\n\n# ========================================\n# PART 2: DISPLAY ALL STUDENTS\n# ========================================\n\nprint(\"=== Part 2: All Students ===\")\nprint()\nprint(f\"{'ID':<8} {'Name':<20} {'Grades':<30} {'Average':<10}\")\nprint(\"-\" * 70)\n\nfor student_id, name, grades in students:  # Tuple unpacking\n    avg = sum(grades) / len(grades)\n    grades_str = str(grades)\n    print(f\"{student_id:<8} {name:<20} {grades_str:<30} {avg:<10.2f}\")\n\nprint()\n\n# ========================================\n# PART 3: CALCULATE STATISTICS\n# ========================================\n\nprint(\"=== Part 3: Class Statistics ===\")\nprint()\n\n# Calculate average for each student (list comprehension)\naverages = [sum(grades)/len(grades) for (id, name, grades) in students]\n\n# Overall class statistics\nclass_avg = sum(averages) / len(averages)\nhighest_avg = max(averages)\nlowest_avg = min(averages)\n\n# Get all individual grades (flatten nested lists)\nall_grades = [grade for (id, name, grades) in students for grade in grades]\n\nprint(f\"Total students: {len(students)}\")\nprint(f\"Total grades recorded: {len(all_grades)}\")\nprint(f\"Class average: {class_avg:.2f}\")\nprint(f\"Highest student average: {highest_avg:.2f}\")\nprint(f\"Lowest student average: {lowest_avg:.2f}\")\nprint(f\"Highest individual grade: {max(all_grades)}\")\nprint(f\"Lowest individual grade: {min(all_grades)}\")\n\nprint()\n\n# ========================================\n# PART 4: HONOR ROLL (Average >= 90)\n# ========================================\n\nprint(\"=== Part 4: Honor Roll (Average >= 90) ===\")\nprint()\n\n# Create list of (name, average) for honor roll students\nhonor_roll = [\n    (name, sum(grades)/len(grades)) \n    for (id, name, grades) in students \n    if sum(grades)/len(grades) >= 90\n]\n\nif honor_roll:\n    print(f\"Congratulations to {len(honor_roll)} students on the Honor Roll!\")\n    print()\n    for name, avg in honor_roll:\n        print(f\"  ‚≠ê {name:<20} Average: {avg:.2f}\")\nelse:\n    print(\"No students qualified for honor roll this term.\")\n\nprint()\n\n# ========================================\n# PART 5: AT-RISK STUDENTS (Average < 70)\n# ========================================\n\nprint(\"=== Part 5: At-Risk Students (Average < 70) ===\")\nprint()\n\nat_risk = [\n    (name, sum(grades)/len(grades))\n    for (id, name, grades) in students\n    if sum(grades)/len(grades) < 70\n]\n\nif at_risk:\n    print(f\"‚ö†Ô∏è  {len(at_risk)} students need additional support:\")\n    print()\n    for name, avg in at_risk:\n        print(f\"  {name:<20} Average: {avg:.2f}\")\nelse:\n    print(\"‚úì All students are performing well (>= 70)\")\n\nprint()\n\n# ========================================\n# PART 6: RANKING (Sorted by Average)\n# ========================================\n\nprint(\"=== Part 6: Student Rankings ===\")\nprint()\n\n# Create list of (name, average) and sort by average (descending)\nranked = [(name, sum(grades)/len(grades)) for (id, name, grades) in students]\nranked.sort(key=lambda x: x[1], reverse=True)  # Sort by average\n\nprint(\"Top to Bottom:\")\nfor rank, (name, avg) in enumerate(ranked, start=1):\n    print(f\"  #{rank:<3} {name:<20} {avg:.2f}\")\n\nprint()\n\n# Top 3 using slicing\nprint(\"üèÜ Top 3 Performers:\")\nfor rank, (name, avg) in enumerate(ranked[:3], start=1):\n    medal = [\"ü•á\", \"ü•à\", \"ü•â\"][rank-1]\n    print(f\"  {medal} #{rank} {name:<20} {avg:.2f}\")\n\nprint()\n\n# Bottom 3 using negative slicing\nprint(\"üìâ Bottom 3 (Need Improvement):\")\nfor name, avg in ranked[-3:]:\n    print(f\"  {name:<20} {avg:.2f}\")\n\nprint()\n\n# ========================================\n# PART 7: GRADE DISTRIBUTION\n# ========================================\n\nprint(\"=== Part 7: Grade Distribution ===\")\nprint()\n\n# Count students in each grade range\na_count = len([avg for avg in averages if avg >= 90])\nb_count = len([avg for avg in averages if 80 <= avg < 90])\nc_count = len([avg for avg in averages if 70 <= avg < 80])\nd_count = len([avg for avg in averages if 60 <= avg < 70])\nf_count = len([avg for avg in averages if avg < 60])\n\nprint(\"Letter Grade Distribution:\")\nprint(f\"  A (90+):  {a_count:2} students {'*' * a_count}\")\nprint(f\"  B (80+):  {b_count:2} students {'*' * b_count}\")\nprint(f\"  C (70+):  {c_count:2} students {'*' * c_count}\")\nprint(f\"  D (60+):  {d_count:2} students {'*' * d_count}\")\nprint(f\"  F (<60):  {f_count:2} students {'*' * f_count}\")\n\nprint()\n\n# ========================================\n# PART 8: GRADE CURVE (+5 points)\n# ========================================\n\nprint(\"=== Part 8: Apply Grade Curve (+5 points) ===\")\nprint()\n\nprint(\"Before curve:\")\nprint(f\"  Class average: {class_avg:.2f}\")\n\n# Apply curve: add 5 to each grade, cap at 100\ncurved_students = [\n    (id, name, [min(grade + 5, 100) for grade in grades])  # List comprehension for curve\n    for (id, name, grades) in students\n]\n\n# Recalculate averages after curve\ncurved_averages = [sum(grades)/len(grades) for (id, name, grades) in curved_students]\ncurved_class_avg = sum(curved_averages) / len(curved_averages)\n\nprint(f\"\\nAfter curve:\")\nprint(f\"  Class average: {curved_class_avg:.2f}\")\nprint(f\"  Improvement: +{curved_class_avg - class_avg:.2f} points\")\n\nprint()\nprint(\"Sample student (before ‚Üí after):\")\nfor i in [0, 3]:  # Show first and fourth student\n    id, name, old_grades = students[i]\n    _, _, new_grades = curved_students[i]\n    print(f\"  {name}:\")\n    print(f\"    Before: {old_grades} ‚Üí Avg: {sum(old_grades)/len(old_grades):.2f}\")\n    print(f\"    After:  {new_grades} ‚Üí Avg: {sum(new_grades)/len(new_grades):.2f}\")\n\nprint()\n\n# ========================================\n# PART 9: GRADE TREND ANALYSIS\n# ========================================\n\nprint(\"=== Part 9: Grade Trends (First vs Last Test) ===\")\nprint()\n\nfor student_id, name, grades in students:\n    first_test = grades[0]      # First grade\n    last_test = grades[-1]      # Last grade\n    change = last_test - first_test\n    \n    trend = \"üìà Improving\" if change > 0 else \"üìâ Declining\" if change < 0 else \"‚û°Ô∏è  Stable\"\n    \n    print(f\"{name:<20} {first_test:3} ‚Üí {last_test:3} ({change:+3}) {trend}\")\n\nprint()\n\n# ========================================\n# PART 10: TEST DIFFICULTY ANALYSIS\n# ========================================\n\nprint(\"=== Part 10: Test Difficulty Analysis ===\")\nprint()\n\n# Calculate average for each test across all students\nnum_tests = len(students[0][2])  # Assuming all students have same number of tests\n\ntest_averages = [\n    sum([grades[test_num] for (id, name, grades) in students]) / len(students)\n    for test_num in range(num_tests)\n]\n\nprint(\"Average score per test:\")\nfor test_num, avg in enumerate(test_averages, start=1):\n    bar = \"*\" * int(avg / 5)  # Each * = 5 points\n    difficulty = \"Hard\" if avg < 75 else \"Medium\" if avg < 85 else \"Easy\"\n    print(f\"  Test {test_num}: {avg:5.1f} {bar} ({difficulty})\")\n\nprint()\n\n# Hardest and easiest tests\nhardest_test = test_averages.index(min(test_averages)) + 1\neasiest_test = test_averages.index(max(test_averages)) + 1\n\nprint(f\"Hardest test: Test {hardest_test} (avg: {min(test_averages):.1f})\")\nprint(f\"Easiest test: Test {easiest_test} (avg: {max(test_averages):.1f})\")\n\nprint()\n\n# ========================================\n# PART 11: FINAL REPORT\n# ========================================\n\nprint(\"=\" * 70)\nprint(\"FINAL SUMMARY REPORT\")\nprint(\"=\" * 70)\nprint()\n\nprint(f\"Class Size: {len(students)} students\")\nprint(f\"Tests Administered: {num_tests}\")\nprint(f\"Total Grades: {len(all_grades)}\")\nprint()\nprint(f\"Class Average: {class_avg:.2f}\")\nprint(f\"Honor Roll: {len(honor_roll)} students\")\nprint(f\"At-Risk: {len(at_risk)} students\")\nprint()\nprint(f\"Top Performer: {ranked[0][0]} ({ranked[0][1]:.2f})\")\nprint(f\"Needs Support: {ranked[-1][0]} ({ranked[-1][1]:.2f})\")\nprint()\nprint(f\"Grade Distribution: {a_count} A's, {b_count} B's, {c_count} C's, {d_count} D's, {f_count} F's\")\nprint()\nprint(\"‚úì Analysis complete!\")",
    "output": "======================================================================\nSTUDENT GRADE ANALYTICS SYSTEM\n======================================================================\n\n=== Part 1: Data Setup ===\n\nLoaded 8 student records\nSample record: (101, 'Alice Johnson', [85, 92, 88, 95, 90])\n\n=== Part 2: All Students ===\n\nID       Name                 Grades                         Average   \n----------------------------------------------------------------------\n101      Alice Johnson        [85, 92, 88, 95, 90]           90.00     \n102      Bob Smith            [78, 82, 75, 88, 80]           80.60     \n103      Charlie Brown        [92, 95, 98, 94, 96]           95.00     \n104      Diana Ross           [68, 72, 65, 70, 73]           69.60     \n105      Eve Adams            [88, 91, 85, 92, 89]           89.00     \n106      Frank Miller         [55, 62, 58, 60, 65]           60.00     \n107      Grace Lee            [95, 98, 92, 97, 94]           95.20     \n108      Henry Davis          [82, 85, 88, 81, 84]           84.00     \n\n=== Part 3: Class Statistics ===\n\nTotal students: 8\nTotal grades recorded: 40\nClass average: 82.93\nHighest student average: 95.20\nLowest student average: 60.00\nHighest individual grade: 98\nLowest individual grade: 55\n\n=== Part 4: Honor Roll (Average >= 90) ===\n\nCongratulations to 3 students on the Honor Roll!\n\n  ‚≠ê Alice Johnson       Average: 90.00\n  ‚≠ê Charlie Brown       Average: 95.00\n  ‚≠ê Grace Lee           Average: 95.20\n\n=== Part 5: At-Risk Students (Average < 70) ===\n\n‚ö†Ô∏è  2 students need additional support:\n\n  Diana Ross           Average: 69.60\n  Frank Miller         Average: 60.00\n\n=== Part 6: Student Rankings ===\n\nTop to Bottom:\n  #1   Grace Lee            95.20\n  #2   Charlie Brown        95.00\n  #3   Alice Johnson        90.00\n  #4   Eve Adams            89.00\n  #5   Henry Davis          84.00\n  #6   Bob Smith            80.60\n  #7   Diana Ross           69.60\n  #8   Frank Miller         60.00\n\nüèÜ Top 3 Performers:\n  ü•á #1 Grace Lee            95.20\n  ü•à #2 Charlie Brown        95.00\n  ü•â #3 Alice Johnson        90.00\n\nüìâ Bottom 3 (Need Improvement):\n  Bob Smith            80.60\n  Diana Ross           69.60\n  Frank Miller         60.00\n\n=== Part 7: Grade Distribution ===\n\nLetter Grade Distribution:\n  A (90+):   3 students ***\n  B (80+):   2 students **\n  C (70+):   0 students \n  D (60+):   2 students **\n  F (<60):   1 students *\n\n=== Part 8: Apply Grade Curve (+5 points) ===\n\nBefore curve:\n  Class average: 82.93\n\nAfter curve:\n  Class average: 87.93\n  Improvement: +5.00 points\n\nSample student (before ‚Üí after):\n  Alice Johnson:\n    Before: [85, 92, 88, 95, 90] ‚Üí Avg: 90.00\n    After:  [90, 97, 93, 100, 95] ‚Üí Avg: 95.00\n  Diana Ross:\n    Before: [68, 72, 65, 70, 73] ‚Üí Avg: 69.60\n    After:  [73, 77, 70, 75, 78] ‚Üí Avg: 74.60\n\n=== Part 9: Grade Trends (First vs Last Test) ===\n\nAlice Johnson         85 ‚Üí  90 ( +5) üìà Improving\nBob Smith             78 ‚Üí  80 ( +2) üìà Improving\nCharlie Brown         92 ‚Üí  96 ( +4) üìà Improving\nDiana Ross            68 ‚Üí  73 ( +5) üìà Improving\nEve Adams             88 ‚Üí  89 ( +1) üìà Improving\nFrank Miller          55 ‚Üí  65 (+10) üìà Improving\nGrace Lee             95 ‚Üí  94 ( -1) üìâ Declining\nHenry Davis           82 ‚Üí  84 ( +2) üìà Improving\n\n=== Part 10: Test Difficulty Analysis ===\n\nAverage score per test:\n  Test 1:  80.4 **************** (Medium)\n  Test 2:  84.6 **************** (Easy)\n  Test 3:  81.1 **************** (Medium)\n  Test 4:  84.4 **************** (Easy)\n  Test 5:  83.9 **************** (Medium)\n\nHardest test: Test 1 (avg: 80.4)\nEasiest test: Test 2 (avg: 84.6)\n\n======================================================================\nFINAL SUMMARY REPORT\n======================================================================\n\nClass Size: 8 students\nTests Administered: 5\nTotal Grades: 40\n\nClass Average: 82.93\nHonor Roll: 3 students\nAt-Risk: 2 students\n\nTop Performer: Grace Lee (95.20)\nNeeds Support: Frank Miller (60.00)\n\nGrade Distribution: 3 A's, 2 B's, 0 C's, 2 D's, 1 F's\n\n‚úì Analysis complete!"
  },

  "syntax_breakdown": "<h3>Module 5 Concepts Used:</h3><h4>1. Tuples for Student Records</h4><pre><code># Immutable record structure\nstudent = (101, \"Alice Johnson\", [85, 92, 88, 95, 90])\n#          ‚Üì    ‚Üì                ‚Üì\n#          ID   Name            Grades (mutable list)\n\n# Tuple unpacking in loop\nfor student_id, name, grades in students:\n    # student_id = 101\n    # name = \"Alice Johnson\"\n    # grades = [85, 92, 88, 95, 90]\n</code></pre><p><strong>Why tuples?</strong> Student ID and name are fixed, but grades can be updated.</p><h4>2. List Comprehensions for Calculations</h4><pre><code># Calculate average for each student\naverages = [sum(grades)/len(grades) for (id, name, grades) in students]\n\n# Breakdown:\n# - For each student tuple\n# - Unpack to get grades\n# - Calculate sum/length\n# - Create new list of averages\n\n# Filter honor roll students\nhonor_roll = [\n    (name, sum(grades)/len(grades))  # Create tuple of (name, avg)\n    for (id, name, grades) in students  # For each student\n    if sum(grades)/len(grades) >= 90    # Filter: avg >= 90\n]\n</code></pre><h4>3. Nested List Comprehension (Flattening)</h4><pre><code># Get all individual grades from all students\nall_grades = [grade for (id, name, grades) in students for grade in grades]\n\n# Reads as:\n# \"For each student in students,\n#  for each grade in that student's grades,\n#  take the grade\"\n\n# Equivalent loop:\nall_grades = []\nfor (id, name, grades) in students:\n    for grade in grades:\n        all_grades.append(grade)\n</code></pre><h4>4. Slicing for Top/Bottom</h4><pre><code># Assuming ranked is sorted by average (high to low)\n\n# Top 3 students\ntop_3 = ranked[:3]  # First 3\n\n# Bottom 3 students  \nbottom_3 = ranked[-3:]  # Last 3\n\n# Top half\ntop_half = ranked[:len(ranked)//2]\n\n# Bottom quarter\nbottom_quarter = ranked[:len(ranked)//4]\n</code></pre><h4>5. Conditional List Comprehension (Grade Curve)</h4><pre><code># Apply curve: +5 points, capped at 100\ncurved_students = [\n    (id, name, [min(grade + 5, 100) for grade in grades])\n    for (id, name, grades) in students\n]\n\n# Breakdown:\n# Inner comprehension: [min(grade + 5, 100) for grade in grades]\n#   - For each grade, add 5\n#   - Cap at 100 using min()\n# Outer comprehension: Create new student tuple with curved grades\n</code></pre><h4>6. Sorting with Custom Key</h4><pre><code># Create list of (name, average) tuples\nranked = [(name, sum(grades)/len(grades)) for (id, name, grades) in students]\n\n# Sort by average (second element of tuple)\nranked.sort(key=lambda x: x[1], reverse=True)\n#                       ‚Üì\n#                  x[1] = average\n\n# Descending order (highest first)\n</code></pre><h4>7. List Methods</h4><pre><code># Count students in grade range\na_count = len([avg for avg in averages if avg >= 90])\n\n# Find max/min\nhighest = max(averages)\nlowest = min(averages)\n\n# Get index of min/max\nhardest_test = test_averages.index(min(test_averages))\n</code></pre><h4>8. String Formatting</h4><pre><code># Aligned columns\nprint(f\"{id:<8} {name:<20} {avg:<10.2f}\")\n#        ‚Üì       ‚Üì            ‚Üì\n#     Left    Left         Left aligned,\n#     8 chars 20 chars     10 chars, 2 decimals\n\n# Conditional formatting\ntrend = \"üìà Improving\" if change > 0 else \"üìâ Declining\" if change < 0 else \"‚û°Ô∏è  Stable\"\n</code></pre><h3>Data Flow Diagram:</h3><pre>Raw Data (Tuples)\n     ‚Üì\n[(101, \"Alice\", [85, 92, ...]), ...]\n     ‚Üì\nTuple Unpacking\n     ‚Üì\nid=101, name=\"Alice\", grades=[85,92,...]\n     ‚Üì\nList Comprehension\n     ‚Üì\naverages = [90.0, 80.6, ...]\n     ‚Üì\nFiltering\n     ‚Üì\nhonor_roll = [(\"Alice\", 90.0), (\"Charlie\", 95.0)]\n     ‚Üì\nSorting\n     ‚Üì\nranked = [(\"Grace\", 95.2), (\"Charlie\", 95.0), ...]\n     ‚Üì\nSlicing\n     ‚Üì\ntop_3 = [(\"Grace\", 95.2), (\"Charlie\", 95.0), (\"Alice\", 90.0)]\n     ‚Üì\nOutput\n</pre><h3>Key Patterns Used:</h3><table border='1' cellpadding='5' style='border-collapse: collapse;'><tr><th>Pattern</th><th>Code</th><th>Purpose</th></tr><tr><td>Tuple unpacking</td><td>for id, name, grades in students</td><td>Extract data from tuples</td></tr><tr><td>Calculate average</td><td>sum(grades)/len(grades)</td><td>Single student average</td></tr><tr><td>Map transformation</td><td>[expr for item in list]</td><td>Transform all items</td></tr><tr><td>Filter</td><td>[x for x in list if cond]</td><td>Keep matching items</td></tr><tr><td>Flatten</td><td>[item for sublist in list for item in sublist]</td><td>Nested list ‚Üí flat list</td></tr><tr><td>Sort by attribute</td><td>list.sort(key=lambda x: x[1])</td><td>Sort by specific field</td></tr><tr><td>Top N</td><td>sorted_list[:N]</td><td>First N items</td></tr><tr><td>Bottom N</td><td>sorted_list[-N:]</td><td>Last N items</td></tr></table><h3>Alternative Implementations:</h3><h4>Without List Comprehensions:</h4><pre><code># Honor roll (comprehension version)\nhonor_roll = [(name, sum(grades)/len(grades)) for (id, name, grades) in students if sum(grades)/len(grades) >= 90]\n\n# Honor roll (loop version)\nhonor_roll = []\nfor (id, name, grades) in students:\n    avg = sum(grades) / len(grades)\n    if avg >= 90:\n        honor_roll.append((name, avg))\n\n# List comprehension is more concise!\n</code></pre><h4>Using Named Tuples (Advanced):</h4><pre><code>from collections import namedtuple\n\n# Define structure\nStudent = namedtuple('Student', ['id', 'name', 'grades'])\n\n# Create students\nstudents = [\n    Student(101, \"Alice\", [85, 92, 88, 95, 90]),\n    Student(102, \"Bob\", [78, 82, 75, 88, 80])\n]\n\n# Access by name instead of index\nfor student in students:\n    print(student.name)  # More readable than student[1]\n    avg = sum(student.grades) / len(student.grades)\n</code></pre>",

  "exercise": {
    "instructions": "<p>Build a <strong>Movie Rating Analyzer</strong> that processes movie data and generates insights.</p><p><strong>Requirements:</strong></p><ol><li><strong>Data Structure</strong>: Each movie is a tuple: (id, title, year, [ratings])<ul><li>ratings is a list of user ratings (1-10)</li></ul></li><li><strong>Create sample data</strong> for at least 6 movies</li><li><strong>Calculate statistics</strong>:<ul><li>Average rating per movie</li><li>Overall average across all movies</li><li>Highest and lowest rated movies</li></ul></li><li><strong>Filter movies</strong>:<ul><li>Highly rated (avg >= 8.0)</li><li>Poorly rated (avg < 6.0)</li><li>Recent movies (year >= 2020)</li></ul></li><li><strong>Analyze ratings</strong>:<ul><li>Movies with most ratings (participation)</li><li>Movies with most consistent ratings (low variance)</li><li>Distribution by decade</li></ul></li><li><strong>Generate reports</strong>:<ul><li>Top 5 movies</li><li>Recommendations (highly rated recent movies)</li><li>Rating distribution chart</li></ul></li></ol><p><strong>Example Output:</strong></p><pre>=== Movie Rating Analyzer ===\n\nLoaded 6 movies\n\nTop Rated Movies:\n1. The Shawshank Redemption (1994) - 9.3 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê\n2. The Dark Knight (2008) - 9.0 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê\n3. Inception (2010) - 8.8 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê\n\nRecommendations (Recent + Highly Rated):\n- Dune (2021) - 8.5\n- Everything Everywhere (2022) - 8.9\n\nRating Distribution:\n9-10: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 3 movies\n7-8:  ‚ñà‚ñà‚ñà‚ñà 2 movies\n5-6:  ‚ñà‚ñà 1 movie\n</pre>",
    "starter_code": "# Movie Rating Analyzer - Starter Code\n\nprint(\"=== Movie Rating Analyzer ===\")\nprint()\n\n# YOUR CODE: Create movie data\n# Each movie: (id, title, year, [ratings])\nmovies = [\n    (1, \"The Shawshank Redemption\", 1994, [10, 9, 10, 9, 9, 10, 9]),\n    (2, \"The Dark Knight\", 2008, [9, 9, 8, 10, 9, 8, 9]),\n    # Add 4 more movies\n]\n\nprint(f\"Loaded {len(movies)} movies\")\nprint()\n\n# YOUR CODE: Display all movies with averages\nprint(\"All Movies:\")\nfor movie_id, title, year, ratings in movies:\n    avg =   # Calculate average\n    print(f\"{title} ({year}) - Avg: {avg:.1f}\")\n\nprint()\n\n# YOUR CODE: Calculate overall statistics\naverages = [  # List comprehension for all averages\noverall_avg = sum(averages) / len(averages)\n\nprint(f\"Overall average rating: {overall_avg:.2f}\")\nprint()\n\n# YOUR CODE: Find highest rated\n# Create list of (title, average) and sort\nrated = [  # (title, avg) for each movie\nrated.sort(key=lambda x: x[1], reverse=True)\n\nprint(\"Top 3 Movies:\")\nfor rank, (title, avg) in enumerate(rated[:3], start=1):\n    stars = \"‚≠ê\" * int(avg)  # Round to nearest int\n    print(f\"{rank}. {title} - {avg:.1f} {stars}\")\n\nprint()\n\n# YOUR CODE: Filter highly rated (>=8)\nhighly_rated = [  # Filter movies with avg >= 8\nprint(f\"Highly Rated Movies (>=8.0): {len(highly_rated)}\")\n\n# YOUR CODE: Filter recent (year >= 2020)\nrecent = [  # Filter movies from 2020 or later\nprint(f\"Recent Movies (2020+): {len(recent)}\")\n\nprint()\n\n# YOUR CODE: Recommendations (recent AND highly rated)\nrecommendations = [  # Movies that are both recent and highly rated\nif recommendations:\n    print(\"Recommendations (Recent + Highly Rated):\")\n    for title, year, avg in recommendations:\n        print(f\"  - {title} ({year}) - {avg:.1f}\")\nelse:\n    print(\"No recent highly-rated movies found.\")\n\nprint()\n\n# YOUR CODE: Rating distribution\nprint(\"Rating Distribution:\")\nhigh_rated = len([  # 8-10\nmed_rated = len([   # 6-8\nlow_rated = len([   # <6\n\nprint(f\"8-10: {'‚ñà' * high_rated} {high_rated} movies\")\nprint(f\"6-8:  {'‚ñà' * med_rated} {med_rated} movies\")\nprint(f\"<6:   {'‚ñà' * low_rated} {low_rated} movies\")",
    "hint": "For average: sum(ratings)/len(ratings). For comprehension: [(title, sum(ratings)/len(ratings)) for (id, title, year, ratings) in movies]. For filtering: [... for ... in movies if condition]. For AND conditions: if cond1 and cond2. For sorting: list.sort(key=lambda x: x[1], reverse=True). For slicing top N: list[:N]."
  },

  "solution": {
    "code": "# Movie Rating Analyzer - COMPLETE SOLUTION\n\nprint(\"=== Movie Rating Analyzer ===\")\nprint()\n\n# Create movie data\n# Each movie: (id, title, year, [ratings])\nmovies = [\n    (1, \"The Shawshank Redemption\", 1994, [10, 9, 10, 9, 9, 10, 9]),\n    (2, \"The Dark Knight\", 2008, [9, 9, 8, 10, 9, 8, 9]),\n    (3, \"Inception\", 2010, [9, 8, 9, 8, 9, 8, 9]),\n    (4, \"Dune\", 2021, [8, 9, 8, 8, 9, 9, 8]),\n    (5, \"Everything Everywhere\", 2022, [9, 9, 9, 8, 9, 9, 9]),\n    (6, \"The Room\", 2003, [3, 4, 2, 5, 3, 4, 3])\n]\n\nprint(f\"Loaded {len(movies)} movies\")\nprint()\n\n# Display all movies with averages\nprint(\"All Movies:\")\nfor movie_id, title, year, ratings in movies:\n    avg = sum(ratings) / len(ratings)\n    print(f\"{title} ({year}) - Avg: {avg:.1f}\")\n\nprint()\n\n# Calculate overall statistics\naverages = [sum(ratings)/len(ratings) for (id, title, year, ratings) in movies]\noverall_avg = sum(averages) / len(averages)\n\nprint(f\"Overall average rating: {overall_avg:.2f}\")\nprint()\n\n# Find highest rated\nrated = [(title, sum(ratings)/len(ratings)) for (id, title, year, ratings) in movies]\nrated.sort(key=lambda x: x[1], reverse=True)\n\nprint(\"Top 3 Movies:\")\nfor rank, (title, avg) in enumerate(rated[:3], start=1):\n    stars = \"‚≠ê\" * int(avg)\n    print(f\"{rank}. {title} - {avg:.1f} {stars}\")\n\nprint()\n\n# Filter highly rated (>=8)\nhighly_rated = [(title, sum(ratings)/len(ratings)) for (id, title, year, ratings) in movies if sum(ratings)/len(ratings) >= 8.0]\nprint(f\"Highly Rated Movies (>=8.0): {len(highly_rated)}\")\n\n# Filter recent (year >= 2020)\nrecent = [(title, year) for (id, title, year, ratings) in movies if year >= 2020]\nprint(f\"Recent Movies (2020+): {len(recent)}\")\n\nprint()\n\n# Recommendations (recent AND highly rated)\nrecommendations = [\n    (title, year, sum(ratings)/len(ratings))\n    for (id, title, year, ratings) in movies\n    if year >= 2020 and sum(ratings)/len(ratings) >= 8.0\n]\n\nif recommendations:\n    print(\"Recommendations (Recent + Highly Rated):\")\n    for title, year, avg in recommendations:\n        print(f\"  - {title} ({year}) - {avg:.1f}\")\nelse:\n    print(\"No recent highly-rated movies found.\")\n\nprint()\n\n# Rating distribution\nprint(\"Rating Distribution:\")\nhigh_rated = len([avg for avg in averages if avg >= 8])\nmed_rated = len([avg for avg in averages if 6 <= avg < 8])\nlow_rated = len([avg for avg in averages if avg < 6])\n\nprint(f\"8-10: {'‚ñà' * high_rated} {high_rated} movies\")\nprint(f\"6-8:  {'‚ñà' * med_rated} {med_rated} movies\")\nprint(f\"<6:   {'‚ñà' * low_rated} {low_rated} movies\")",
    "explanation": "<h3>Complete Analysis Breakdown:</h3><h4>1. Data Structure</h4><pre><code># Each movie tuple:\n(id, title, year, [ratings])\n(1, \"The Shawshank Redemption\", 1994, [10, 9, 10, 9, 9, 10, 9])\n\n# Why this structure?\n# - id, title, year are immutable (tuple)\n# - ratings is mutable list (can add more ratings)\n</code></pre><h4>2. Calculate Averages (List Comprehension)</h4><pre><code>averages = [sum(ratings)/len(ratings) for (id, title, year, ratings) in movies]\n\n# For each movie:\n# - Unpack tuple\n# - Calculate sum(ratings)/len(ratings)\n# - Add to list\n\n# Result: [9.43, 8.86, 8.57, 8.43, 8.86, 3.43]\n</code></pre><h4>3. Sorting by Rating</h4><pre><code># Create (title, average) pairs\nrated = [(title, sum(ratings)/len(ratings)) for (id, title, year, ratings) in movies]\n\n# Sort by average (second element)\nrated.sort(key=lambda x: x[1], reverse=True)\n#                       ‚Üì\n#                   x[1] = average\n#                   reverse=True = highest first\n\n# Result sorted high to low:\n# [(\"Shawshank\", 9.43), (\"Dark Knight\", 8.86), ...]\n</code></pre><h4>4. Filtering with Multiple Conditions</h4><pre><code># Recent AND highly rated\nrecommendations = [\n    (title, year, sum(ratings)/len(ratings))\n    for (id, title, year, ratings) in movies\n    if year >= 2020 and sum(ratings)/len(ratings) >= 8.0\n]\n\n# Two conditions:\n# 1. year >= 2020 (recent)\n# 2. avg >= 8.0 (highly rated)\n# Both must be True (AND)\n</code></pre><h4>5. Slicing for Top N</h4><pre><code># Top 3 from sorted list\nfor rank, (title, avg) in enumerate(rated[:3], start=1):\n#                                        ‚Üì\n#                                  First 3 items\n\n# enumerate(rated[:3], start=1) creates:\n# (1, (\"Shawshank\", 9.43))\n# (2, (\"Dark Knight\", 8.86))\n# (3, (\"Inception\", 8.57))\n</code></pre><h3>Module 5 Concepts Demonstrated:</h3><table border='1' cellpadding='5' style='border-collapse: collapse;'><tr><th>Concept</th><th>Usage in Project</th></tr><tr><td>Tuples</td><td>Movie records (immutable id, title, year)</td></tr><tr><td>Lists</td><td>Ratings collection (mutable)</td></tr><tr><td>Unpacking</td><td>for id, title, year, ratings in movies</td></tr><tr><td>Comprehensions</td><td>Calculate averages, filter movies</td></tr><tr><td>Slicing</td><td>Top 3 movies rated[:3]</td></tr><tr><td>Sorting</td><td>Order by rating with key function</td></tr><tr><td>Filtering</td><td>Recent, highly rated, multiple conditions</td></tr><tr><td>Methods</td><td>sum(), len(), sort()</td></tr></table><h3>Key Takeaways:</h3><ol><li><strong>Tuple + List combination</strong>: Fixed data (tuple) + variable data (list)</li><li><strong>List comprehension efficiency</strong>: Calculate all averages in one line</li><li><strong>Lambda for sorting</strong>: Sort by specific tuple element</li><li><strong>Multiple filters</strong>: Combine conditions with 'and'</li><li><strong>Enumerate with custom start</strong>: 1-based ranking</li></ol>"
  },

  "key_takeaways": "<ul><li><strong>Module 5 mastery</strong>: Combined lists, tuples, slicing, methods, comprehensions</li><li><strong>Tuples for fixed data</strong>: ID, name unchangeable; nested list mutable</li><li><strong>List comprehensions</strong>: Concise data transformations and filtering</li><li><strong>Tuple unpacking</strong>: Extract data directly in loops</li><li><strong>Sorting with lambda</strong>: Sort by specific fields</li><li><strong>Slicing patterns</strong>: Top N, bottom N, ranges</li><li><strong>Nested comprehensions</strong>: Flatten multi-level data</li><li><strong>Real-world data structures</strong>: Practical combinations of concepts</li></ul><h3>Essential Patterns from This Project:</h3><pre><code># 1. Tuple record with mutable component\nrecord = (id, name, [mutable_data])\n\n# 2. Calculate statistics with comprehension\naverages = [sum(values)/len(values) for (_, _, values) in records]\n\n# 3. Filter and transform\nfiltered = [(name, calc(data)) for (id, name, data) in records if condition]\n\n# 4. Sort by calculated value\nresults.sort(key=lambda x: x[1], reverse=True)\n\n# 5. Top/bottom using slicing\ntop_n = sorted_list[:n]\nbottom_n = sorted_list[-n:]\n\n# 6. Multiple filter conditions\nresult = [item for item in items if cond1 and cond2]\n\n# 7. Flatten nested structure\nflat = [item for sublist in nested for item in sublist]\n</code></pre><h3>Module 5 Complete! üéâ</h3><p>You've mastered:</p><ul><li>‚úÖ Lists (creation, indexing, methods)</li><li>‚úÖ List slicing ([start:stop:step])</li><li>‚úÖ Tuples (immutable sequences)</li><li>‚úÖ Tuple unpacking</li><li>‚úÖ List comprehensions</li><li>‚úÖ Real-world data processing</li></ul><h3>What's Next: Module 6 - Functions</h3><p>In Module 6, you'll learn to:</p><ul><li>Define reusable code blocks</li><li>Pass parameters and return values</li><li>Understand scope and lifetime</li><li>Use default arguments</li><li>Create lambda functions</li><li>Build modular, organized programs</li></ul><p>Functions will revolutionize how you structure code!</p>",

  "checkpoint_quiz": [
    {
      "question": "Why use a tuple for the student record instead of a list?\n\nstudent = (101, \"Alice\", [85, 92, 88])",
      "options": [
        "Tuples are faster than lists",
        "Student ID and name shouldn't change (immutable)",
        "Tuples use less memory",
        "Lists can't contain other lists"
      ],
      "correct_answer": 1,
      "explanation": "The correct answer is that student ID and name shouldn't change. Tuples are immutable, which prevents accidental modification of fixed data like ID and name. The grades list is nested inside the tuple, so it can still be modified. This is a common pattern: use tuples for fixed structure with lists for variable data."
    },
    {
      "question": "What does this comprehension do?\n\naverages = [sum(grades)/len(grades) for (id, name, grades) in students]",
      "options": [
        "Calculates the total of all grades",
        "Creates a list of averages for each student",
        "Filters students by average grade",
        "Counts the number of students"
      ],
      "correct_answer": 1,
      "explanation": "This creates a list of averages for each student. For each student tuple, it unpacks to get the grades list, calculates sum(grades)/len(grades) (the average), and adds that to the new list. The result is a list of all student averages in the same order as the students list."
    },
    {
      "question": "What does this code return?\n\nranked = [(\"Alice\", 90), (\"Bob\", 85), (\"Charlie\", 95)]\nranked.sort(key=lambda x: x[1], reverse=True)\ntop_3 = ranked[:3]",
      "options": [
        "[(\"Alice\", 90), (\"Bob\", 85), (\"Charlie\", 95)]",
        "[(\"Charlie\", 95), (\"Alice\", 90), (\"Bob\", 85)]",
        "[(\"Bob\", 85), (\"Alice\", 90), (\"Charlie\", 95)]",
        "Error: can't slice after sort"
      ],
      "correct_answer": 1,
      "explanation": "The result is [(\"Charlie\", 95), (\"Alice\", 90), (\"Bob\", 85)]. The sort() with key=lambda x: x[1] sorts by the second element (the score), and reverse=True puts highest first. Then [:3] takes the first 3 items (which is all of them in this case). This pattern is used to get top performers sorted by score."
    }
  ]
}
