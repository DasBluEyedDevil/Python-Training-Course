{
  "lesson_id": 3,
  "module_id": 6,
  "title": "Variable Scope and Lifetime",
  "duration": "30 minutes",
  "objectives": [
    "Understand the difference between local and global variables",
    "Learn how Python determines which variable to use",
    "Master the concept of variable scope and lifetime",
    "Avoid common scope-related bugs and confusion"
  ],
  "sections": [
    {
      "role": "The Simplifier",
      "title": "The Concept",
      "content": "<h3>ğŸ  Scope: Variables Have Territories</h3><p><strong>Real-World Analogy First:</strong></p><p>Imagine a large office building with many separate offices:</p><ul><li>ğŸ“ Each office has its own <strong>whiteboard</strong> for notes</li><li>ğŸ“ If you write \"meeting at 2pm\" on YOUR office whiteboard, it only exists in YOUR office</li><li>ğŸ“ Other offices can't see your whiteboard</li><li>ğŸ“ But there's also a <strong>lobby bulletin board</strong> that everyone can see</li><li>ğŸ“ When someone mentions \"the whiteboard,\" do they mean yours or the lobby one? <em>It depends where they are!</em></li></ul><p>This is exactly how <strong>variable scope</strong> works in Python:</p><ul><li>ğŸ”µ Variables created <strong>inside a function</strong> are like your private office whiteboard (LOCAL)</li><li>ğŸ”µ Variables created <strong>outside all functions</strong> are like the lobby bulletin board (GLOBAL)</li><li>ğŸ”µ Python determines which variable you mean based on WHERE your code is</li></ul><hr><p><strong>Now The Technical Terms:</strong></p><p><strong>Scope:</strong> The region of code where a variable is accessible. Think of it as the variable's \"visibility zone.\"</p><p><strong>Local Variable:</strong> A variable created inside a function. It only exists while that function runs and can only be used inside that function.</p><p><strong>Global Variable:</strong> A variable created outside all functions. It can be accessed from anywhere in your code.</p><p><strong>Lifetime:</strong> How long a variable exists in memory. Local variables are born when a function is called and die when it returns.</p><p><strong>Why This Matters:</strong></p><ul><li>âœ… <strong>Isolation:</strong> Functions don't accidentally mess up each other's variables</li><li>âœ… <strong>Reusability:</strong> You can use the same variable name in different functions</li><li>âœ… <strong>Memory:</strong> Local variables are cleaned up automatically</li><li>âœ… <strong>Debugging:</strong> Understanding scope helps you find where variables come from</li></ul>"
    },
    {
      "role": "The Coder",
      "title": "Code Example",
      "content": "<h3>ğŸ’» Local vs Global Scope</h3><p>Let's see how variables in different scopes behave:</p>",
      "code": "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 1: Local Variables Are Isolated\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ndef function_a():\n    \"\"\"Function A has its own local variable.\"\"\"\n    message = \"Hello from Function A\"\n    print(f\"Inside A: {message}\")\n\ndef function_b():\n    \"\"\"Function B has a DIFFERENT local variable with the same name.\"\"\"\n    message = \"Hello from Function B\"\n    print(f\"Inside B: {message}\")\n\nprint(\"Example 1: Each function has its own 'message' variable:\")\nfunction_a()\nfunction_b()\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 2: Local Variables Die After Function Ends\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ndef calculate_total():\n    \"\"\"Local variables exist only while function runs.\"\"\"\n    price = 10\n    quantity = 3\n    total = price * quantity\n    print(f\"Inside function: total = {total}\")\n    return total\n\nprint(\"Example 2: Local variable lifetime:\")\nresult = calculate_total()\nprint(f\"After function: result = {result}\")\n# print(price)  # âŒ This would cause NameError: 'price' not defined\nprint(\"(The variables 'price' and 'quantity' no longer exist!)\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 3: Global Variables Are Accessible Everywhere\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\napp_name = \"Super Calculator\"  # Global variable\nversion = \"1.0\"  # Global variable\n\ndef display_about():\n    \"\"\"Can READ global variables from inside function.\"\"\"\n    print(f\"App: {app_name}\")\n    print(f\"Version: {version}\")\n\ndef display_welcome():\n    \"\"\"Another function can also READ the same globals.\"\"\"\n    print(f\"Welcome to {app_name}!\")\n\nprint(\"Example 3: Global variables are accessible everywhere:\")\ndisplay_about()\ndisplay_welcome()\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 4: Local Variable SHADOWS Global\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ncount = 100  # Global variable\n\ndef show_count():\n    \"\"\"Local variable with same name SHADOWS the global.\"\"\"\n    count = 5  # Local variable (different from global!)\n    print(f\"Inside function: count = {count}\")\n\nprint(\"Example 4: Local shadows global:\")\nprint(f\"Before function call: count = {count}\")\nshow_count()\nprint(f\"After function call: count = {count}\")\nprint(\"(The global 'count' was never changed!)\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 5: Parameters Are Local Variables\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ndef greet(name):\n    \"\"\"Parameter 'name' is a local variable.\"\"\"\n    name = name.upper()  # Modifying the LOCAL copy\n    print(f\"Inside function: {name}\")\n\nprint(\"Example 5: Parameters are local:\")\nuser = \"Alice\"\ngreet(user)\nprint(f\"After function: user = {user}\")  # Original unchanged\nprint(\"(The parameter was a local copy!)\")",
      "output": "Example 1: Each function has its own 'message' variable:\nInside A: Hello from Function A\nInside B: Hello from Function B\n\nExample 2: Local variable lifetime:\nInside function: total = 30\nAfter function: result = 30\n(The variables 'price' and 'quantity' no longer exist!)\n\nExample 3: Global variables are accessible everywhere:\nApp: Super Calculator\nVersion: 1.0\nWelcome to Super Calculator!\n\nExample 4: Local shadows global:\nBefore function call: count = 100\nInside function: count = 5\nAfter function call: count = 100\n(The global 'count' was never changed!)\n\nExample 5: Parameters are local:\nInside function: ALICE\nAfter function: user = Alice\n(The parameter was a local copy!)"
    },
    {
      "role": "The Simplifier",
      "title": "Syntax Breakdown",
      "content": "<h3>ğŸ” Understanding Scope Rules</h3><p><strong>Rule 1: Where You Create = What Scope</strong></p><pre><code># Global scope (outside all functions)\nglob_var = 10\n\ndef my_function():\n    # Local scope (inside a function)\n    local_var = 20\n    print(glob_var)   # âœ… Can READ global\n    print(local_var)  # âœ… Can READ local\n\n# Outside function:\nprint(glob_var)   # âœ… Can READ global\nprint(local_var)  # âŒ NameError! Can't see local</code></pre><ul><li>ğŸ“Œ Variables created <strong>inside</strong> a function = <strong>local</strong></li><li>ğŸ“Œ Variables created <strong>outside</strong> all functions = <strong>global</strong></li><li>ğŸ“Œ Parameters count as local variables</li></ul><hr><p><strong>Rule 2: Python's Variable Lookup Order (LEGB)</strong></p><p>When Python sees a variable name, it searches in this order:</p><ol><li><strong>L</strong>ocal: Inside the current function</li><li><strong>E</strong>nclosing: In any outer functions (advanced topic)</li><li><strong>G</strong>lobal: At the module level (top of file)</li><li><strong>B</strong>uilt-in: Python's built-in names (print, len, etc.)</li></ol><p>It uses the <strong>first match</strong> it finds and stops searching.</p><pre><code>x = \"global\"  # Global scope\n\ndef outer():\n    x = \"enclosing\"  # Enclosing scope\n    \n    def inner():\n        x = \"local\"  # Local scope\n        print(x)  # Prints \"local\" (found in step 1)\n    \n    inner()\n\nouter()</code></pre><hr><p><strong>Rule 3: Reading vs Writing</strong></p><pre><code>count = 0  # Global\n\ndef read_global():\n    print(count)  # âœ… Can READ global, no problem\n\ndef write_local():\n    count = 5  # âœ… Creates NEW LOCAL variable\n    print(count)  # Prints 5 (local)\n\nread_global()   # Prints 0\nwrite_local()   # Prints 5\nprint(count)    # Prints 0 (global unchanged)</code></pre><ul><li>ğŸ“Œ <strong>Reading</strong> a global: No special syntax needed</li><li>ğŸ“Œ <strong>Assigning</strong> to a variable: Creates new local (doesn't modify global)</li></ul><hr><p><strong>Rule 4: The global Keyword (Use Sparingly!)</strong></p><pre><code>counter = 0  # Global\n\ndef increment():\n    global counter  # Tell Python: use the GLOBAL counter\n    counter += 1    # Modify the global variable\n\nincrement()\nprint(counter)  # Prints 1 (global was modified)</code></pre><ul><li>ğŸ“Œ <code>global variable_name</code> tells Python to use the global version</li><li>ğŸ“Œ Now assignments inside the function affect the global</li><li>âš ï¸ <strong>Generally discouraged!</strong> Use parameters and return values instead</li></ul><hr><p><strong>Rule 5: Parameters and Local Variables</strong></p><pre><code>def process(value):  # 'value' is a parameter (local variable)\n    result = value * 2  # 'result' is a local variable\n    return result\n\nnum = 10\nanswer = process(num)\nprint(answer)  # 20\nprint(num)     # 10 (original unchanged)</code></pre><ul><li>ğŸ“Œ Parameters are automatically local variables</li><li>ğŸ“Œ Changes to parameters don't affect the original variable</li><li>ğŸ“Œ The function gets a <strong>copy</strong> of the value</li></ul><hr><p><strong>Visual Model:</strong></p><pre><code>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘      GLOBAL SCOPE             â•‘\nâ•‘  app_name = \"Calculator\"      â•‘\nâ•‘  version = 1.0                â•‘\nâ•‘                               â•‘\nâ•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â•‘\nâ•‘  â”‚  FUNCTION: calculate    â”‚  â•‘\nâ•‘  â”‚  LOCAL SCOPE            â”‚  â•‘\nâ•‘  â”‚  price = 10             â”‚  â•‘\nâ•‘  â”‚  total = 30             â”‚  â•‘\nâ•‘  â”‚  (dies when fn ends)    â”‚  â•‘\nâ•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â•‘\nâ•‘                               â•‘\nâ•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â•‘\nâ•‘  â”‚  FUNCTION: display      â”‚  â•‘\nâ•‘  â”‚  LOCAL SCOPE            â”‚  â•‘\nâ•‘  â”‚  message = \"Hi\"         â”‚  â•‘\nâ•‘  â”‚  (separate from above)  â”‚  â•‘\nâ•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</code></pre>"
    },
    {
      "role": "The Coder",
      "title": "Exercise",
      "content": "<h3>âœï¸ Your Turn: Bank Account Balance</h3><p><strong>Challenge:</strong> Create a simple bank account system that demonstrates variable scope. You'll have a global balance and functions that work with it CORRECTLY (using parameters and return values, NOT the global keyword).</p><p><strong>Requirements:</strong></p><ol><li>Create a global variable <code>account_balance</code> set to 1000</li><li>Create a function <code>deposit(balance, amount)</code> that:<ul><li>Takes current balance and deposit amount as parameters</li><li>Returns the new balance (old balance + amount)</li><li>Prints a message showing the deposit</li></ul></li><li>Create a function <code>withdraw(balance, amount)</code> that:<ul><li>Takes current balance and withdrawal amount as parameters</li><li>Returns the new balance (old balance - amount) if sufficient funds</li><li>Returns the unchanged balance if insufficient funds</li><li>Prints appropriate messages</li></ul></li><li>Create a function <code>check_balance(balance)</code> that prints the current balance</li><li>Test your functions by:<ul><li>Depositing $500</li><li>Withdrawing $200</li><li>Trying to withdraw $2000 (should fail)</li><li>Checking final balance</li></ul></li></ol><p><strong>Important:</strong> DO NOT use the <code>global</code> keyword! Instead, use return values and reassignment.</p>",
      "starter_code": "# Global variable for account balance\naccount_balance = 1000\n\n# Define your deposit function\ndef deposit(balance, amount):\n    # Your code here\n    pass\n\n# Define your withdraw function\ndef withdraw(balance, amount):\n    # Your code here\n    pass\n\n# Define your check_balance function\ndef check_balance(balance):\n    # Your code here\n    pass\n\n# Test your functions\nprint(\"ğŸ¦ BANK ACCOUNT SYSTEM\")\nprint(\"â•\" * 40)\n# Your test code here\n"
    },
    {
      "role": "The Coder",
      "title": "Solution",
      "content": "<h3>âœ… Solution: Bank Account Balance</h3>",
      "code": "# Global variable for account balance\naccount_balance = 1000\n\ndef deposit(balance, amount):\n    \"\"\"Add money to the account and return new balance.\n    \n    Args:\n        balance: Current account balance\n        amount: Amount to deposit\n    \n    Returns:\n        New balance after deposit\n    \"\"\"\n    new_balance = balance + amount\n    print(f\"ğŸ’° Deposited ${amount:.2f}\")\n    return new_balance\n\ndef withdraw(balance, amount):\n    \"\"\"Withdraw money from account if sufficient funds.\n    \n    Args:\n        balance: Current account balance\n        amount: Amount to withdraw\n    \n    Returns:\n        New balance after withdrawal, or unchanged if insufficient funds\n    \"\"\"\n    if amount > balance:\n        print(f\"âŒ Insufficient funds! Cannot withdraw ${amount:.2f}\")\n        print(f\"   (You only have ${balance:.2f})\")\n        return balance  # No change\n    else:\n        new_balance = balance - amount\n        print(f\"ğŸ’¸ Withdrew ${amount:.2f}\")\n        return new_balance\n\ndef check_balance(balance):\n    \"\"\"Display the current account balance.\n    \n    Args:\n        balance: Current account balance\n    \"\"\"\n    print(f\"ğŸ’µ Current Balance: ${balance:.2f}\")\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# TESTING THE BANK ACCOUNT SYSTEM\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nprint(\"ğŸ¦ BANK ACCOUNT SYSTEM\")\nprint(\"â•\" * 40)\nprint()\n\n# Initial balance\nprint(\"Starting balance:\")\ncheck_balance(account_balance)\nprint()\n\n# Deposit $500\nprint(\"Transaction 1: Deposit $500\")\naccount_balance = deposit(account_balance, 500)\ncheck_balance(account_balance)\nprint()\n\n# Withdraw $200\nprint(\"Transaction 2: Withdraw $200\")\naccount_balance = withdraw(account_balance, 200)\ncheck_balance(account_balance)\nprint()\n\n# Try to withdraw $2000 (should fail)\nprint(\"Transaction 3: Try to withdraw $2000\")\naccount_balance = withdraw(account_balance, 2000)\ncheck_balance(account_balance)\nprint()\n\n# Small withdrawal\nprint(\"Transaction 4: Withdraw $100\")\naccount_balance = withdraw(account_balance, 100)\ncheck_balance(account_balance)\nprint()\n\nprint(\"â•\" * 40)\nprint(f\"âœ… Final Balance: ${account_balance:.2f}\")",
      "output": "ğŸ¦ BANK ACCOUNT SYSTEM\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nStarting balance:\nğŸ’µ Current Balance: $1000.00\n\nTransaction 1: Deposit $500\nğŸ’° Deposited $500.00\nğŸ’µ Current Balance: $1500.00\n\nTransaction 2: Withdraw $200\nğŸ’¸ Withdrew $200.00\nğŸ’µ Current Balance: $1300.00\n\nTransaction 3: Try to withdraw $2000\nâŒ Insufficient funds! Cannot withdraw $2000.00\n   (You only have $1300.00)\nğŸ’µ Current Balance: $1300.00\n\nTransaction 4: Withdraw $100\nğŸ’¸ Withdrew $100.00\nğŸ’µ Current Balance: $1200.00\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâœ… Final Balance: $1200.00",
      "explanation": "<h3>ğŸ“š How It Works:</h3><ol><li><strong>Global Variable (Line 2):</strong><ul><li><code>account_balance = 1000</code> is defined outside all functions (global scope)</li><li>It can be READ by all functions</li><li>But we don't MODIFY it directly from inside functions</li></ul></li><li><strong>deposit() Function (Lines 4-17):</strong><ul><li>Takes <code>balance</code> as a parameter (local copy)</li><li>Calculates <code>new_balance = balance + amount</code> (local variable)</li><li><code>return new_balance</code> sends the result back</li><li>Doesn't modify any global variables!</li></ul></li><li><strong>withdraw() Function (Lines 19-39):</strong><ul><li>Checks if sufficient funds before withdrawing</li><li>Returns unchanged balance if insufficient</li><li>Returns new balance if successful</li><li>All calculations use local variables</li></ul></li><li><strong>check_balance() Function (Lines 41-48):</strong><ul><li>Simple display function</li><li>Takes balance as parameter and prints it</li><li>Doesn't return anything (returns None implicitly)</li></ul></li><li><strong>The Key Pattern (Lines 60-80):</strong><pre><code>account_balance = deposit(account_balance, 500)</code></pre><ul><li>We pass the current balance TO the function</li><li>Function calculates and returns new balance</li><li>We reassign the global: <code>account_balance = ...</code></li><li>This is the CORRECT way to update globals (not using <code>global</code> keyword)</li></ul></li></ol><h3>âš ï¸ Common Mistakes:</h3><ol><li><strong>Using global Keyword (Not Recommended):</strong><pre><code># âŒ POOR PRACTICE - using global keyword\ndef deposit_bad(amount):\n    global account_balance\n    account_balance += amount\n\n# âœ… GOOD PRACTICE - parameters and return\ndef deposit_good(balance, amount):\n    return balance + amount\n\naccount_balance = deposit_good(account_balance, 100)</code></pre></li><li><strong>Forgetting to Reassign:</strong><pre><code># âŒ WRONG - return value is ignored\ndeposit(account_balance, 500)\n# account_balance hasn't changed!\n\n# âœ… CORRECT - capture and reassign\naccount_balance = deposit(account_balance, 500)</code></pre></li><li><strong>Modifying Parameter Directly:</strong><pre><code># âŒ CONFUSING - modifying parameter\ndef deposit(balance, amount):\n    balance = balance + amount  # Changes local copy only\n    # Forgot to return!\n\n# âœ… CLEAR - calculate and return\ndef deposit(balance, amount):\n    new_balance = balance + amount\n    return new_balance</code></pre></li><li><strong>Trying to Access Local Variables Outside:</strong><pre><code>def calculate():\n    result = 100  # Local variable\n    return result\n\nvalue = calculate()\nprint(result)  # âŒ NameError! result doesn't exist here</code></pre></li></ol><h3>ğŸ’¡ Pro Tips:</h3><ul><li>âœ… <strong>Prefer parameters and return values over global keyword</strong></li><li>âœ… <strong>Functions should be \"pure\":</strong> Same inputs = same outputs, no hidden state</li><li>âœ… <strong>Local variables are safer:</strong> They can't accidentally be changed by other code</li><li>âœ… <strong>Use descriptive names:</strong> <code>new_balance</code> is clearer than reusing <code>balance</code></li><li>âœ… <strong>Test edge cases:</strong> Like trying to withdraw more than available</li></ul><h3>ğŸ¯ Why This Approach Is Better:</h3><ol><li><strong>Testable:</strong> Easy to test - give inputs, check outputs</li><li><strong>Predictable:</strong> Functions don't have hidden side effects</li><li><strong>Reusable:</strong> Same function could work with multiple accounts</li><li><strong>Clear data flow:</strong> You can see where values come from and go to</li></ol>"
    },
    {
      "role": "Summary",
      "title": "Key Takeaways",
      "content": "<h3>ğŸ¯ Essential Points to Remember:</h3><ol><li><strong>Scope determines visibility:</strong><ul><li><strong>Local scope:</strong> Inside a function, variables only exist there</li><li><strong>Global scope:</strong> Outside functions, accessible everywhere</li><li>Think: Local = private office, Global = public bulletin board</li></ul></li><li><strong>Variable lookup order (LEGB):</strong><ul><li><strong>L</strong>ocal â†’ <strong>E</strong>nclosing â†’ <strong>G</strong>lobal â†’ <strong>B</strong>uilt-in</li><li>Python uses the first match it finds</li></ul></li><li><strong>Creating variables:</strong><pre><code># Global (created outside functions)\nx = 10\n\ndef my_function():\n    # Local (created inside function)\n    y = 20</code></pre></li><li><strong>Reading vs Writing:</strong><ul><li>Can <strong>read</strong> global variables from inside functions (no special syntax)</li><li><strong>Assigning</strong> to a variable inside a function creates a new local variable</li><li>Local variable with same name <strong>shadows</strong> the global</li></ul></li><li><strong>Parameters are local variables:</strong><pre><code>def process(value):  # 'value' is local\n    result = value * 2  # 'result' is local\n    return result</code></pre><ul><li>Changes to parameters don't affect original variables</li><li>Function works with a copy of the value</li></ul></li><li><strong>Local variable lifetime:</strong><ul><li><strong>Born:</strong> When function is called</li><li><strong>Live:</strong> While function executes</li><li><strong>Die:</strong> When function returns</li><li>Memory is automatically freed</li></ul></li><li><strong>Best practice for modifying \"globals\":</strong><pre><code># âœ… GOOD: Use parameters and return values\ndef increment(value):\n    return value + 1\n\ncounter = 5\ncounter = increment(counter)  # Reassign with return value</code></pre><pre><code># âŒ AVOID: Using global keyword\ndef increment():\n    global counter\n    counter += 1</code></pre></li><li><strong>Why avoid global keyword:</strong><ul><li>Makes code harder to test</li><li>Creates hidden dependencies</li><li>Reduces reusability</li><li>Can cause bugs in larger programs</li></ul></li><li><strong>Common scope errors:</strong><ul><li><code>NameError</code>: Variable doesn't exist in current scope</li><li><code>UnboundLocalError</code>: Referenced before assignment in local scope</li></ul></li></ol><h3>ğŸš€ Coming Up Next:</h3><p>In the next lesson, you'll learn about <strong>default and keyword arguments</strong> - how to make functions more flexible by providing default values for parameters and calling functions with named arguments in any order!</p>"
    }
  ],
  "checkpoint_quiz": [
    {
      "question": "What is the scope of a variable created inside a function?",
      "options": [
        "Global - accessible everywhere",
        "Local - only accessible inside that function",
        "Universal - accessible in all programs",
        "Protected - accessible only with special keyword"
      ],
      "correct_answer": 1,
      "explanation": "Variables created inside a function have LOCAL scope - they only exist inside that function and disappear when the function ends. They cannot be accessed from outside the function. This isolation prevents functions from interfering with each other's variables."
    },
    {
      "question": "What happens when you assign to a variable inside a function that has the same name as a global variable?",
      "options": [
        "You modify the global variable",
        "You get a syntax error",
        "You create a new local variable that shadows the global",
        "You must use the 'local' keyword"
      ],
      "correct_answer": 2,
      "explanation": "You create a new LOCAL variable that SHADOWS (hides) the global one. Inside the function, the local version is used. The global variable remains unchanged. This is Python's default behavior to prevent accidentally modifying globals."
    },
    {
      "question": "When does a local variable's lifetime end?",
      "options": [
        "When the program ends",
        "When the function returns",
        "After 60 seconds",
        "When you use the 'del' keyword"
      ],
      "correct_answer": 1,
      "explanation": "Local variables die (are removed from memory) when the function RETURNS. They are created when the function is called and destroyed when it ends. This automatic cleanup is one of the benefits of local scope - you don't have to manage memory manually."
    }
  ]
}
