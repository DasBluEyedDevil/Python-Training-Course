{
  "lesson_id": 5,
  "module_id": 6,
  "title": "Lambda Functions and Built-in Functions",
  "duration": "30 minutes",
  "objectives": [
    "Understand lambda functions (anonymous functions) and their syntax",
    "Learn when to use lambda vs regular functions",
    "Master built-in functions like map(), filter(), and sorted()",
    "Write more concise and Pythonic code using lambdas"
  ],
  "sections": [
    {
      "role": "The Simplifier",
      "title": "The Concept",
      "content": "<h3>âš¡ Lambda: Functions in a Hurry</h3><p><strong>Real-World Analogy First:</strong></p><p>Imagine you're at a coffee shop:</p><ul><li>â˜• <strong>Regular function = Hired barista:</strong> You hire someone, give them a name tag, train them on procedures, they work every day</li><li>â˜• <strong>Lambda function = You make it yourself real quick:</strong> You just need one quick coffee right now, so you step behind the counter for 30 seconds and make it yourself - no hiring, no name tag needed</li></ul><p>Another analogy: <strong>Regular functions</strong> are like formal meetings with names on the calendar. <strong>Lambda functions</strong> are like quick hallway conversations - no official name, just get the job done quickly.</p><p>Lambda functions are for simple, one-off tasks where creating a full function with <code>def</code> would be overkill.</p><hr><p><strong>Now The Technical Terms:</strong></p><p><strong>Lambda Function:</strong> An anonymous (unnamed) function defined in a single expression. It's a shortcut for simple functions.</p><p><strong>Anonymous Function:</strong> A function without a name. You use it immediately where you define it.</p><p><strong>Higher-Order Function:</strong> A function that takes other functions as arguments (like <code>map()</code>, <code>filter()</code>, <code>sorted()</code>). Lambdas are perfect for these!</p><p><strong>Why This Matters:</strong></p><ul><li>âœ… <strong>Conciseness:</strong> Write simple functions in one line</li><li>âœ… <strong>Readability:</strong> For simple operations, lambda can be clearer than <code>def</code></li><li>âœ… <strong>Functional Programming:</strong> Essential for map, filter, sorted, and other functional patterns</li><li>âœ… <strong>No Pollution:</strong> Don't clutter namespace with one-use function names</li></ul><p><strong>âš ï¸ When NOT to Use Lambda:</strong></p><ul><li>âŒ Complex logic (multiple statements)</li><li>âŒ Needs to be reused in many places (use <code>def</code> instead)</li><li>âŒ Requires comments to explain (if it needs explanation, use <code>def</code>)</li></ul>"
    },
    {
      "role": "The Coder",
      "title": "Code Example",
      "content": "<h3>ğŸ’» Lambda Functions and Built-in Functions</h3><p>Let's compare regular functions with lambdas and see them in action with built-in functions:</p>",
      "code": "# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 1: Lambda vs Regular Function\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nprint(\"Example 1: Lambda vs Regular Function\")\nprint()\n\n# Regular function with def\ndef double(x):\n    return x * 2\n\n# Lambda function (anonymous function)\ndouble_lambda = lambda x: x * 2\n\nprint(f\"Regular function: double(5) = {double(5)}\")\nprint(f\"Lambda function:  double_lambda(5) = {double_lambda(5)}\")\nprint(\"Both do the same thing!\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 2: map() - Apply Function to All Items\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nprint(\"Example 2: map() transforms every item in a list\")\nprint()\n\nnumbers = [1, 2, 3, 4, 5]\n\n# Using map with lambda\ndoubled = list(map(lambda x: x * 2, numbers))\nprint(f\"Original: {numbers}\")\nprint(f\"Doubled:  {doubled}\")\nprint()\n\nnames = [\"alice\", \"bob\", \"carol\"]\ncapitalized = list(map(lambda name: name.capitalize(), names))\nprint(f\"Original names: {names}\")\nprint(f\"Capitalized:    {capitalized}\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 3: filter() - Keep Only Items That Match\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nprint(\"Example 3: filter() keeps items that pass a test\")\nprint()\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Keep only even numbers\nevens = list(filter(lambda x: x % 2 == 0, numbers))\nprint(f\"All numbers:  {numbers}\")\nprint(f\"Even numbers: {evens}\")\nprint()\n\n# Keep only numbers greater than 5\ngreater_than_5 = list(filter(lambda x: x > 5, numbers))\nprint(f\"Numbers > 5:  {greater_than_5}\")\nprint()\n\n# Filter strings by length\nwords = [\"hi\", \"hello\", \"hey\", \"greetings\", \"yo\"]\nlong_words = list(filter(lambda word: len(word) > 3, words))\nprint(f\"All words:    {words}\")\nprint(f\"Long words:   {long_words}\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 4: sorted() with key Parameter\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nprint(\"Example 4: sorted() with custom sorting key\")\nprint()\n\nwords = [\"banana\", \"pie\", \"Washington\", \"book\"]\n\n# Normal sort (alphabetical)\nprint(f\"Normal sort:        {sorted(words)}\")\n\n# Sort by length (using lambda)\nprint(f\"Sort by length:     {sorted(words, key=lambda w: len(w))}\")\n\n# Sort by last letter\nprint(f\"Sort by last letter: {sorted(words, key=lambda w: w[-1])}\")\nprint()\n\n# Sort list of tuples by second element\nstudents = [(\"Alice\", 85), (\"Bob\", 92), (\"Carol\", 78), (\"Dave\", 95)]\nprint(f\"Original:           {students}\")\nby_grade = sorted(students, key=lambda student: student[1], reverse=True)\nprint(f\"Sorted by grade:    {by_grade}\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 5: Lambda with Multiple Parameters\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nprint(\"Example 5: Lambda with multiple parameters\")\nprint()\n\n# Lambda can have multiple parameters\nadd = lambda x, y: x + y\nprint(f\"add(3, 5) = {add(3, 5)}\")\n\nmultiply = lambda x, y: x * y\nprint(f\"multiply(4, 7) = {multiply(4, 7)}\")\n\n# Practical use: sorting by calculated value\npoints = [(1, 2), (3, 1), (5, 4), (2, 3)]\n# Sort by distance from origin (sqrt(xÂ² + yÂ²))\ndistance_sorted = sorted(points, key=lambda p: (p[0]**2 + p[1]**2)**0.5)\nprint(f\"\\nPoints sorted by distance from origin:\")\nfor point in distance_sorted:\n    distance = (point[0]**2 + point[1]**2)**0.5\n    print(f\"  {point} - distance: {distance:.2f}\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# EXAMPLE 6: When to Use def Instead\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nprint(\"Example 6: When NOT to use lambda\")\nprint()\n\n# âŒ TOO COMPLEX for lambda\n# This should be a regular function:\ndef calculate_grade(score):\n    \"\"\"Convert numeric score to letter grade.\"\"\"\n    if score >= 90:\n        return 'A'\n    elif score >= 80:\n        return 'B'\n    elif score >= 70:\n        return 'C'\n    elif score >= 60:\n        return 'D'\n    else:\n        return 'F'\n\nscores = [95, 87, 73, 62, 58]\ngrades = list(map(calculate_grade, scores))  # Using regular function\nprint(f\"Scores: {scores}\")\nprint(f\"Grades: {grades}\")\nprint(\"\\n(This logic is too complex for lambda - used def instead!)\")",
      "output": "Example 1: Lambda vs Regular Function\n\nRegular function: double(5) = 10\nLambda function:  double_lambda(5) = 10\nBoth do the same thing!\n\nExample 2: map() transforms every item in a list\n\nOriginal: [1, 2, 3, 4, 5]\nDoubled:  [2, 4, 6, 8, 10]\n\nOriginal names: ['alice', 'bob', 'carol']\nCapitalized:    ['Alice', 'Bob', 'Carol']\n\nExample 3: filter() keeps items that pass a test\n\nAll numbers:  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nEven numbers: [2, 4, 6, 8, 10]\n\nNumbers > 5:  [6, 7, 8, 9, 10]\n\nAll words:    ['hi', 'hello', 'hey', 'greetings', 'yo']\nLong words:   ['hello', 'greetings']\n\nExample 4: sorted() with custom sorting key\n\nNormal sort:        ['Washington', 'banana', 'book', 'pie']\nSort by length:     ['pie', 'book', 'banana', 'Washington']\nSort by last letter: ['banana', 'pie', 'Washington', 'book']\n\nOriginal:           [('Alice', 85), ('Bob', 92), ('Carol', 78), ('Dave', 95)]\nSorted by grade:    [('Dave', 95), ('Bob', 92), ('Alice', 85), ('Carol', 78)]\n\nExample 5: Lambda with multiple parameters\n\nadd(3, 5) = 8\nmultiply(4, 7) = 28\n\nPoints sorted by distance from origin:\n  (1, 2) - distance: 2.24\n  (3, 1) - distance: 3.16\n  (2, 3) - distance: 3.61\n  (5, 4) - distance: 6.40\n\nExample 6: When NOT to use lambda\n\nScores: [95, 87, 73, 62, 58]\nGrades: ['A', 'B', 'C', 'D', 'F']\n\n(This logic is too complex for lambda - used def instead!)"
    },
    {
      "role": "The Simplifier",
      "title": "Syntax Breakdown",
      "content": "<h3>ğŸ” Understanding Lambda Syntax</h3><p><strong>Part 1: Lambda Syntax</strong></p><pre><code>lambda parameters: expression</code></pre><ul><li>ğŸ“Œ <code>lambda</code> keyword (like <code>def</code> but for short functions)</li><li>ğŸ“Œ Parameters (no parentheses needed!)</li><li>ğŸ“Œ Colon <code>:</code></li><li>ğŸ“Œ Single expression (automatically returned)</li><li>ğŸ“Œ No <code>return</code> keyword (implicit return)</li><li>ğŸ“Œ No function name (anonymous)</li></ul><p><strong>Examples:</strong></p><pre><code># Zero parameters\nget_five = lambda: 5\n\n# One parameter\ndouble = lambda x: x * 2\n\n# Two parameters\nadd = lambda x, y: x + y\n\n# Three parameters\nvolume = lambda l, w, h: l * w * h</code></pre><hr><p><strong>Part 2: Comparison - Lambda vs Def</strong></p><pre><code># Regular function with def\ndef double(x):\n    return x * 2\n\n# Equivalent lambda\ndouble = lambda x: x * 2\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n# Regular function\ndef is_even(n):\n    return n % 2 == 0\n\n# Equivalent lambda\nis_even = lambda n: n % 2 == 0\n\n# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n# Regular function\ndef full_name(first, last):\n    return f\"{first} {last}\"\n\n# Equivalent lambda\nfull_name = lambda first, last: f\"{first} {last}\"</code></pre><hr><p><strong>Part 3: map() Function</strong></p><pre><code>map(function, iterable)</code></pre><ul><li>ğŸ“Œ Applies <code>function</code> to every item in <code>iterable</code></li><li>ğŸ“Œ Returns a map object (convert to list with <code>list()</code>)</li><li>ğŸ“Œ Like a list comprehension: <code>[function(x) for x in iterable]</code></li></ul><pre><code># Using map with lambda\nnumbers = [1, 2, 3, 4]\ndoubled = list(map(lambda x: x * 2, numbers))\n# Result: [2, 4, 6, 8]\n\n# Equivalent list comprehension\ndoubled = [x * 2 for x in numbers]\n\n# Equivalent regular function + map\ndef double(x):\n    return x * 2\ndoubled = list(map(double, numbers))</code></pre><hr><p><strong>Part 4: filter() Function</strong></p><pre><code>filter(function, iterable)</code></pre><ul><li>ğŸ“Œ Keeps only items where <code>function(item)</code> returns <code>True</code></li><li>ğŸ“Œ Returns a filter object (convert to list with <code>list()</code>)</li><li>ğŸ“Œ Like a filtered list comprehension: <code>[x for x in iterable if condition]</code></li></ul><pre><code># Using filter with lambda\nnumbers = [1, 2, 3, 4, 5, 6]\nevens = list(filter(lambda x: x % 2 == 0, numbers))\n# Result: [2, 4, 6]\n\n# Equivalent list comprehension\nevens = [x for x in numbers if x % 2 == 0]\n\n# Equivalent regular function + filter\ndef is_even(x):\n    return x % 2 == 0\nevens = list(filter(is_even, numbers))</code></pre><hr><p><strong>Part 5: sorted() with key Parameter</strong></p><pre><code>sorted(iterable, key=function, reverse=False)</code></pre><ul><li>ğŸ“Œ <code>key</code> function determines what to sort by</li><li>ğŸ“Œ The key function extracts a comparison value from each item</li><li>ğŸ“Œ <code>reverse=True</code> for descending order</li></ul><pre><code># Sort by length\nwords = [\"apple\", \"pie\", \"banana\"]\nsorted_words = sorted(words, key=lambda w: len(w))\n# Result: ['pie', 'apple', 'banana']\n\n# Sort tuples by second element\npairs = [(1, 50), (2, 30), (3, 40)]\nsorted_pairs = sorted(pairs, key=lambda p: p[1])\n# Result: [(2, 30), (3, 40), (1, 50)]\n\n# Sort by multiple criteria (last name, then first name)\nnames = [(\"Alice\", \"Smith\"), (\"Bob\", \"Jones\"), (\"Alice\", \"Adams\")]\nsorted_names = sorted(names, key=lambda n: (n[1], n[0]))\n# Result: [('Alice', 'Adams'), ('Bob', 'Jones'), ('Alice', 'Smith')]</code></pre><hr><p><strong>Part 6: Lambda Limitations</strong></p><p>Lambda functions can ONLY contain a single expression. They CANNOT have:</p><ul><li>âŒ Multiple statements</li><li>âŒ Assignments (<code>x = 5</code>)</li><li>âŒ <code>return</code> statement (it's implicit)</li><li>âŒ Annotations or docstrings</li><li>âŒ <code>if/elif/else</code> statements (but can use ternary: <code>x if condition else y</code>)</li></ul><pre><code># âœ… OK: Single expression with ternary\nabsolute = lambda x: x if x >= 0 else -x\n\n# âŒ NOT OK: Multiple statements\nlambda x: \n    y = x * 2\n    return y  # SyntaxError!\n\n# âŒ NOT OK: Assignment\nlambda x: x = x * 2  # SyntaxError!</code></pre><hr><p><strong>Visual Model:</strong></p><pre><code>REGULAR FUNCTION (def):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ def double(x):             â”‚\nâ”‚     return x * 2           â”‚\nâ”‚                            â”‚\nâ”‚ â€¢ Has a name (double)      â”‚\nâ”‚ â€¢ Can have multiple lines  â”‚\nâ”‚ â€¢ Can have docstrings      â”‚\nâ”‚ â€¢ Explicit return          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nLAMBDA FUNCTION:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ lambda x: x * 2            â”‚\nâ”‚                            â”‚\nâ”‚ â€¢ Anonymous (no name)      â”‚\nâ”‚ â€¢ Single expression only   â”‚\nâ”‚ â€¢ No docstring             â”‚\nâ”‚ â€¢ Implicit return          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nBoth create function objects that do the same thing!</code></pre>"
    },
    {
      "role": "The Coder",
      "title": "Exercise",
      "content": "<h3>âœï¸ Your Turn: Data Processing with Lambda</h3><p><strong>Challenge:</strong> You have a list of products with names and prices. Use lambda functions with <code>map()</code>, <code>filter()</code>, and <code>sorted()</code> to process the data.</p><p><strong>Given Data:</strong></p><pre><code>products = [\n    (\"Laptop\", 999.99),\n    (\"Mouse\", 24.99),\n    (\"Keyboard\", 79.99),\n    (\"Monitor\", 299.99),\n    (\"Webcam\", 89.99),\n    (\"Headphones\", 149.99)\n]</code></pre><p><strong>Requirements:</strong></p><ol><li><strong>Task 1:</strong> Use <code>map()</code> with lambda to apply 10% discount to all prices. Create a new list of tuples with discounted prices.</li><li><strong>Task 2:</strong> Use <code>filter()</code> with lambda to find all products under $100 (after discount).</li><li><strong>Task 3:</strong> Use <code>sorted()</code> with lambda to sort products by price (lowest to highest).</li><li><strong>Task 4:</strong> Use <code>sorted()</code> with lambda to sort products by name length (shortest to longest).</li><li><strong>Task 5:</strong> Create a lambda function that calculates final price with tax (7% sales tax) and use it to show total cost for one product.</li></ol><p>Print results for each task with clear labels.</p>",
      "starter_code": "# Given data\nproducts = [\n    (\"Laptop\", 999.99),\n    (\"Mouse\", 24.99),\n    (\"Keyboard\", 79.99),\n    (\"Monitor\", 299.99),\n    (\"Webcam\", 89.99),\n    (\"Headphones\", 149.99)\n]\n\nprint(\"ğŸ›’ PRODUCT DATA PROCESSING\")\nprint(\"â•\" * 50)\nprint(f\"\\nOriginal products: {products}\")\nprint()\n\n# Task 1: Apply 10% discount using map()\nprint(\"Task 1: Apply 10% discount\")\n# Your code here\n\n# Task 2: Filter products under $100 (after discount)\nprint(\"\\nTask 2: Products under $100 (after discount)\")\n# Your code here\n\n# Task 3: Sort by price (lowest to highest)\nprint(\"\\nTask 3: Sort by price (low to high)\")\n# Your code here\n\n# Task 4: Sort by name length\nprint(\"\\nTask 4: Sort by name length\")\n# Your code here\n\n# Task 5: Calculate final price with 7% tax\nprint(\"\\nTask 5: Final price with tax for Laptop\")\n# Your code here\n"
    },
    {
      "role": "The Coder",
      "title": "Solution",
      "content": "<h3>âœ… Solution: Data Processing with Lambda</h3>",
      "code": "# Given data\nproducts = [\n    (\"Laptop\", 999.99),\n    (\"Mouse\", 24.99),\n    (\"Keyboard\", 79.99),\n    (\"Monitor\", 299.99),\n    (\"Webcam\", 89.99),\n    (\"Headphones\", 149.99)\n]\n\nprint(\"ğŸ›’ PRODUCT DATA PROCESSING\")\nprint(\"â•\" * 50)\nprint(f\"\\nOriginal products:\")\nfor name, price in products:\n    print(f\"  {name:12s} - ${price:7.2f}\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# TASK 1: Apply 10% discount using map()\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nprint(\"Task 1: Apply 10% discount to all products\")\nprint(\"â”€\" * 50)\n\n# Lambda that applies 0.9 multiplier (10% off)\ndiscounted = list(map(lambda p: (p[0], p[1] * 0.9), products))\n\nfor name, price in discounted:\n    print(f\"  {name:12s} - ${price:7.2f} (saved ${products[products.index((name, price/0.9))][1] * 0.1:.2f})\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# TASK 2: Filter products under $100 (after discount)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nprint(\"Task 2: Products under $100 (after discount)\")\nprint(\"â”€\" * 50)\n\n# Filter where discounted price < 100\naffordable = list(filter(lambda p: p[1] < 100, discounted))\n\nfor name, price in affordable:\n    print(f\"  {name:12s} - ${price:7.2f}\")\nprint(f\"\\nFound {len(affordable)} affordable products\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# TASK 3: Sort by price (lowest to highest)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nprint(\"Task 3: Products sorted by price (low to high)\")\nprint(\"â”€\" * 50)\n\n# Sort by second element of tuple (price)\nsorted_by_price = sorted(discounted, key=lambda p: p[1])\n\nfor name, price in sorted_by_price:\n    print(f\"  ${price:7.2f} - {name}\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# TASK 4: Sort by name length (shortest to longest)\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nprint(\"Task 4: Products sorted by name length\")\nprint(\"â”€\" * 50)\n\n# Sort by length of first element (name)\nsorted_by_name_length = sorted(products, key=lambda p: len(p[0]))\n\nfor name, price in sorted_by_name_length:\n    print(f\"  {name:12s} (length: {len(name):2d}) - ${price:7.2f}\")\nprint()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# TASK 5: Calculate final price with tax\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nprint(\"Task 5: Final price calculations with 7% tax\")\nprint(\"â”€\" * 50)\n\n# Lambda that applies discount then adds tax\nfinal_price = lambda name, price: price * 0.9 * 1.07\n\n# Show calculation for each product\nfor name, price in products:\n    discounted_price = price * 0.9\n    with_tax = final_price(name, price)\n    print(f\"  {name:12s}:\")\n    print(f\"    Original:  ${price:7.2f}\")\n    print(f\"    Discount:  ${discounted_price:7.2f} (10% off)\")\n    print(f\"    With tax:  ${with_tax:7.2f} (7% tax)\")\n    print()\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# BONUS: Combine operations\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nprint(\"\\nğŸ BONUS: Best deals (under $100 after discount+tax)\")\nprint(\"â•\" * 50)\n\n# Chain operations: discount, add tax, filter, sort\nbest_deals = sorted(\n    filter(\n        lambda p: p[1] * 0.9 * 1.07 < 100,\n        products\n    ),\n    key=lambda p: p[1]\n)\n\nfor name, original_price in best_deals:\n    final = original_price * 0.9 * 1.07\n    print(f\"  {name:12s} - ${final:6.2f} (${original_price:.2f} original)\")\n\nif best_deals:\n    total_savings = sum(p[1] * 0.1 for p in best_deals)\n    print(f\"\\nğŸ’° Total savings on these deals: ${total_savings:.2f}\")",
      "output": "ğŸ›’ PRODUCT DATA PROCESSING\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nOriginal products:\n  Laptop       - $ 999.99\n  Mouse        - $  24.99\n  Keyboard     - $  79.99\n  Monitor      - $ 299.99\n  Webcam       - $  89.99\n  Headphones   - $ 149.99\n\nTask 1: Apply 10% discount to all products\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Laptop       - $ 899.99 (saved $100.00)\n  Mouse        - $  22.49 (saved $2.50)\n  Keyboard     - $  71.99 (saved $8.00)\n  Monitor      - $ 269.99 (saved $30.00)\n  Webcam       - $  80.99 (saved $9.00)\n  Headphones   - $ 134.99 (saved $15.00)\n\nTask 2: Products under $100 (after discount)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Mouse        - $  22.49\n  Keyboard     - $  71.99\n  Webcam       - $  80.99\n\nFound 3 affordable products\n\nTask 3: Products sorted by price (low to high)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  $  22.49 - Mouse\n  $  71.99 - Keyboard\n  $  80.99 - Webcam\n  $ 134.99 - Headphones\n  $ 269.99 - Monitor\n  $ 899.99 - Laptop\n\nTask 4: Products sorted by name length\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Mouse        (length:  5) - $  24.99\n  Webcam       (length:  6) - $  89.99\n  Laptop       (length:  6) - $ 999.99\n  Monitor      (length:  7) - $ 299.99\n  Keyboard     (length:  8) - $  79.99\n  Headphones   (length: 10) - $ 149.99\n\nTask 5: Final price calculations with 7% tax\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Laptop      :\n    Original:  $ 999.99\n    Discount:  $ 899.99 (10% off)\n    With tax:  $ 962.99 (7% tax)\n\n  Mouse       :\n    Original:  $  24.99\n    Discount:  $  22.49 (10% off)\n    With tax:  $  24.06 (7% tax)\n\n  Keyboard    :\n    Original:  $  79.99\n    Discount:  $  71.99 (10% off)\n    With tax:  $  77.03 (7% tax)\n\n  Monitor     :\n    Original:  $ 299.99\n    Discount:  $ 269.99 (10% off)\n    With tax:  $ 288.89 (7% tax)\n\n  Webcam      :\n    Original:  $  89.99\n    Discount:  $  80.99 (10% off)\n    With tax:  $  86.66 (7% tax)\n\n  Headphones  :\n    Original:  $ 149.99\n    Discount:  $ 134.99 (10% off)\n    With tax:  $ 144.44 (7% tax)\n\n\nğŸ BONUS: Best deals (under $100 after discount+tax)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  Mouse        - $ 24.06 ($24.99 original)\n  Keyboard     - $ 77.03 ($79.99 original)\n  Webcam       - $ 86.66 ($89.99 original)\n\nğŸ’° Total savings on these deals: $19.50",
      "explanation": "<h3>ğŸ“š How It Works:</h3><ol><li><strong>Task 1 - map() with Discount Lambda (Line 25):</strong><pre><code>discounted = list(map(lambda p: (p[0], p[1] * 0.9), products))</code></pre><ul><li><code>lambda p:</code> takes a product tuple</li><li><code>(p[0], p[1] * 0.9)</code> creates new tuple: (name, price * 0.9)</li><li><code>map()</code> applies this to every product</li><li><code>list()</code> converts map object to list</li></ul></li><li><strong>Task 2 - filter() Under $100 (Line 39):</strong><pre><code>affordable = list(filter(lambda p: p[1] < 100, discounted))</code></pre><ul><li><code>lambda p: p[1] < 100</code> returns True if price (p[1]) < 100</li><li><code>filter()</code> keeps only products where lambda returns True</li><li>Result: Only products under $100</li></ul></li><li><strong>Task 3 - sorted() by Price (Line 52):</strong><pre><code>sorted_by_price = sorted(discounted, key=lambda p: p[1])</code></pre><ul><li><code>key=lambda p: p[1]</code> tells sorted to compare using price (p[1])</li><li>Without key, it would sort alphabetically by name</li><li>Result: Products from cheapest to most expensive</li></ul></li><li><strong>Task 4 - sorted() by Name Length (Line 64):</strong><pre><code>sorted_by_name_length = sorted(products, key=lambda p: len(p[0]))</code></pre><ul><li><code>key=lambda p: len(p[0])</code> compares by length of name</li><li><code>len(p[0])</code> gets length of first element (name)</li><li>Result: Shortest names first</li></ul></li><li><strong>Task 5 - Lambda for Calculation (Line 76):</strong><pre><code>final_price = lambda name, price: price * 0.9 * 1.07</code></pre><ul><li>Takes two parameters: name and price</li><li>Applies discount (0.9) then tax (1.07)</li><li>Returns final price in one calculation</li></ul></li><li><strong>BONUS - Chaining Operations (Lines 96-103):</strong><pre><code>best_deals = sorted(\n    filter(\n        lambda p: p[1] * 0.9 * 1.07 < 100,\n        products\n    ),\n    key=lambda p: p[1]\n)</code></pre><ul><li>First: <code>filter()</code> keeps products under $100 after discount+tax</li><li>Then: <code>sorted()</code> sorts the filtered results by price</li><li>Shows how operations can be chained together</li></ul></li></ol><h3>âš ï¸ Common Mistakes:</h3><ol><li><strong>Forgetting list() Conversion:</strong><pre><code># âŒ WRONG - map/filter return iterators, not lists\ndoubled = map(lambda x: x * 2, numbers)\nprint(doubled)  # Prints <map object> not the values!\n\n# âœ… CORRECT - convert to list\ndoubled = list(map(lambda x: x * 2, numbers))\nprint(doubled)  # Prints [2, 4, 6, 8]</code></pre></li><li><strong>Trying Multiple Statements in Lambda:</strong><pre><code># âŒ WRONG - lambda can't have multiple statements\napply_discount = lambda p: \n    discount = p[1] * 0.1\n    return p[1] - discount  # SyntaxError!\n\n# âœ… CORRECT - single expression\napply_discount = lambda p: p[1] * 0.9</code></pre></li><li><strong>Wrong Tuple Index:</strong><pre><code>products = [(\"Laptop\", 999.99)]\n\n# âŒ WRONG - p[0] is name, not price\nsorted(products, key=lambda p: p[0])  # Sorts alphabetically\n\n# âœ… CORRECT - p[1] is price\nsorted(products, key=lambda p: p[1])  # Sorts by price</code></pre></li><li><strong>Lambda vs List Comprehension:</strong><pre><code># Both work, choose based on readability:\n\n# Using map with lambda\ndoubled = list(map(lambda x: x * 2, numbers))\n\n# Using list comprehension (often more Pythonic)\ndoubled = [x * 2 for x in numbers]\n\n# Use lambda when passing to functions like sorted(), filter()\n# Use comprehension when building lists from scratch</code></pre></li></ol><h3>ğŸ’¡ Pro Tips:</h3><ul><li>âœ… <strong>Lambda for sorting:</strong> Very common pattern - <code>sorted(data, key=lambda x: x[1])</code></li><li>âœ… <strong>Keep lambdas simple:</strong> If it needs explanation, use <code>def</code> instead</li><li>âœ… <strong>List comprehensions often clearer:</strong> For simple transformations, <code>[x*2 for x in nums]</code> beats <code>list(map(lambda x: x*2, nums))</code></li><li>âœ… <strong>Name stored lambdas:</strong> <code>calculate_tax = lambda x: x * 1.07</code> is reusable</li><li>âœ… <strong>Chain operations:</strong> <code>sorted(filter(...))</code> processes data step by step</li></ul>"
    },
    {
      "role": "Summary",
      "title": "Key Takeaways",
      "content": "<h3>ğŸ¯ Essential Points to Remember:</h3><ol><li><strong>Lambda syntax - anonymous functions:</strong><pre><code>lambda parameters: expression</code></pre><ul><li>No <code>def</code>, no function name, no <code>return</code> keyword</li><li>Single expression only (automatically returned)</li><li>Perfect for simple, one-off functions</li></ul></li><li><strong>Lambda vs Regular Function:</strong><pre><code># Regular function\ndef double(x):\n    return x * 2\n\n# Equivalent lambda\ndouble = lambda x: x * 2</code></pre><p>Both create the same type of function object!</p></li><li><strong>map() - Transform every item:</strong><pre><code>numbers = [1, 2, 3, 4]\ndoubled = list(map(lambda x: x * 2, numbers))\n# Result: [2, 4, 6, 8]</code></pre><ul><li>Applies function to each item</li><li>Returns map object (convert with <code>list()</code>)</li><li>Like: <code>[x * 2 for x in numbers]</code></li></ul></li><li><strong>filter() - Keep items that pass test:</strong><pre><code>numbers = [1, 2, 3, 4, 5, 6]\nevens = list(filter(lambda x: x % 2 == 0, numbers))\n# Result: [2, 4, 6]</code></pre><ul><li>Keeps items where function returns True</li><li>Returns filter object (convert with <code>list()</code>)</li><li>Like: <code>[x for x in numbers if x % 2 == 0]</code></li></ul></li><li><strong>sorted() with key - Custom sorting:</strong><pre><code>words = [\"apple\", \"pie\", \"banana\"]\nsorted_words = sorted(words, key=lambda w: len(w))\n# Result: ['pie', 'apple', 'banana']</code></pre><ul><li><code>key</code> function extracts comparison value</li><li>Very common with lambda for custom sorting</li><li><code>reverse=True</code> for descending order</li></ul></li><li><strong>Lambda with multiple parameters:</strong><pre><code>add = lambda x, y: x + y\nresult = add(3, 5)  # Returns 8</code></pre></li><li><strong>When to use lambda:</strong><ul><li>âœ… Simple, single-expression functions</li><li>âœ… One-time use (especially with map, filter, sorted)</li><li>âœ… When function is obvious and doesn't need documentation</li></ul></li><li><strong>When NOT to use lambda:</strong><ul><li>âŒ Complex logic needing multiple statements</li><li>âŒ Needs to be reused in many places (use <code>def</code>)</li><li>âŒ Requires comments or docstring to explain</li><li>âŒ Contains if/elif/else (though ternary <code>x if cond else y</code> is OK)</li></ul></li><li><strong>Lambda limitations:</strong><ul><li>Single expression only</li><li>No statements (no assignment, no return, no pass, etc.)</li><li>No docstrings or annotations</li><li>Implicit return (expression result is automatically returned)</li></ul></li><li><strong>List comprehension vs map/filter:</strong><pre><code># Both work - choose based on preference\n\n# Map/filter style\nlist(map(lambda x: x*2, nums))\nlist(filter(lambda x: x>0, nums))\n\n# List comprehension style (often preferred)\n[x*2 for x in nums]\n[x for x in nums if x>0]</code></pre></li><li><strong>Common pattern - sorting tuples:</strong><pre><code>students = [(\"Alice\", 85), (\"Bob\", 92)]\n\n# Sort by grade (second element)\nby_grade = sorted(students, key=lambda s: s[1])</code></pre></li></ol><h3>ğŸš€ Coming Up Next:</h3><p>In the next lesson, you'll apply everything you've learned about functions in a <strong>Mini-Project</strong> where you'll build a practical function library with utilities for calculations, text processing, and data analysis!</p>"
    }
  ],
  "checkpoint_quiz": [
    {
      "question": "What is the main difference between a lambda function and a regular function defined with 'def'?",
      "options": [
        "Lambda functions are faster",
        "Lambda functions are anonymous and limited to single expressions",
        "Lambda functions can't have parameters",
        "There is no difference"
      ],
      "correct_answer": 1,
      "explanation": "Lambda functions are ANONYMOUS (no name) and can only contain a SINGLE EXPRESSION (no multiple statements). Regular functions use 'def', have names, can have docstrings, and can contain multiple statements. Both create function objects, but lambdas are for simple, one-off operations."
    },
    {
      "question": "What does this code produce?\n\nnumbers = [1, 2, 3, 4, 5]\nresult = list(filter(lambda x: x > 3, numbers))",
      "options": [
        "[1, 2, 3]",
        "[4, 5]",
        "[True, True, True, False, False]",
        "[2, 3, 4, 5, 6]"
      ],
      "correct_answer": 1,
      "explanation": "filter() keeps only items where the function returns True. The lambda 'x > 3' returns True for 4 and 5, so the result is [4, 5]. filter() doesn't transform items (that's map's job), it just decides which ones to keep or remove."
    },
    {
      "question": "What does the 'key' parameter do in sorted()?\n\nsorted(words, key=lambda w: len(w))",
      "options": [
        "Filters out words that don't match",
        "Determines what value to use for comparison when sorting",
        "Encrypts the words",
        "Reverses the sorting order"
      ],
      "correct_answer": 1,
      "explanation": "The 'key' parameter specifies a function that EXTRACTS A COMPARISON VALUE from each item. Here, 'lambda w: len(w)' extracts the length, so words are sorted by length instead of alphabetically. The key function determines what to compare when deciding order."
    }
  ]
}
