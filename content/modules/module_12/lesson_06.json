{
  "lesson_id": "12_06",
  "title": "Regular Expressions",
  "module_id": 12,
  "order_index": 6,
  "description": "Master regular expressions for pattern matching. Learn the re module, common patterns, groups, and practical applications like validation, extraction, and text processing.",
  "estimated_minutes": 40,
  "content_blocks": [
    {
      "type": "the_simplifier",
      "title": "The Concept: Pattern Matching",
      "content": "**Regular Expressions (regex) = Advanced find/replace**\n\n**Think of a search filter:**\n\n‚ùå **Simple string matching:**\n```python\nif '@' in email and '.' in email:\n    # Too simple!\n    pass\n```\n\n‚úÖ **Regex pattern:**\n```python\nimport re\nif re.match(r'^[\\w.-]+@[\\w.-]+\\.\\w+$', email):\n    # Precise pattern!\n    pass\n```\n\n**What regex can do:**\n\n1. **Validate** ‚úì\n   - Email addresses\n   - Phone numbers\n   - Passwords\n   - URLs\n\n2. **Extract** üîç\n   - Dates from text\n   - Phone numbers from documents\n   - URLs from HTML\n\n3. **Replace** üîÑ\n   - Format phone numbers\n   - Remove unwanted characters\n   - Transform text patterns\n\n4. **Split** ‚úÇÔ∏è\n   - Complex delimiters\n   - Multiple separators\n   - Conditional splitting\n\n**Common patterns:**\n- `.` - Any character (except newline)\n- `\\d` - Digit (0-9)\n- `\\w` - Word character (a-z, A-Z, 0-9, _)\n- `\\s` - Whitespace (space, tab, newline)\n- `*` - 0 or more\n- `+` - 1 or more\n- `?` - 0 or 1 (optional)\n- `[]` - Character class\n- `()` - Group\n- `^` - Start of string\n- `$` - End of string"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Basic Regular Expressions",
      "code": "import re\n\nprint(\"=== Basic Matching ===\")\n\n# re.match() - Match at start of string\ntext = \"Hello World\"\nif re.match(r\"Hello\", text):\n    print(f\"'{text}' starts with 'Hello'\")\n\nif not re.match(r\"World\", text):\n    print(f\"'{text}' does NOT start with 'World'\")\n\n# re.search() - Find anywhere in string\nif re.search(r\"World\", text):\n    print(f\"'{text}' contains 'World'\")\n\n# re.findall() - Find all occurrences\ntext = \"The price is $10, $20, and $30\"\nprices = re.findall(r\"\\$\\d+\", text)\nprint(f\"Found prices: {prices}\")\n\nprint(\"\\n=== Character Classes ===\")\n\n# \\d - digits\ntext = \"My phone: 555-1234\"\ndigits = re.findall(r\"\\d\", text)\nprint(f\"All digits: {''.join(digits)}\")\n\n# \\d+ - one or more digits\nnumbers = re.findall(r\"\\d+\", text)\nprint(f\"Number groups: {numbers}\")\n\n# \\w - word characters\ntext = \"Hello, World! 123\"\nwords = re.findall(r\"\\w+\", text)\nprint(f\"Words: {words}\")\n\n# \\s - whitespace\ntext = \"Split   on    spaces\"\nparts = re.split(r\"\\s+\", text)\nprint(f\"Split parts: {parts}\")\n\nprint(\"\\n=== Quantifiers ===\")\n\n# * - zero or more\npattern = r\"a*b\"\nprint(f\"'b' matches: {bool(re.match(pattern, 'b'))}\")\nprint(f\"'ab' matches: {bool(re.match(pattern, 'ab'))}\")\nprint(f\"'aaab' matches: {bool(re.match(pattern, 'aaab'))}\")\n\n# + - one or more\npattern = r\"a+b\"\nprint(f\"\\n'b' matches a+b: {bool(re.match(pattern, 'b'))}\")\nprint(f\"'ab' matches a+b: {bool(re.match(pattern, 'ab'))}\")\n\n# ? - zero or one (optional)\npattern = r\"colou?r\"  # Matches color or colour\nprint(f\"\\n'color' matches: {bool(re.match(pattern, 'color'))}\")\nprint(f\"'colour' matches: {bool(re.match(pattern, 'colour'))}\")\n\n# {n} - exactly n times\npattern = r\"\\d{3}\"  # Exactly 3 digits\nprint(f\"\\n'123' matches \\\\d{{3}}: {bool(re.match(pattern, '123'))}\")\nprint(f\"'12' matches \\\\d{{3}}: {bool(re.match(pattern, '12'))}\")\n\n# {n,m} - between n and m times\npattern = r\"\\d{2,4}\"  # 2 to 4 digits\nprint(f\"\\n'12' matches \\\\d{{2,4}}: {bool(re.match(pattern, '12'))}\")\nprint(f\"'123' matches \\\\d{{2,4}}: {bool(re.match(pattern, '123'))}\")\n\nprint(\"\\n=== Anchors and Boundaries ===\")\n\n# ^ - start of string\npattern = r\"^Hello\"\nprint(f\"'Hello World' starts with Hello: {bool(re.match(pattern, 'Hello World'))}\")\nprint(f\"'Say Hello' starts with Hello: {bool(re.match(pattern, 'Say Hello'))}\")\n\n# $ - end of string\npattern = r\"World$\"\nprint(f\"\\n'Hello World' ends with World: {bool(re.search(pattern, 'Hello World'))}\")\nprint(f\"'World Hello' ends with World: {bool(re.search(pattern, 'World Hello'))}\")\n\n# Combining ^ and $ - full string match\npattern = r\"^\\d{3}$\"  # Exactly 3 digits, nothing else\nprint(f\"\\n'123' is exactly 3 digits: {bool(re.match(pattern, '123'))}\")\nprint(f\"'1234' is exactly 3 digits: {bool(re.match(pattern, '1234'))}\")\n\nprint(\"\\n=== Character Classes ===\")\n\n# [abc] - any of these characters\npattern = r\"[aeiou]\"\nvowels = re.findall(pattern, \"hello world\")\nprint(f\"Vowels in 'hello world': {vowels}\")\n\n# [a-z] - range\npattern = r\"[a-z]+\"\nwords = re.findall(pattern, \"Hello123World456\")\nprint(f\"Lowercase words: {words}\")\n\n# [^abc] - NOT these characters\npattern = r\"[^aeiou]+\"\nconsonants = re.findall(pattern, \"hello world\")\nprint(f\"Consonant groups: {consonants}\")",
      "explanation": "**Key regex functions:**\n\n**1. re.match(pattern, string):**\n- Matches at START of string\n- Returns Match object or None\n```python\nre.match(r\"Hello\", \"Hello World\")  # Matches\nre.match(r\"World\", \"Hello World\")  # Doesn't match\n```\n\n**2. re.search(pattern, string):**\n- Searches ANYWHERE in string\n- Returns first match\n```python\nre.search(r\"World\", \"Hello World\")  # Matches\n```\n\n**3. re.findall(pattern, string):**\n- Returns list of ALL matches\n```python\nre.findall(r\"\\d+\", \"10 cats, 20 dogs\")  # ['10', '20']\n```\n\n**4. re.sub(pattern, replacement, string):**\n- Replace matches\n```python\nre.sub(r\"\\d+\", \"X\", \"10 cats\")  # \"X cats\"\n```\n\n**Raw strings (r\"\"):**\n- Use r\"\" for regex patterns\n- Prevents backslash escaping issues\n- r\"\\d\" not \"\\\\d\"",
      "output": "=== Basic Matching ===\n'Hello World' starts with 'Hello'\n'Hello World' does NOT start with 'World'\n'Hello World' contains 'World'\nFound prices: ['$10', '$20', '$30']\n\n=== Character Classes ===\nAll digits: 5551234\nNumber groups: ['555', '1234']\nWords: ['Hello', 'World', '123']\nSplit parts: ['Split', 'on', 'spaces']\n\n=== Quantifiers ===\n'b' matches: True\n'ab' matches: True\n'aaab' matches: True\n\n'b' matches a+b: False\n'ab' matches a+b: True\n\n'color' matches: True\n'colour' matches: True\n\n'123' matches \\d{3}: True\n'12' matches \\d{3}: False\n\n'12' matches \\d{2,4}: True\n'123' matches \\d{2,4}: True\n\n=== Anchors and Boundaries ===\n'Hello World' starts with Hello: True\n'Say Hello' starts with Hello: False\n\n'Hello World' ends with World: True\n'World Hello' ends with World: False\n\n'123' is exactly 3 digits: True\n'1234' is exactly 3 digits: False\n\n=== Character Classes ===\nVowels in 'hello world': ['e', 'o', 'o']\nLowercase words: ['ello', 'orld']\nConsonant groups: ['h', 'll', ' w', 'rld']"
    },
    {
      "type": "the_simplifier",
      "title": "Syntax Breakdown",
      "content": "**Pattern syntax quick reference:**\n\n**Special characters:**\n```\n.   Any character (except newline)\n\\d  Digit [0-9]\n\\D  Not digit [^0-9]\n\\w  Word char [a-zA-Z0-9_]\n\\W  Not word char\n\\s  Whitespace [ \\t\\n\\r\\f\\v]\n\\S  Not whitespace\n```\n\n**Quantifiers:**\n```\n*      0 or more\n+      1 or more\n?      0 or 1 (optional)\n{3}    Exactly 3\n{2,5}  Between 2 and 5\n{2,}   2 or more\n```\n\n**Anchors:**\n```\n^   Start of string\n$   End of string\n\\b  Word boundary\n```\n\n**Groups:**\n```\n(...)   Capturing group\n(?:...)  Non-capturing group\n|       OR (alternation)\n```\n\n**Character classes:**\n```\n[abc]    Any of a, b, c\n[a-z]    Range (a through z)\n[^abc]   NOT a, b, or c\n```\n\n**Escaping special chars:**\n```\n\\.  Literal dot\n\\$  Literal dollar sign\n\\*  Literal asterisk\nUse \\ before special characters\n```"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Groups and Practical Patterns",
      "code": "import re\n\nprint(\"=== Capturing Groups ===\")\n\n# Groups with ()\npattern = r\"(\\d{3})-(\\d{3})-(\\d{4})\"\nphone = \"555-123-4567\"\nmatch = re.search(pattern, phone)\n\nif match:\n    print(f\"Full match: {match.group(0)}\")\n    print(f\"Area code: {match.group(1)}\")\n    print(f\"Exchange: {match.group(2)}\")\n    print(f\"Number: {match.group(3)}\")\n    print(f\"All groups: {match.groups()}\")\n\n# Named groups\npattern = r\"(?P<area>\\d{3})-(?P<exchange>\\d{3})-(?P<number>\\d{4})\"\nmatch = re.search(pattern, phone)\n\nif match:\n    print(f\"\\nNamed groups:\")\n    print(f\"Area: {match.group('area')}\")\n    print(f\"Exchange: {match.group('exchange')}\")\n    print(f\"Number: {match.group('number')}\")\n    print(f\"Dict: {match.groupdict()}\")\n\nprint(\"\\n=== Email Validation ===\")\n\nemail_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n\nemails = [\n    \"user@example.com\",\n    \"test.user@domain.co.uk\",\n    \"invalid@\",\n    \"@invalid.com\",\n    \"no-at-sign.com\"\n]\n\nfor email in emails:\n    valid = bool(re.match(email_pattern, email))\n    print(f\"{email:25} {'‚úì Valid' if valid else '‚úó Invalid'}\")\n\nprint(\"\\n=== URL Extraction ===\")\n\ntext = \"\"\"\nCheck out https://www.example.com and http://test.org\nAlso visit ftp://files.example.com for downloads.\n\"\"\"\n\nurl_pattern = r'https?://[\\w.-]+\\.[a-zA-Z]{2,}'\nurls = re.findall(url_pattern, text)\nprint(f\"Found URLs: {urls}\")\n\nprint(\"\\n=== Phone Number Formatting ===\")\n\ndef format_phone(phone):\n    \"\"\"Extract and format phone number\"\"\"\n    # Remove all non-digits\n    digits = re.sub(r'\\D', '', phone)\n    \n    # Format as (XXX) XXX-XXXX\n    if len(digits) == 10:\n        return f\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\"\n    return phone\n\nphones = [\n    \"5551234567\",\n    \"555-123-4567\",\n    \"(555) 123-4567\",\n    \"555.123.4567\"\n]\n\nfor phone in phones:\n    formatted = format_phone(phone)\n    print(f\"{phone:20} ‚Üí {formatted}\")\n\nprint(\"\\n=== Date Extraction ===\")\n\ntext = \"Meeting on 2024-01-15, deadline 03/20/2024, event: 12-25-2024\"\n\n# Multiple date formats\ndate_patterns = [\n    r'\\d{4}-\\d{2}-\\d{2}',  # YYYY-MM-DD\n    r'\\d{2}/\\d{2}/\\d{4}',  # MM/DD/YYYY\n    r'\\d{2}-\\d{2}-\\d{4}',  # MM-DD-YYYY\n]\n\nall_dates = []\nfor pattern in date_patterns:\n    dates = re.findall(pattern, text)\n    all_dates.extend(dates)\n\nprint(f\"Dates found: {all_dates}\")\n\nprint(\"\\n=== Text Substitution ===\")\n\n# Replace multiple spaces with single space\ntext = \"Too    many     spaces\"\ncleaned = re.sub(r'\\s+', ' ', text)\nprint(f\"Original: '{text}'\")\nprint(f\"Cleaned:  '{cleaned}'\")\n\n# Remove HTML tags\nhtml = \"<p>Hello <b>World</b>!</p>\"\nplain = re.sub(r'<[^>]+>', '', html)\nprint(f\"\\nHTML: {html}\")\nprint(f\"Plain: {plain}\")\n\n# Censor words\ntext = \"This is damn bad stuff\"\ncensored = re.sub(r'\\b(damn|bad)\\b', '***', text, flags=re.IGNORECASE)\nprint(f\"\\nOriginal: {text}\")\nprint(f\"Censored: {censored}\")\n\nprint(\"\\n=== Split with Regex ===\")\n\n# Split on multiple delimiters\ntext = \"apple;banana,cherry:date|elderberry\"\nfruits = re.split(r'[;,:|\n]+', text)\nprint(f\"Fruits: {fruits}\")\n\n# Split but keep delimiter\ntext = \"Question? Answer! Statement.\"\nparts = re.split(r'([.!?])', text)\nprint(f\"With punctuation: {parts}\")\n\nprint(\"\\n=== Password Validation ===\")\n\ndef validate_password(password):\n    \"\"\"Validate password strength\"\"\"\n    checks = {\n        'length': len(password) >= 8,\n        'uppercase': bool(re.search(r'[A-Z]', password)),\n        'lowercase': bool(re.search(r'[a-z]', password)),\n        'digit': bool(re.search(r'\\d', password)),\n        'special': bool(re.search(r'[!@#$%^&*()]', password))\n    }\n    \n    return all(checks.values()), checks\n\npasswords = [\n    \"weak\",\n    \"StrongPass123!\",\n    \"NoDigits!\",\n    \"ALLUPPER123!\"\n]\n\nfor pwd in passwords:\n    valid, checks = validate_password(pwd)\n    status = \"‚úì Valid\" if valid else \"‚úó Invalid\"\n    print(f\"{pwd:20} {status}\")\n    if not valid:\n        failed = [k for k, v in checks.items() if not v]\n        print(f\"{'':20} Missing: {', '.join(failed)}\")",
      "explanation": "**Capturing groups:**\n```python\npattern = r\"(\\d{3})-(\\d{3})-(\\d{4})\"\nmatch = re.search(pattern, \"555-123-4567\")\nmatch.group(0)  # Full match: \"555-123-4567\"\nmatch.group(1)  # First group: \"555\"\nmatch.groups()  # All groups: ('555', '123', '4567')\n```\n\n**Named groups:**\n```python\npattern = r\"(?P<area>\\d{3})-(?P<num>\\d{3})\"\nmatch.group('area')  # By name\nmatch.groupdict()    # Dict of named groups\n```\n\n**Substitution with groups:**\n```python\n# Swap first and last name\nre.sub(r'(\\w+) (\\w+)', r'\\2, \\1', \"John Doe\")\n# Result: \"Doe, John\"\n```\n\n**Flags:**\n```python\nre.IGNORECASE  # Case-insensitive\nre.MULTILINE   # ^ and $ match line boundaries\nre.DOTALL      # . matches newlines too\n```",
      "output": "=== Capturing Groups ===\nFull match: 555-123-4567\nArea code: 555\nExchange: 123\nNumber: 4567\nAll groups: ('555', '123', '4567')\n\nNamed groups:\nArea: 555\nExchange: 123\nNumber: 4567\nDict: {'area': '555', 'exchange': '123', 'number': '4567'}\n\n=== Email Validation ===\nuser@example.com          ‚úì Valid\ntest.user@domain.co.uk    ‚úì Valid\ninvalid@                  ‚úó Invalid\n@invalid.com              ‚úó Invalid\nno-at-sign.com            ‚úó Invalid\n\n=== URL Extraction ===\nFound URLs: ['https://www.example.com', 'http://test.org']\n\n=== Phone Number Formatting ===\n5551234567           ‚Üí (555) 123-4567\n555-123-4567         ‚Üí (555) 123-4567\n(555) 123-4567       ‚Üí (555) 123-4567\n555.123.4567         ‚Üí (555) 123-4567\n\n=== Date Extraction ===\nDates found: ['2024-01-15', '03/20/2024', '12-25-2024']\n\n=== Text Substitution ===\nOriginal: 'Too    many     spaces'\nCleaned:  'Too many spaces'\n\nHTML: <p>Hello <b>World</b>!</p>\nPlain: Hello World!\n\nOriginal: This is damn bad stuff\nCensored: This is *** *** stuff\n\n=== Split with Regex ===\nFruits: ['apple', 'banana', 'cherry', 'date', 'elderberry']\nWith punctuation: ['Question', '?', ' Answer', '!', ' Statement', '.', '']\n\n=== Password Validation ===\nweak                 ‚úó Invalid\n                     Missing: length, uppercase, digit, special\nStrongPass123!       ‚úì Valid\nNoDigits!            ‚úó Invalid\n                     Missing: digit\nALLUPPER123!         ‚úó Invalid\n                     Missing: lowercase"
    },
    {
      "type": "the_coder",
      "title": "Interactive Exercise",
      "instruction": "Create a log parser that extracts:\n1. Timestamp (YYYY-MM-DD HH:MM:SS)\n2. Log level (INFO, WARNING, ERROR)\n3. Message\nFrom log lines like: \"2024-01-15 10:30:45 [ERROR] Database connection failed\"",
      "starter_code": "import re\n\ndef parse_log_line(line):\n    # TODO: Create regex pattern with named groups\n    pattern = r''\n    \n    # TODO: Match and extract groups\n    match = None\n    \n    if match:\n        return match.groupdict()\n    return None\n\nlogs = [\n    \"2024-01-15 10:30:45 [ERROR] Database connection failed\",\n    \"2024-01-15 10:31:12 [INFO] Application started\",\n    \"2024-01-15 10:35:22 [WARNING] High memory usage\"\n]\n\nfor log in logs:\n    parsed = parse_log_line(log)\n    print(parsed)",
      "hint": "Use named groups: (?P<name>pattern). Timestamp: \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}. Level: \\w+."
    },
    {
      "type": "the_coder",
      "title": "Solution",
      "solution_code": "import re\nfrom typing import Dict, Optional\n\ndef parse_log_line(line: str) -> Optional[Dict[str, str]]:\n    \"\"\"Parse log line and extract components\"\"\"\n    pattern = r'(?P<timestamp>\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) \\[(?P<level>\\w+)\\] (?P<message>.+)'\n    \n    match = re.search(pattern, line)\n    \n    if match:\n        return match.groupdict()\n    return None\n\ndef parse_log_file(filename: str) -> list[Dict[str, str]]:\n    \"\"\"Parse entire log file\"\"\"\n    results = []\n    \n    with open(filename) as f:\n        for line in f:\n            parsed = parse_log_line(line.strip())\n            if parsed:\n                results.append(parsed)\n    \n    return results\n\ndef filter_by_level(logs: list[Dict[str, str]], level: str) -> list[Dict[str, str]]:\n    \"\"\"Filter logs by level\"\"\"\n    return [log for log in logs if log['level'] == level]\n\nprint(\"=== Testing Log Parser ===\")\n\nlogs = [\n    \"2024-01-15 10:30:45 [ERROR] Database connection failed\",\n    \"2024-01-15 10:31:12 [INFO] Application started\",\n    \"2024-01-15 10:35:22 [WARNING] High memory usage\",\n    \"2024-01-15 10:40:15 [ERROR] API timeout\",\n    \"2024-01-15 10:45:30 [INFO] Request processed successfully\"\n]\n\nprint(\"\\nParsing individual logs:\")\nfor log in logs:\n    parsed = parse_log_line(log)\n    if parsed:\n        print(f\"Time: {parsed['timestamp']:20} Level: {parsed['level']:8} Message: {parsed['message']}\")\n\n# Create test log file\nwith open('application.log', 'w') as f:\n    for log in logs:\n        f.write(log + '\\n')\n\nprint(\"\\n=== Parsing File ===\")\nparsed_logs = parse_log_file('application.log')\nprint(f\"Total logs parsed: {len(parsed_logs)}\")\n\nprint(\"\\n=== Filtering by Level ===\")\nerrors = filter_by_level(parsed_logs, 'ERROR')\nprint(f\"\\nERROR logs ({len(errors)}):\")\nfor log in errors:\n    print(f\"  {log['timestamp']}: {log['message']}\")\n\nwarnings = filter_by_level(parsed_logs, 'WARNING')\nprint(f\"\\nWARNING logs ({len(warnings)}):\")\nfor log in warnings:\n    print(f\"  {log['timestamp']}: {log['message']}\")\n\nprint(\"\\n=== Advanced: Log Statistics ===\")\n\ndef analyze_logs(logs: list[Dict[str, str]]) -> Dict:\n    \"\"\"Analyze log statistics\"\"\"\n    from collections import Counter\n    \n    level_counts = Counter(log['level'] for log in logs)\n    \n    # Extract hours from timestamps\n    hours = [int(log['timestamp'][11:13]) for log in logs]\n    hour_counts = Counter(hours)\n    \n    return {\n        'total': len(logs),\n        'by_level': dict(level_counts),\n        'by_hour': dict(hour_counts),\n        'first': logs[0]['timestamp'] if logs else None,\n        'last': logs[-1]['timestamp'] if logs else None\n    }\n\nstats = analyze_logs(parsed_logs)\nprint(f\"Total logs: {stats['total']}\")\nprint(f\"By level: {stats['by_level']}\")\nprint(f\"By hour: {stats['by_hour']}\")\nprint(f\"Time range: {stats['first']} to {stats['last']}\")\n\nprint(\"\\n=== More Complex Patterns ===\")\n\n# Extract IP addresses from logs\nlog_with_ip = \"2024-01-15 10:30:45 [INFO] Request from 192.168.1.100 processed\"\nip_pattern = r'\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b'\nips = re.findall(ip_pattern, log_with_ip)\nprint(f\"\\nIP addresses: {ips}\")\n\n# Extract durations\nlog_with_duration = \"2024-01-15 10:30:45 [INFO] Request completed in 1.234s\"\nduration_pattern = r'(\\d+\\.\\d+)s'\nmatch = re.search(duration_pattern, log_with_duration)\nif match:\n    print(f\"Duration: {match.group(1)} seconds\")\n\n# Extract key-value pairs\nlog_with_data = \"2024-01-15 10:30:45 [INFO] user=alice action=login status=success\"\nkv_pattern = r'(\\w+)=(\\w+)'\ndata = dict(re.findall(kv_pattern, log_with_data))\nprint(f\"Key-value pairs: {data}\")\n\nimport os\nif os.path.exists('application.log'):\n    os.remove('application.log')",
      "explanation": "**Complete log parser solution:**\n\n**Pattern breakdown:**\n```python\n(?P<timestamp>\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\n# Named group 'timestamp'\n# YYYY-MM-DD HH:MM:SS format\n\n\\[(?P<level>\\w+)\\]\n# Named group 'level' in brackets\n# One or more word characters\n\n(?P<message>.+)\n# Named group 'message'\n# One or more of any character\n```\n\n**Real-world applications:**\n- Log analysis\n- Data extraction\n- Input validation\n- Text processing\n- Web scraping\n- Configuration parsing\n\n**Best practices:**\n- Use raw strings (r\"\")\n- Test patterns thoroughly\n- Use named groups for clarity\n- Compile patterns if reusing\n- Keep patterns readable (use comments)\n\n**Performance tip:**\n```python\n# Compile for reuse\npattern = re.compile(r'pattern')\nfor text in texts:\n    pattern.search(text)  # Faster!\n```",
      "output": "=== Testing Log Parser ===\n\nParsing individual logs:\nTime: 2024-01-15 10:30:45  Level: ERROR    Message: Database connection failed\nTime: 2024-01-15 10:31:12  Level: INFO     Message: Application started\nTime: 2024-01-15 10:35:22  Level: WARNING  Message: High memory usage\nTime: 2024-01-15 10:40:15  Level: ERROR    Message: API timeout\nTime: 2024-01-15 10:45:30  Level: INFO     Message: Request processed successfully\n\n=== Parsing File ===\nTotal logs parsed: 5\n\n=== Filtering by Level ===\n\nERROR logs (2):\n  2024-01-15 10:30:45: Database connection failed\n  2024-01-15 10:40:15: API timeout\n\nWARNING logs (1):\n  2024-01-15 10:35:22: High memory usage\n\n=== Advanced: Log Statistics ===\nTotal logs: 5\nBy level: {'ERROR': 2, 'INFO': 2, 'WARNING': 1}\nBy hour: {10: 5}\nTime range: 2024-01-15 10:30:45 to 2024-01-15 10:45:30\n\n=== More Complex Patterns ===\n\nIP addresses: ['192.168.1.100']\nDuration: 1.234 seconds\nKey-value pairs: {'user': 'alice', 'action': 'login', 'status': 'success'}",
      "common_mistakes": [
        "Forgetting to use raw strings (r'') - causes backslash issues",
        "Using .* when you mean .+? (greedy vs lazy matching)",
        "Not escaping special characters (. $ * + ?)",
        "Confusing re.match() (start only) with re.search() (anywhere)",
        "Forgetting that groups are 1-indexed (group(0) is full match)"
      ]
    },
    {
      "type": "key_takeaways",
      "title": "Key Takeaways",
      "takeaways": [
        "**re.search() finds anywhere, re.match() only at start** - Most common confusion",
        "**Always use raw strings r''** - Prevents backslash escaping issues",
        "**\\d digit, \\w word, \\s space** - Most common character classes",
        "**+ means 1+, * means 0+, ? means 0 or 1** - Quantifiers",
        "**^ start, $ end** - Anchors for full string matching",
        "**() creates groups** - Access with match.group(1), match.groups()",
        "**Named groups: (?P<name>...)** - Better than numbers",
        "**Compile patterns if reusing:** pattern = re.compile(r'...')"
      ]
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "What's the difference between re.match() and re.search()?",
        "options": [
          "No difference",
          "match() only checks start of string, search() checks anywhere",
          "search() is faster",
          "match() is case-sensitive"
        ],
        "correct_answer": 1,
        "explanation": "re.match() only matches at the beginning of the string, while re.search() looks for a match anywhere in the string."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "What does the pattern r'\\d{3}' match?",
        "options": [
          "Any 3 characters",
          "Exactly 3 digits",
          "3 or more digits",
          "Up to 3 digits"
        ],
        "correct_answer": 1,
        "explanation": "\\d matches a digit, and {3} means exactly 3 times. So \\d{3} matches exactly three consecutive digits."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "Why should you use raw strings (r'') for regex patterns?",
        "options": [
          "They make regex faster",
          "They prevent backslash escaping issues",
          "They're required by the re module",
          "They enable case-insensitive matching"
        ],
        "correct_answer": 1,
        "explanation": "Raw strings treat backslashes literally, preventing issues. Without r'', you'd need '\\\\d' instead of r'\\d' for a digit."
      }
    ]
  }
}
