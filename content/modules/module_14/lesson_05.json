{
  "lesson_id": "14_05",
  "title": "Deployment and Final Capstone Project",
  "module_id": 14,
  "order_index": 5,
  "description": "Learn deployment strategies, environment management, and build a comprehensive capstone project that demonstrates all skills learned throughout the course.",
  "estimated_minutes": 45,
  "content_blocks": [
    {
      "type": "the_simplifier",
      "title": "The Concept: Shipping Your Code",
      "content": "**Deployment = Making your app available to users**\n\n**Think of it like:**\n- Opening a restaurant (not just cooking at home)\n- Publishing a book (not just writing it)\n- Launching a rocket (not just building it)\n\n**Development vs Production:**\n\n**Development** üíª\n- On your computer\n- Debug mode enabled\n- Small test database\n- You're the only user\n- Frequent changes\n\n**Production** üöÄ\n- On a server\n- Debug mode OFF\n- Real database\n- Many users\n- Stable, tested code\n\n**Deployment platforms:**\n\n**1. Platform-as-a-Service (PaaS)** ‚òÅÔ∏è\n- Heroku\n- PythonAnywhere\n- Google App Engine\n- Railway\n\n**Pros:**\n- Easy to use\n- Auto-scaling\n- Managed services\n\n**Cons:**\n- More expensive\n- Less control\n\n**2. Infrastructure-as-a-Service (IaaS)** üè¢\n- AWS EC2\n- DigitalOcean\n- Linode\n\n**Pros:**\n- Full control\n- Cheaper at scale\n\n**Cons:**\n- More setup\n- You manage servers\n\n**3. Serverless** ‚ö°\n- AWS Lambda\n- Vercel\n- Netlify Functions\n\n**Pros:**\n- No servers to manage\n- Pay per use\n\n**Cons:**\n- Cold starts\n- Vendor lock-in\n\n**Deployment checklist:**\n\n```\n1. ‚úÖ Environment variables (.env)\n2. ‚úÖ Production database\n3. ‚úÖ Debug mode = False\n4. ‚úÖ Secret key changed\n5. ‚úÖ Dependencies listed (requirements.txt)\n6. ‚úÖ HTTPS enabled\n7. ‚úÖ Error logging\n8. ‚úÖ Backups configured\n9. ‚úÖ Tests passing\n10. ‚úÖ Performance tested\n```\n\n**CI/CD (Continuous Integration/Deployment):**\n- Automated testing\n- Automated deployment\n- Every push triggers tests\n- Passing tests auto-deploy\n\n**Example workflow:**\n```\nDeveloper ‚Üí Git Push ‚Üí Tests Run ‚Üí Deploy to Server\n```"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Preparing for Deployment",
      "code": "import os\nfrom pathlib import Path\n\nprint(\"=== Deployment Preparation ===\")\n\nprint(\"\\n1. Environment Configuration\")\n\nconfig_example = '''\n# config.py - Production-ready configuration\n\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nclass Config:\n    \"\"\"Base configuration\"\"\"\n    SECRET_KEY = os.getenv('SECRET_KEY', 'dev-key-change-in-production')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    \nclass DevelopmentConfig(Config):\n    \"\"\"Development environment configuration\"\"\"\n    DEBUG = True\n    DATABASE_URI = 'sqlite:///dev.db'\n    \nclass ProductionConfig(Config):\n    \"\"\"Production environment configuration\"\"\"\n    DEBUG = False\n    DATABASE_URI = os.getenv('DATABASE_URL')\n    \n    # Security settings\n    SESSION_COOKIE_SECURE = True  # HTTPS only\n    SESSION_COOKIE_HTTPONLY = True\n    PERMANENT_SESSION_LIFETIME = 3600  # 1 hour\n    \n    # Logging\n    LOG_LEVEL = 'ERROR'\n    \nclass TestConfig(Config):\n    \"\"\"Test environment configuration\"\"\"\n    TESTING = True\n    DATABASE_URI = 'sqlite:///:memory:'\n\n# Select config based on environment\nconfig = {\n    'development': DevelopmentConfig,\n    'production': ProductionConfig,\n    'test': TestConfig,\n    'default': DevelopmentConfig\n}\n\ndef get_config():\n    env = os.getenv('FLASK_ENV', 'development')\n    return config.get(env, config['default'])\n'''\n\nprint(config_example)\n\nprint(\"\\n2. Requirements Management\")\n\nrequirements_example = '''\n# requirements.txt - Production dependencies\nFlask==3.0.0\nSQLAlchemy==2.0.0\npython-dotenv==1.0.0\ngunicorn==21.2.0  # Production server\npsycopg2-binary==2.9.9  # PostgreSQL\n\n# requirements-dev.txt - Development dependencies\n-r requirements.txt  # Include production deps\npytest==7.4.0\nblack==23.0.0\nflake8==6.0.0\nmypy==1.5.0\n'''\n\nprint(requirements_example)\n\nprint(\"\\n3. Procfile (for Heroku/Railway)\")\n\nprocfile_example = '''\n# Procfile\nweb: gunicorn app:app\n\n# With workers and timeout\nweb: gunicorn app:app --workers 4 --timeout 30\n'''\n\nprint(procfile_example)\n\nprint(\"\\n4. Production-Ready App Structure\")\n\napp_example = '''\n# app.py - Production-ready Flask app\n\nimport os\nimport logging\nfrom flask import Flask, jsonify\nfrom config import get_config\n\n# Initialize Flask app\napp = Flask(__name__)\napp.config.from_object(get_config())\n\n# Configure logging\nif not app.debug:\n    logging.basicConfig(\n        level=logging.ERROR,\n        format='%(asctime)s %(levelname)s: %(message)s'\n    )\n    file_handler = logging.FileHandler('app.log')\n    file_handler.setLevel(logging.ERROR)\n    app.logger.addHandler(file_handler)\n\n# Error handlers\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({'error': 'Not found'}), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f'Server Error: {error}')\n    return jsonify({'error': 'Internal server error'}), 500\n\n# Health check endpoint\n@app.route('/health')\ndef health_check():\n    return jsonify({'status': 'healthy'}), 200\n\n# Main routes\n@app.route('/')\ndef index():\n    return jsonify({'message': 'Welcome to the API'})\n\nif __name__ == '__main__':\n    # For development only\n    port = int(os.getenv('PORT', 5000))\n    app.run(host='0.0.0.0', port=port)\n'''\n\nprint(app_example)\n\nprint(\"\\n5. Docker Deployment (Optional)\")\n\ndockerfile_example = '''\n# Dockerfile\nFROM python:3.11-slim\n\n# Set working directory\nWORKDIR /app\n\n# Copy requirements\nCOPY requirements.txt .\n\n# Install dependencies\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application\nCOPY . .\n\n# Expose port\nEXPOSE 5000\n\n# Run application\nCMD [\"gunicorn\", \"app:app\", \"--bind\", \"0.0.0.0:5000\"]\n'''\n\nprint(dockerfile_example)\n\nprint(\"\\n=== Deployment Workflows ===\")\n\nprint(\"\\n1. Deploying to Heroku:\")\nheroku_steps = '''\n# Install Heroku CLI\n# Visit: https://devcenter.heroku.com/articles/heroku-cli\n\n# Login\nheroku login\n\n# Create app\nheroku create my-app-name\n\n# Set environment variables\nheroku config:set SECRET_KEY=your-secret-key\nheroku config:set DATABASE_URL=postgres://...\nheroku config:set FLASK_ENV=production\n\n# Add PostgreSQL database (optional)\nheroku addons:create heroku-postgresql:mini\n\n# Deploy\ngit push heroku main\n\n# Run migrations (if using database)\nheroku run python migrate.py\n\n# Open app\nheroku open\n\n# View logs\nheroku logs --tail\n'''\n\nprint(heroku_steps)\n\nprint(\"\\n2. Deploying to PythonAnywhere:\")\npythonanywhere_steps = '''\n1. Sign up at pythonanywhere.com\n2. Open Bash console\n3. Clone your repository:\n   git clone https://github.com/username/repo.git\n   cd repo\n   \n4. Create virtual environment:\n   python -m venv venv\n   source venv/bin/activate\n   pip install -r requirements.txt\n   \n5. Configure web app in Web tab:\n   - Source code: /home/username/repo\n   - Working directory: /home/username/repo\n   - Virtualenv: /home/username/repo/venv\n   - WSGI file: Edit to point to your app\n   \n6. Set environment variables in Web tab\n\n7. Reload web app\n'''\n\nprint(pythonanywhere_steps)\n\nprint(\"\\n3. Using GitHub Actions (CI/CD):\")\ngithub_actions = '''\n# .github/workflows/deploy.yml\n\nname: Deploy to Production\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.11\n    \n    - name: Install dependencies\n      run: |\n        pip install -r requirements.txt\n        pip install -r requirements-dev.txt\n    \n    - name: Run tests\n      run: pytest\n    \n    - name: Check code style\n      run: flake8 .\n    \n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Deploy to Heroku\n      uses: akhileshns/heroku-deploy@v3.12.12\n      with:\n        heroku_api_key: ${{secrets.HEROKU_API_KEY}}\n        heroku_app_name: \"my-app-name\"\n        heroku_email: \"your-email@example.com\"\n'''\n\nprint(github_actions)",
      "explanation": "**Production deployment steps:**\n\n**1. Configuration:**\n- Separate dev/prod configs\n- Environment variables for secrets\n- Debug mode OFF in production\n\n**2. Dependencies:**\n- requirements.txt for production\n- requirements-dev.txt for development\n- Pin versions (Flask==3.0.0)\n\n**3. Server:**\n- Use gunicorn (not Flask dev server)\n- Multiple workers for concurrency\n- Proper error handling\n\n**4. Monitoring:**\n- Logging to files\n- Error tracking (Sentry)\n- Health check endpoints\n\n**5. Security:**\n- HTTPS only\n- Secure cookies\n- Input validation\n- Regular updates",
      "output": "=== Deployment Preparation ===\n\n[Configuration examples displayed]\n\n=== Deployment Workflows ===\n\n[Platform-specific deployment steps shown]"
    },
    {
      "type": "the_simplifier",
      "title": "Final Capstone Project",
      "content": "**Capstone = Bring it all together**\n\n**Project: Task Management API with Authentication**\n\n**Features to implement:**\n\n**1. User Management** üë§\n- Registration (POST /api/auth/register)\n- Login (POST /api/auth/login)\n- Logout (POST /api/auth/logout)\n- Password hashing with bcrypt\n- JWT tokens for authentication\n\n**2. Task CRUD** ‚úÖ\n- Create task (POST /api/tasks)\n- List tasks (GET /api/tasks)\n- Get task (GET /api/tasks/{id})\n- Update task (PUT /api/tasks/{id})\n- Delete task (DELETE /api/tasks/{id})\n- Filter by status, priority\n\n**3. Categories** üè∑Ô∏è\n- Create category (POST /api/categories)\n- Assign tasks to categories\n- List tasks by category\n\n**4. Security** üîí\n- Authentication required for all endpoints\n- Users can only access their own tasks\n- Input validation\n- Rate limiting\n\n**5. Testing** üß™\n- Unit tests for all functions\n- Integration tests for API endpoints\n- 80%+ code coverage\n\n**6. Documentation** üìö\n- README with setup instructions\n- API documentation\n- Docstrings for all functions\n- Environment setup guide\n\n**7. Deployment** üöÄ\n- Deploy to Heroku or PythonAnywhere\n- Production database (PostgreSQL)\n- Environment variables configured\n- HTTPS enabled\n\n**Tech stack:**\n- Flask (web framework)\n- SQLAlchemy (database ORM)\n- PostgreSQL/SQLite (database)\n- JWT (authentication)\n- pytest (testing)\n- Heroku (deployment)\n\n**Evaluation criteria:**\n- ‚úÖ All features working\n- ‚úÖ Tests passing\n- ‚úÖ Code quality (PEP 8, docstrings)\n- ‚úÖ Git history (clear commits)\n- ‚úÖ Documentation complete\n- ‚úÖ Successfully deployed\n- ‚úÖ Security best practices"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Capstone Project Starter",
      "solution_code": "print(\"=== Capstone Project: Task Management API ===\")\nprint(\"\\nProject structure:\")\n\nproject_structure = '''\ntask-manager-api/\n‚îú‚îÄ‚îÄ app.py                  # Main application\n‚îú‚îÄ‚îÄ config.py               # Configuration\n‚îú‚îÄ‚îÄ requirements.txt        # Dependencies\n‚îú‚îÄ‚îÄ Procfile               # Deployment config\n‚îú‚îÄ‚îÄ .env.example           # Environment template\n‚îú‚îÄ‚îÄ .gitignore            # Git ignore rules\n‚îú‚îÄ‚îÄ README.md             # Documentation\n‚îÇ\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py        # User model\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task.py        # Task model\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ routes/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py        # Auth endpoints\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tasks.py       # Task endpoints\n‚îÇ   ‚îÇ\n‚îÇ   ‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_service.py\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_service.py\n‚îÇ   ‚îÇ\n‚îÇ   ‚îî‚îÄ‚îÄ utils/\n‚îÇ       ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ       ‚îú‚îÄ‚îÄ jwt_helper.py\n‚îÇ       ‚îî‚îÄ‚îÄ validators.py\n‚îÇ\n‚îî‚îÄ‚îÄ tests/\n    ‚îú‚îÄ‚îÄ __init__.py\n    ‚îú‚îÄ‚îÄ conftest.py        # Shared fixtures\n    ‚îú‚îÄ‚îÄ test_auth.py\n    ‚îî‚îÄ‚îÄ test_tasks.py\n'''\n\nprint(project_structure)\n\nprint(\"\\n=== Implementation Examples ===\")\n\nprint(\"\\n1. User Model (src/models/user.py):\")\nuser_model = '''\nfrom sqlalchemy import Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom datetime import datetime\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\nBase = declarative_base()\n\nclass User(Base):\n    \"\"\"User model for authentication\"\"\"\n    __tablename__ = 'users'\n    \n    id = Column(Integer, primary_key=True)\n    username = Column(String(80), unique=True, nullable=False)\n    email = Column(String(120), unique=True, nullable=False)\n    password_hash = Column(String(200), nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    def set_password(self, password):\n        \"\"\"Hash and set password\"\"\"\n        self.password_hash = generate_password_hash(password)\n    \n    def check_password(self, password):\n        \"\"\"Verify password\"\"\"\n        return check_password_hash(self.password_hash, password)\n    \n    def to_dict(self):\n        \"\"\"Convert to dictionary\"\"\"\n        return {\n            'id': self.id,\n            'username': self.username,\n            'email': self.email,\n            'created_at': self.created_at.isoformat()\n        }\n'''\n\nprint(user_model)\n\nprint(\"\\n2. Task Model (src/models/task.py):\")\ntask_model = '''\nfrom sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom datetime import datetime\nfrom .user import Base\n\nclass Task(Base):\n    \"\"\"Task model\"\"\"\n    __tablename__ = 'tasks'\n    \n    id = Column(Integer, primary_key=True)\n    title = Column(String(200), nullable=False)\n    description = Column(String(500))\n    completed = Column(Boolean, default=False)\n    priority = Column(String(20), default='medium')  # low, medium, high\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Relationship\n    user = relationship('User', backref='tasks')\n    \n    def to_dict(self):\n        \"\"\"Convert to dictionary\"\"\"\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'priority': self.priority,\n            'user_id': self.user_id,\n            'created_at': self.created_at.isoformat(),\n            'updated_at': self.updated_at.isoformat()\n        }\n'''\n\nprint(task_model)\n\nprint(\"\\n3. Authentication Routes (src/routes/auth.py):\")\nauth_routes = '''\nfrom flask import Blueprint, request, jsonify\nfrom src.services.auth_service import AuthService\nfrom src.utils.validators import validate_email, validate_password\n\nauth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')\nauth_service = AuthService()\n\n@auth_bp.route('/register', methods=['POST'])\ndef register():\n    \"\"\"Register new user\"\"\"\n    data = request.get_json()\n    \n    # Validation\n    if not data or not data.get('username') or not data.get('email') or not data.get('password'):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    if not validate_email(data['email']):\n        return jsonify({'error': 'Invalid email format'}), 400\n    \n    if not validate_password(data['password']):\n        return jsonify({'error': 'Password must be at least 8 characters'}), 400\n    \n    # Create user\n    result = auth_service.register_user(\n        username=data['username'],\n        email=data['email'],\n        password=data['password']\n    )\n    \n    if 'error' in result:\n        return jsonify(result), 400\n    \n    return jsonify(result), 201\n\n@auth_bp.route('/login', methods=['POST'])\ndef login():\n    \"\"\"Login user\"\"\"\n    data = request.get_json()\n    \n    if not data or not data.get('email') or not data.get('password'):\n        return jsonify({'error': 'Missing email or password'}), 400\n    \n    result = auth_service.login_user(\n        email=data['email'],\n        password=data['password']\n    )\n    \n    if 'error' in result:\n        return jsonify(result), 401\n    \n    return jsonify(result), 200\n'''\n\nprint(auth_routes)\n\nprint(\"\\n4. Testing Example (tests/test_auth.py):\")\ntest_example = '''\nimport pytest\nfrom app import create_app\nfrom src.models.user import User, Base\n\n@pytest.fixture\ndef app():\n    \"\"\"Create test app\"\"\"\n    app = create_app('test')\n    with app.app_context():\n        Base.metadata.create_all()\n        yield app\n        Base.metadata.drop_all()\n\n@pytest.fixture\ndef client(app):\n    \"\"\"Create test client\"\"\"\n    return app.test_client()\n\ndef test_register_success(client):\n    \"\"\"Test successful user registration\"\"\"\n    response = client.post('/api/auth/register', json={\n        'username': 'testuser',\n        'email': 'test@example.com',\n        'password': 'SecurePass123!'\n    })\n    \n    assert response.status_code == 201\n    data = response.get_json()\n    assert 'token' in data\n    assert 'user' in data\n\ndef test_register_invalid_email(client):\n    \"\"\"Test registration with invalid email\"\"\"\n    response = client.post('/api/auth/register', json={\n        'username': 'testuser',\n        'email': 'invalid-email',\n        'password': 'SecurePass123!'\n    })\n    \n    assert response.status_code == 400\n    data = response.get_json()\n    assert 'error' in data\n\ndef test_login_success(client):\n    \"\"\"Test successful login\"\"\"\n    # First register\n    client.post('/api/auth/register', json={\n        'username': 'testuser',\n        'email': 'test@example.com',\n        'password': 'SecurePass123!'\n    })\n    \n    # Then login\n    response = client.post('/api/auth/login', json={\n        'email': 'test@example.com',\n        'password': 'SecurePass123!'\n    })\n    \n    assert response.status_code == 200\n    data = response.get_json()\n    assert 'token' in data\n'''\n\nprint(test_example)\n\nprint(\"\\n=== Project Milestones ===\")\n\nmilestones = [\n    \"1. ‚úÖ Set up project structure and Git repository\",\n    \"2. ‚úÖ Implement User model with password hashing\",\n    \"3. ‚úÖ Implement Task model with relationships\",\n    \"4. ‚úÖ Create authentication endpoints (register/login)\",\n    \"5. ‚úÖ Implement JWT token generation and validation\",\n    \"6. ‚úÖ Create task CRUD endpoints\",\n    \"7. ‚úÖ Add authorization (users access own tasks only)\",\n    \"8. ‚úÖ Write unit tests for models and services\",\n    \"9. ‚úÖ Write integration tests for API endpoints\",\n    \"10. ‚úÖ Add input validation and error handling\",\n    \"11. ‚úÖ Write comprehensive documentation\",\n    \"12. ‚úÖ Deploy to production platform\",\n    \"13. ‚úÖ Test deployed application\",\n    \"14. ‚úÖ Create demo video or presentation\"\n]\n\nfor milestone in milestones:\n    print(milestone)\n\nprint(\"\\n=== Success Criteria ===\")\n\nsuccess_criteria = {\n    \"Functionality\": [\n        \"All API endpoints working correctly\",\n        \"Authentication and authorization implemented\",\n        \"CRUD operations for tasks\",\n        \"Input validation on all endpoints\"\n    ],\n    \"Code Quality\": [\n        \"PEP 8 compliant (checked with flake8)\",\n        \"Type hints where appropriate\",\n        \"Comprehensive docstrings\",\n        \"No security vulnerabilities\"\n    ],\n    \"Testing\": [\n        \"80%+ code coverage\",\n        \"All tests passing\",\n        \"Both unit and integration tests\",\n        \"Edge cases covered\"\n    ],\n    \"Documentation\": [\n        \"Clear README with setup instructions\",\n        \"API endpoint documentation\",\n        \"Environment variables documented\",\n        \"Troubleshooting guide\"\n    ],\n    \"Deployment\": [\n        \"Successfully deployed to production\",\n        \"HTTPS enabled\",\n        \"Environment variables configured\",\n        \"Database migrations working\"\n    ]\n}\n\nfor category, criteria in success_criteria.items():\n    print(f\"\\n{category}:\")\n    for criterion in criteria:\n        print(f\"  - {criterion}\")\n\nprint(\"\\n\" + \"=\"*50)\nprint(\"üéì CONGRATULATIONS!\")\nprint(\"=\"*50)\nprint(\"\\nYou've completed the Python Training Course!\")\nprint(\"From absolute beginner to full-stack developer.\")\nprint(\"\\nYou now have the skills to:\")\nprint(\"  ‚úì Build web applications with Flask\")\nprint(\"  ‚úì Work with databases using SQLAlchemy\")\nprint(\"  ‚úì Implement authentication and security\")\nprint(\"  ‚úì Write professional tests\")\nprint(\"  ‚úì Use Git for version control\")\nprint(\"  ‚úì Deploy applications to production\")\nprint(\"  ‚úì Write clean, documented code\")\nprint(\"\\nNext steps:\")\nprint(\"  1. Build your own projects\")\nprint(\"  2. Contribute to open source\")\nprint(\"  3. Keep learning and growing\")\nprint(\"  4. Share your knowledge with others\")\nprint(\"\\nüöÄ Keep coding and building amazing things!\")",
      "explanation": "**Capstone project requirements:**\n\n**Complete full-stack application:**\n- Backend API with Flask\n- Database with SQLAlchemy\n- Authentication with JWT\n- RESTful endpoints\n- Input validation\n- Error handling\n\n**Professional practices:**\n- Git version control\n- Comprehensive tests\n- Clear documentation\n- Code quality tools\n- Production deployment\n\n**Skills demonstrated:**\n1. Project planning and architecture\n2. Database modeling and relationships\n3. API design and implementation\n4. Security and authentication\n5. Testing strategies\n6. Documentation\n7. Deployment and DevOps\n\n**Portfolio piece:**\n- Shows technical skills\n- Demonstrates best practices\n- Ready to show employers\n- Fully functional application",
      "output": "=== Capstone Project: Task Management API ===\n\n[Project structure and implementation examples displayed]\n\n=== Project Milestones ===\n[14 milestones listed]\n\n=== Success Criteria ===\n[Comprehensive criteria by category]\n\n==================================================\nüéì CONGRATULATIONS!\n==================================================\n\nYou've completed the Python Training Course!\nFrom absolute beginner to full-stack developer.\n\nYou now have the skills to:\n  ‚úì Build web applications with Flask\n  ‚úì Work with databases using SQLAlchemy\n  ‚úì Implement authentication and security\n  ‚úì Write professional tests\n  ‚úì Use Git for version control\n  ‚úì Deploy applications to production\n  ‚úì Write clean, documented code\n\nNext steps:\n  1. Build your own projects\n  2. Contribute to open source\n  3. Keep learning and growing\n  4. Share your knowledge with others\n\nüöÄ Keep coding and building amazing things!",
      "common_mistakes": [
        "Deploying with DEBUG=True - always disable in production",
        "Hardcoding secrets in code - use environment variables",
        "Not testing before deployment - always run tests first",
        "Skipping documentation - README is essential",
        "No error logging - you can't fix what you can't see"
      ]
    },
    {
      "type": "key_takeaways",
      "title": "Key Takeaways",
      "takeaways": [
        "**Deployment = shipping code to users** - Production is different from development",
        "**Environment variables for secrets** - Never commit passwords or API keys",
        "**Use production servers** - gunicorn, not Flask dev server",
        "**CI/CD automates deployment** - Tests run automatically, deploy if passing",
        "**Monitor your application** - Logging and error tracking are essential",
        "**Security matters** - HTTPS, secure cookies, input validation",
        "**Capstone demonstrates skills** - Full-stack project shows what you've learned",
        "**Keep learning** - Technology evolves, stay curious and keep building"
      ]
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "What should you NEVER do when deploying to production?",
        "options": [
          "Use environment variables",
          "Enable DEBUG mode",
          "Use HTTPS",
          "Configure logging"
        ],
        "correct_answer": 1,
        "explanation": "DEBUG mode should NEVER be enabled in production as it exposes sensitive information and allows code execution via the browser."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "What is the purpose of a Procfile?",
        "options": [
          "To process user input",
          "To tell deployment platforms how to run your app",
          "To process database queries",
          "To configure Python packages"
        ],
        "correct_answer": 1,
        "explanation": "A Procfile tells platforms like Heroku what command to run to start your application (e.g., 'web: gunicorn app:app')."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "Why use gunicorn instead of Flask's development server in production?",
        "options": [
          "Gunicorn is faster and designed for production workloads",
          "Gunicorn is required by Python",
          "Flask's server doesn't work in production",
          "Gunicorn is easier to configure"
        ],
        "correct_answer": 0,
        "explanation": "Gunicorn is a production-grade WSGI server that handles multiple concurrent requests efficiently. Flask's dev server is single-threaded and not designed for production."
      }
    ]
  }
}
