{
  "lesson_id": "14_03",
  "title": "Testing Best Practices",
  "module_id": 14,
  "order_index": 3,
  "description": "Learn professional testing strategies including unit tests, integration tests, test-driven development (TDD), and using pytest for comprehensive test coverage.",
  "estimated_minutes": 35,
  "content_blocks": [
    {
      "type": "the_simplifier",
      "title": "The Concept: Testing is Insurance",
      "content": "**Tests = Proof your code works**\n\n**Think of testing like:**\n- Car safety tests before sale\n- Taste-testing food before serving\n- Checking parachute before jumping\n\n**Why test:**\n\n1. **Catch bugs early** ðŸ›\n   - Before users find them\n   - Cheaper to fix\n   - Build confidence\n\n2. **Prevent regressions** â†©ï¸\n   - New code doesn't break old features\n   - Safe to refactor\n   - Automated checks\n\n3. **Document behavior** ðŸ“–\n   - Tests show how code should work\n   - Examples of usage\n   - Living documentation\n\n4. **Design improvement** ðŸŽ¨\n   - Hard to test = bad design\n   - Forces modular code\n   - Clear interfaces\n\n**Types of tests:**\n\n**1. Unit Tests** ðŸ”¬\n- Test single function/class\n- Fast (milliseconds)\n- Isolated (no database, network)\n- Most common\n\n**2. Integration Tests** ðŸ”—\n- Test components together\n- Database, API calls\n- Slower\n- Realistic scenarios\n\n**3. End-to-End (E2E) Tests** ðŸŽ¬\n- Test entire application\n- User perspective\n- Slowest\n- Most realistic\n\n**Test pyramid:**\n```\n      /\\  \n     /E2E\\      â† Few (expensive, slow)\n    /â”€â”€â”€â”€â”€\\\n   /Integr\\     â† Some (moderate speed)\n  /â”€â”€â”€â”€â”€â”€â”€â”€\\\n /Unit Tests\\   â† Many (cheap, fast)\n/â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\\n```\n\n**Write tests that:**\nâœ“ Are fast\nâœ“ Are independent\nâœ“ Are repeatable\nâœ“ Validate one thing\nâœ“ Have clear names"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Unit Testing with pytest",
      "code": "# Example functions to test\n\ndef add(a, b):\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\ndef divide(a, b):\n    \"\"\"Divide two numbers\"\"\"\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\ndef is_palindrome(text):\n    \"\"\"Check if text is a palindrome\"\"\"\n    cleaned = ''.join(c.lower() for c in text if c.isalnum())\n    return cleaned == cleaned[::-1]\n\nclass Calculator:\n    \"\"\"Simple calculator class\"\"\"\n    \n    def __init__(self):\n        self.history = []\n    \n    def add(self, a, b):\n        result = a + b\n        self.history.append(f\"{a} + {b} = {result}\")\n        return result\n    \n    def get_history(self):\n        return self.history.copy()\n\nprint(\"=== Writing Tests with pytest ===\")\n\n# Test file: test_calculator.py\ntest_code = '''\nimport pytest\nfrom calculator import add, divide, is_palindrome, Calculator\n\n# Basic unit tests\ndef test_add_positive_numbers():\n    \"\"\"Test adding positive numbers\"\"\"\n    assert add(2, 3) == 5\n    assert add(10, 20) == 30\n\ndef test_add_negative_numbers():\n    \"\"\"Test adding negative numbers\"\"\"\n    assert add(-1, -1) == -2\n    assert add(-5, 5) == 0\n\ndef test_divide_normal():\n    \"\"\"Test normal division\"\"\"\n    assert divide(10, 2) == 5\n    assert divide(9, 3) == 3\n\ndef test_divide_by_zero():\n    \"\"\"Test division by zero raises error\"\"\"\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide(10, 0)\n\ndef test_is_palindrome_simple():\n    \"\"\"Test simple palindromes\"\"\"\n    assert is_palindrome(\"racecar\") == True\n    assert is_palindrome(\"hello\") == False\n\ndef test_is_palindrome_case_insensitive():\n    \"\"\"Test case insensitivity\"\"\"\n    assert is_palindrome(\"RaceCar\") == True\n    assert is_palindrome(\"A man a plan a canal Panama\") == True\n\n# Test with fixtures\n@pytest.fixture\ndef calculator():\n    \"\"\"Fixture providing a fresh Calculator instance\"\"\"\n    return Calculator()\n\ndef test_calculator_add(calculator):\n    \"\"\"Test calculator add method\"\"\"\n    result = calculator.add(5, 3)\n    assert result == 8\n\ndef test_calculator_history(calculator):\n    \"\"\"Test calculator maintains history\"\"\"\n    calculator.add(5, 3)\n    calculator.add(10, 2)\n    history = calculator.get_history()\n    assert len(history) == 2\n    assert \"5 + 3 = 8\" in history\n\n# Parametrized tests (test multiple inputs)\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (2, 3, 5),\n    (10, 20, 30),\n    (-1, 1, 0),\n    (0, 0, 0),\n    (100, 200, 300)\n])\ndef test_add_parametrized(a, b, expected):\n    \"\"\"Test add with multiple parameter sets\"\"\"\n    assert add(a, b) == expected\n\n# Test error messages\ndef test_divide_error_message():\n    \"\"\"Test error message is helpful\"\"\"\n    try:\n        divide(10, 0)\n        assert False, \"Should have raised ValueError\"\n    except ValueError as e:\n        assert \"Cannot divide by zero\" in str(e)\n'''\n\nprint(\"Test file example:\")\nprint(test_code)\n\nprint(\"\\n=== Running Tests ===\")\nprint(\"\"\"\nCommand: pytest test_calculator.py\n\nOutput:\n========================= test session starts =========================\ncollected 10 items\n\ntest_calculator.py ..........                                   [100%]\n\n========================= 10 passed in 0.03s =========================\n\nOptions:\n  pytest -v                    # Verbose output\n  pytest -k \"palindrome\"       # Run tests matching name\n  pytest --cov                 # Show code coverage\n  pytest -x                    # Stop on first failure\n  pytest --pdb                 # Drop into debugger on failure\n\"\"\")\n\nprint(\"\\n=== Test Organization ===\")\n\nproject_structure = \"\"\"\nmy_project/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”œâ”€â”€ calculator.py\nâ”‚   â”œâ”€â”€ models.py\nâ”‚   â””â”€â”€ services.py\nâ”‚\nâ”œâ”€â”€ tests/\nâ”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”œâ”€â”€ conftest.py          # Shared fixtures\nâ”‚   â”œâ”€â”€ test_calculator.py   # Test calculator module\nâ”‚   â”œâ”€â”€ test_models.py       # Test models\nâ”‚   â””â”€â”€ test_services.py     # Test services\nâ”‚\nâ”œâ”€â”€ pytest.ini               # pytest configuration\nâ””â”€â”€ requirements-test.txt    # Test dependencies\n\"\"\"\n\nprint(project_structure)",
      "explanation": "**pytest features:**\n\n**1. Simple assertions:**\n```python\nassert result == expected\nassert value > 0\nassert item in list\n```\n\n**2. Testing exceptions:**\n```python\nwith pytest.raises(ValueError):\n    function_that_fails()\n```\n\n**3. Fixtures (setup/teardown):**\n```python\n@pytest.fixture\ndef database():\n    db = create_db()\n    yield db  # Test runs here\n    db.close()\n```\n\n**4. Parametrized tests:**\n```python\n@pytest.mark.parametrize(\"input,expected\", [\n    (1, 2),\n    (2, 4),\n])\ndef test_double(input, expected):\n    assert double(input) == expected\n```\n\n**Test naming:**\n- Prefix with `test_`\n- Descriptive names\n- One test = one concept",
      "output": "=== Writing Tests with pytest ===\n[Test code example displayed]\n\n=== Running Tests ===\nCommand: pytest test_calculator.py\n\nOutput:\n========================= test session starts =========================\ncollected 10 items\n\ntest_calculator.py ..........                                   [100%]\n\n========================= 10 passed in 0.03s =========================\n\n=== Test Organization ===\n[Project structure with tests displayed]"
    },
    {
      "type": "the_simplifier",
      "title": "Test-Driven Development (TDD)",
      "content": "**TDD = Write tests before code**\n\n**The cycle:**\n\n```\n1. ðŸ”´ Red: Write failing test\n   â†“\n2. ðŸŸ¢ Green: Write minimal code to pass\n   â†“\n3. ðŸ”µ Refactor: Improve code quality\n   â†“\n   Repeat\n```\n\n**Example workflow:**\n\n**Step 1: Red (failing test)**\n```python\ndef test_validate_email():\n    assert validate_email(\"user@example.com\") == True\n    assert validate_email(\"invalid\") == False\n# Test fails - function doesn't exist\n```\n\n**Step 2: Green (make it pass)**\n```python\ndef validate_email(email):\n    return '@' in email\n# Test passes (barely)\n```\n\n**Step 3: Refactor (improve)**\n```python\nimport re\n\ndef validate_email(email):\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    return bool(re.match(pattern, email))\n# Better implementation, tests still pass\n```\n\n**TDD benefits:**\n- Forces you to think about requirements\n- Every line of code is tested\n- No over-engineering\n- Confidence to refactor\n- Design emerges naturally"
    },
    {
      "type": "the_coder",
      "title": "Code Example: TDD in Practice",
      "solution_code": "print(\"=== TDD Example: Building a Todo List ===\")\n\nprint(\"\\nStep 1: Write failing test\")\nprint(\"\"\"\n# test_todo.py\ndef test_create_todo():\n    todo = Todo(\"Buy milk\")\n    assert todo.title == \"Buy milk\"\n    assert todo.completed == False\n\n# Run: pytest â†’ FAIL (Todo doesn't exist)\n\"\"\")\n\nprint(\"\\nStep 2: Minimal code to pass\")\nprint(\"\"\"\n# todo.py\nclass Todo:\n    def __init__(self, title):\n        self.title = title\n        self.completed = False\n\n# Run: pytest â†’ PASS âœ“\n\"\"\")\n\nprint(\"\\nStep 3: Add more tests\")\nprint(\"\"\"\ndef test_mark_completed():\n    todo = Todo(\"Buy milk\")\n    todo.mark_completed()\n    assert todo.completed == True\n\n# Run: pytest â†’ FAIL (mark_completed doesn't exist)\n\"\"\")\n\nprint(\"\\nStep 4: Implement feature\")\nprint(\"\"\"\nclass Todo:\n    def __init__(self, title):\n        self.title = title\n        self.completed = False\n    \n    def mark_completed(self):\n        self.completed = True\n\n# Run: pytest â†’ PASS âœ“\n\"\"\")\n\nprint(\"\\nStep 5: Add validation\")\nprint(\"\"\"\ndef test_empty_title_raises_error():\n    with pytest.raises(ValueError):\n        Todo(\"\")\n\n# Run: pytest â†’ FAIL (no validation yet)\n\"\"\")\n\nprint(\"\\nStep 6: Implement validation\")\nprint(\"\"\"\nclass Todo:\n    def __init__(self, title):\n        if not title or not title.strip():\n            raise ValueError(\"Title cannot be empty\")\n        self.title = title.strip()\n        self.completed = False\n    \n    def mark_completed(self):\n        self.completed = True\n\n# Run: pytest â†’ PASS âœ“\n\"\"\")\n\nprint(\"\\n=== Full TDD Example ===\")\n\n# Complete implementation with all tests\nclass Todo:\n    \"\"\"Todo item with TDD implementation\"\"\"\n    \n    def __init__(self, title: str):\n        if not title or not title.strip():\n            raise ValueError(\"Title cannot be empty\")\n        self.title = title.strip()\n        self.completed = False\n    \n    def mark_completed(self):\n        \"\"\"Mark todo as completed\"\"\"\n        if self.completed:\n            raise ValueError(\"Todo already completed\")\n        self.completed = True\n    \n    def mark_incomplete(self):\n        \"\"\"Mark todo as incomplete\"\"\"\n        self.completed = False\n    \n    def __repr__(self):\n        status = \"âœ“\" if self.completed else \"â—‹\"\n        return f\"{status} {self.title}\"\n\nclass TodoList:\n    \"\"\"Collection of todos\"\"\"\n    \n    def __init__(self):\n        self.todos = []\n    \n    def add(self, todo: Todo):\n        \"\"\"Add todo to list\"\"\"\n        self.todos.append(todo)\n    \n    def get_all(self):\n        \"\"\"Get all todos\"\"\"\n        return self.todos.copy()\n    \n    def get_completed(self):\n        \"\"\"Get completed todos\"\"\"\n        return [t for t in self.todos if t.completed]\n    \n    def get_pending(self):\n        \"\"\"Get pending todos\"\"\"\n        return [t for t in self.todos if not t.completed]\n    \n    def remove_completed(self):\n        \"\"\"Remove all completed todos\"\"\"\n        self.todos = [t for t in self.todos if not t.completed]\n\nprint(\"Testing the implementation:\")\n\n# Create todos\ntodo1 = Todo(\"Learn Python\")\ntodo2 = Todo(\"Build a project\")\ntodo3 = Todo(\"Write tests\")\n\nprint(f\"\\n{todo1}\")\nprint(f\"{todo2}\")\nprint(f\"{todo3}\")\n\n# Mark some complete\ntodo1.mark_completed()\ntodo3.mark_completed()\n\nprint(\"\\nAfter completing some:\")\nprint(f\"{todo1}\")\nprint(f\"{todo2}\")\nprint(f\"{todo3}\")\n\n# Use TodoList\ntodo_list = TodoList()\ntodo_list.add(todo1)\ntodo_list.add(todo2)\ntodo_list.add(todo3)\n\nprint(f\"\\nTotal todos: {len(todo_list.get_all())}\")\nprint(f\"Completed: {len(todo_list.get_completed())}\")\nprint(f\"Pending: {len(todo_list.get_pending())}\")\n\nprint(\"\\nPending todos:\")\nfor todo in todo_list.get_pending():\n    print(f\"  {todo}\")",
      "explanation": "**TDD workflow demonstrated:**\n\n**Benefits of this approach:**\n1. **Clear requirements** - Tests define behavior\n2. **Minimal code** - Only write what's needed\n3. **Refactor safely** - Tests catch breaks\n4. **Documentation** - Tests show usage\n\n**Key principles:**\n- Write test first\n- Make it pass with minimal code\n- Refactor while keeping tests green\n- Repeat for each feature\n\n**When to use TDD:**\nâœ“ Complex logic\nâœ“ Critical functionality\nâœ“ Learning new concepts\nâœ“ Fixing bugs (write test that fails, then fix)\n\n**When to skip:**\nâœ— Prototyping\nâœ— UI layout\nâœ— Simple getters/setters",
      "output": "=== TDD Example: Building a Todo List ===\n\n[Shows progressive development with tests]\n\nTesting the implementation:\n\nâ—‹ Learn Python\nâ—‹ Build a project\nâ—‹ Write tests\n\nAfter completing some:\nâœ“ Learn Python\nâ—‹ Build a project\nâœ“ Write tests\n\nTotal todos: 3\nCompleted: 2\nPending: 1\n\nPending todos:\n  â—‹ Build a project"
    },
    {
      "type": "the_coder",
      "title": "Interactive Exercise",
      "instruction": "Practice TDD by creating a Password Validator:\n1. Write tests for password requirements:\n   - Min 8 characters\n   - At least one uppercase letter\n   - At least one number\n   - At least one special character\n2. Implement the validator to pass all tests\n3. Use pytest parametrize for multiple test cases",
      "starter_code": "import pytest\nimport re\n\n# TODO: Write tests first!\ndef test_password_length():\n    # TODO: Test minimum length\n    pass\n\ndef test_password_uppercase():\n    # TODO: Test uppercase requirement\n    pass\n\n# TODO: Implement after tests\nclass PasswordValidator:\n    def __init__(self, min_length=8):\n        pass\n    \n    def validate(self, password):\n        # TODO: Return True if valid, False otherwise\n        pass\n    \n    def get_errors(self, password):\n        # TODO: Return list of error messages\n        pass",
      "hint": "Start with simple tests. Use regex for character checks. Return helpful error messages."
    },
    {
      "type": "the_coder",
      "title": "Solution",
      "solution_code": "import pytest\nimport re\nfrom typing import List\n\nprint(\"=== TDD Solution: Password Validator ===\")\n\nclass PasswordValidator:\n    \"\"\"Validates passwords against security requirements\"\"\"\n    \n    def __init__(self, min_length: int = 8):\n        self.min_length = min_length\n    \n    def validate(self, password: str) -> bool:\n        \"\"\"Returns True if password meets all requirements\"\"\"\n        return len(self.get_errors(password)) == 0\n    \n    def get_errors(self, password: str) -> List[str]:\n        \"\"\"Returns list of validation errors\"\"\"\n        errors = []\n        \n        # Check length\n        if len(password) < self.min_length:\n            errors.append(f\"Password must be at least {self.min_length} characters\")\n        \n        # Check uppercase\n        if not re.search(r'[A-Z]', password):\n            errors.append(\"Password must contain at least one uppercase letter\")\n        \n        # Check lowercase\n        if not re.search(r'[a-z]', password):\n            errors.append(\"Password must contain at least one lowercase letter\")\n        \n        # Check digit\n        if not re.search(r'\\d', password):\n            errors.append(\"Password must contain at least one number\")\n        \n        # Check special character\n        if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n            errors.append(\"Password must contain at least one special character\")\n        \n        return errors\n\nprint(\"\\n=== Test Suite ===\")\n\n# Test suite that drove the implementation\ntest_suite = '''\nimport pytest\nfrom password_validator import PasswordValidator\n\n@pytest.fixture\ndef validator():\n    return PasswordValidator()\n\ndef test_valid_password(validator):\n    \"\"\"Test a valid password passes all checks\"\"\"\n    assert validator.validate(\"SecureP@ss1\") == True\n    assert validator.get_errors(\"SecureP@ss1\") == []\n\ndef test_password_too_short(validator):\n    \"\"\"Test password length requirement\"\"\"\n    errors = validator.get_errors(\"Short1!\")\n    assert len(errors) > 0\n    assert any(\"at least 8 characters\" in e for e in errors)\n\ndef test_password_no_uppercase(validator):\n    \"\"\"Test uppercase letter requirement\"\"\"\n    errors = validator.get_errors(\"password123!\")\n    assert any(\"uppercase\" in e for e in errors)\n\ndef test_password_no_lowercase(validator):\n    \"\"\"Test lowercase letter requirement\"\"\"\n    errors = validator.get_errors(\"PASSWORD123!\")\n    assert any(\"lowercase\" in e for e in errors)\n\ndef test_password_no_number(validator):\n    \"\"\"Test number requirement\"\"\"\n    errors = validator.get_errors(\"Password!\")\n    assert any(\"number\" in e for e in errors)\n\ndef test_password_no_special(validator):\n    \"\"\"Test special character requirement\"\"\"\n    errors = validator.get_errors(\"Password123\")\n    assert any(\"special character\" in e for e in errors)\n\n@pytest.mark.parametrize(\"password,should_pass\", [\n    (\"SecureP@ss1\", True),\n    (\"MyP@ssw0rd\", True),\n    (\"Test123!\", True),\n    (\"short1!\", False),        # Too short\n    (\"password123!\", False),   # No uppercase\n    (\"PASSWORD123!\", False),   # No lowercase\n    (\"Password!\", False),      # No number\n    (\"Password123\", False),    # No special char\n    (\"p@ss\", False),          # Multiple issues\n])\ndef test_password_validation(validator, password, should_pass):\n    \"\"\"Parametrized tests for multiple passwords\"\"\"\n    assert validator.validate(password) == should_pass\n'''\n\nprint(test_suite)\n\nprint(\"\\n=== Testing the Implementation ===\")\n\nvalidator = PasswordValidator()\n\n# Test cases\ntest_passwords = [\n    (\"SecureP@ss1\", \"Valid password\"),\n    (\"short\", \"Too short\"),\n    (\"alllowercase123!\", \"No uppercase\"),\n    (\"ALLUPPERCASE123!\", \"No lowercase\"),\n    (\"NoNumbers!\", \"No numbers\"),\n    (\"NoSpecial123\", \"No special chars\"),\n    (\"MyP@ssw0rd\", \"Another valid one\"),\n]\n\nfor password, description in test_passwords:\n    is_valid = validator.validate(password)\n    status = \"âœ“ Valid\" if is_valid else \"âœ— Invalid\"\n    \n    print(f\"\\n{status}: '{password}' ({description})\")\n    \n    if not is_valid:\n        errors = validator.get_errors(password)\n        for error in errors:\n            print(f\"  - {error}\")\n\nprint(\"\\n=== Password Strength Indicator ===\")\n\nclass PasswordStrengthValidator(PasswordValidator):\n    \"\"\"Extended validator with strength rating\"\"\"\n    \n    def get_strength(self, password: str) -> str:\n        \"\"\"Return password strength: Weak, Medium, Strong\"\"\"\n        if not self.validate(password):\n            return \"Weak\"\n        \n        score = 0\n        \n        # Length bonus\n        if len(password) >= 12:\n            score += 1\n        if len(password) >= 16:\n            score += 1\n        \n        # Character variety\n        if re.search(r'[A-Z].*[A-Z]', password):  # Multiple uppercase\n            score += 1\n        if re.search(r'\\d.*\\d.*\\d', password):    # Multiple digits\n            score += 1\n        if re.search(r'[!@#$%^&*].*[!@#$%^&*]', password):  # Multiple special\n            score += 1\n        \n        # No common patterns\n        common_patterns = ['123', 'abc', 'password', 'qwerty']\n        if not any(p in password.lower() for p in common_patterns):\n            score += 1\n        \n        if score >= 4:\n            return \"Strong\"\n        elif score >= 2:\n            return \"Medium\"\n        else:\n            return \"Weak\"\n\nstrength_validator = PasswordStrengthValidator()\n\nstrength_tests = [\n    \"P@ss1\",                    # Weak (too short)\n    \"Password123!\",             # Medium (meets requirements)\n    \"MyS3cur3P@ssw0rd!\",       # Strong (long, varied)\n    \"Sup3r!S3cur3#P@ssw0rd$\", # Very strong\n]\n\nprint(\"\\nPassword strength ratings:\")\nfor pwd in strength_tests:\n    strength = strength_validator.get_strength(pwd)\n    is_valid = strength_validator.validate(pwd)\n    \n    if is_valid:\n        print(f\"  '{pwd}' â†’ {strength}\")\n    else:\n        print(f\"  '{pwd}' â†’ Invalid\")",
      "explanation": "**Complete TDD password validator:**\n\n**Test-first development:**\n1. Write failing tests for each requirement\n2. Implement minimum code to pass\n3. Refactor and improve\n4. Add more tests for edge cases\n\n**Key features:**\n- **Validation** - Check all requirements\n- **Error messages** - Helpful feedback\n- **Extensible** - Easy to add rules\n- **Testable** - Each rule tested independently\n\n**Testing strategy:**\n- Unit tests for each requirement\n- Parametrized tests for many inputs\n- Fixtures for reusable setup\n- Clear, descriptive test names\n\n**Real-world usage:**\n- User registration forms\n- Password reset flows\n- Security policy enforcement\n- API input validation",
      "output": "=== TDD Solution: Password Validator ===\n\n=== Test Suite ===\n[Complete test suite code displayed]\n\n=== Testing the Implementation ===\n\nâœ“ Valid: 'SecureP@ss1' (Valid password)\n\nâœ— Invalid: 'short' (Too short)\n  - Password must be at least 8 characters\n  - Password must contain at least one uppercase letter\n  - Password must contain at least one number\n  - Password must contain at least one special character\n\nâœ— Invalid: 'alllowercase123!' (No uppercase)\n  - Password must contain at least one uppercase letter\n\nâœ— Invalid: 'ALLUPPERCASE123!' (No lowercase)\n  - Password must contain at least one lowercase letter\n\nâœ— Invalid: 'NoNumbers!' (No numbers)\n  - Password must contain at least one number\n\nâœ— Invalid: 'NoSpecial123' (No special chars)\n  - Password must contain at least one special character\n\nâœ“ Valid: 'MyP@ssw0rd' (Another valid one)\n\n=== Password Strength Indicator ===\n\nPassword strength ratings:\n  'P@ss1' â†’ Invalid\n  'Password123!' â†’ Medium\n  'MyS3cur3P@ssw0rd!' â†’ Strong\n  'Sup3r!S3cur3#P@ssw0rd$' â†’ Strong",
      "common_mistakes": [
        "Writing code before tests in TDD - defeats the purpose",
        "Not testing edge cases - empty strings, special characters",
        "Tests that are too broad - test one thing per test",
        "Ignoring test failures - all tests must pass",
        "Not refactoring after tests pass - improve code quality"
      ]
    },
    {
      "type": "key_takeaways",
      "title": "Key Takeaways",
      "takeaways": [
        "**Tests are insurance** - Catch bugs before users do",
        "**Unit tests are fastest** - Test small pieces in isolation",
        "**pytest makes testing easy** - Simple syntax, powerful features",
        "**TDD = Red, Green, Refactor** - Write test, make it pass, improve",
        "**One test, one concept** - Keep tests focused and clear",
        "**Fixtures for setup** - Reusable test dependencies",
        "**Parametrize for multiple inputs** - Test many cases efficiently",
        "**Good tests = good design** - Hard to test = bad design"
      ]
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "What does TDD stand for and what is its main principle?",
        "options": [
          "Test-Driven Development - write code before tests",
          "Test-Driven Development - write tests before code",
          "Test-Driven Debugging - fix bugs with tests",
          "Technical Design Document - document before coding"
        ],
        "correct_answer": 1,
        "explanation": "TDD (Test-Driven Development) means writing tests BEFORE writing the implementation code. This ensures every feature has tests."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "In the test pyramid, which type of test should you have the MOST of?",
        "options": [
          "End-to-end tests",
          "Integration tests",
          "Unit tests",
          "Manual tests"
        ],
        "correct_answer": 2,
        "explanation": "Unit tests should be most numerous because they're fast, cheap, and test small isolated pieces. The pyramid shows: many unit tests, some integration tests, few E2E tests."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "What is a pytest fixture used for?",
        "options": [
          "To fix broken tests",
          "To provide reusable setup/teardown code for tests",
          "To mark tests as skipped",
          "To run tests in parallel"
        ],
        "correct_answer": 1,
        "explanation": "Fixtures provide reusable setup code (like creating test databases or objects) that multiple tests can use. They run before each test."
      }
    ]
  }
}
