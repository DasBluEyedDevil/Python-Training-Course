{
  "lesson_id": "14_04",
  "title": "Documentation and Code Quality",
  "module_id": 14,
  "order_index": 4,
  "description": "Learn to write clear documentation, maintain code quality with linters and formatters, and follow Python best practices (PEP 8, type hints, docstrings).",
  "estimated_minutes": 35,
  "content_blocks": [
    {
      "type": "the_simplifier",
      "title": "The Concept: Code is Read More Than Written",
      "content": "**Documentation = Instructions for humans**\n\n**Think of it like:**\n- Recipe for cooking\n- User manual for appliances\n- Assembly instructions for furniture\n\n**Why documentation matters:**\n\n1. **Future you** ðŸ”®\n   - You'll forget why you wrote code\n   - 6 months = forever\n   - Save yourself debugging time\n\n2. **Other developers** ðŸ‘¥\n   - Team members need to understand\n   - Open source contributors\n   - Code reviews\n\n3. **Users** ðŸ‘¤\n   - How to install\n   - How to use\n   - Troubleshooting\n\n**Types of documentation:**\n\n**1. Code comments** ðŸ’¬\n```python\n# Explain WHY, not WHAT\n# Good: Cache result to avoid expensive API call\n# Bad: This stores the result\n```\n\n**2. Docstrings** ðŸ“\n```python\ndef calculate_total(items, tax_rate):\n    \"\"\"Calculate total price including tax.\n    \n    Args:\n        items: List of item prices\n        tax_rate: Tax rate as decimal (0.1 = 10%)\n    \n    Returns:\n        Total price with tax applied\n    \"\"\"\n```\n\n**3. README.md** ðŸ“„\n- What the project does\n- How to install\n- How to use\n- Examples\n- Contributing guide\n\n**4. API documentation** ðŸ”—\n- Endpoint descriptions\n- Request/response examples\n- Authentication details\n\n**Code quality = Readable, maintainable code**\n\n**PEP 8 (Python Style Guide):**\n- 4 spaces for indentation\n- Max 79 characters per line\n- 2 blank lines between functions\n- snake_case for variables\n- PascalCase for classes\n\n**Tools:**\n- **Black** - Auto-formatter\n- **flake8** - Style checker\n- **pylint** - Code analyzer\n- **mypy** - Type checker"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Writing Good Documentation",
      "code": "print(\"=== Example 1: Poor vs Good Documentation ===\")\n\n# BAD: No documentation\ndef calc(x, y, z):\n    return (x + y) * z\n\n# GOOD: Clear documentation\ndef calculate_total_with_tax(subtotal, tax_rate, quantity):\n    \"\"\"Calculate final price including tax for multiple items.\n    \n    Args:\n        subtotal (float): Price of single item before tax\n        tax_rate (float): Tax rate as decimal (e.g., 0.08 for 8%)\n        quantity (int): Number of items to purchase\n    \n    Returns:\n        float: Total price including tax\n    \n    Example:\n        >>> calculate_total_with_tax(10.00, 0.08, 3)\n        32.4\n    \"\"\"\n    return (subtotal + subtotal * tax_rate) * quantity\n\nprint(\"\\nBAD function:\")\nprint(f\"calc(10, 0.08, 3) = {calc(10, 0.08, 3)}\")\nprint(\"What does this do? ðŸ¤”\")\n\nprint(\"\\nGOOD function:\")\nprint(f\"calculate_total_with_tax(10.00, 0.08, 3) = {calculate_total_with_tax(10.00, 0.08, 3)}\")\nprint(\"Clear what this calculates! âœ“\")\n\nprint(\"\\n=== Example 2: Comprehensive Docstrings ===\")\n\nfrom typing import List, Optional\n\nclass User:\n    \"\"\"Represents a user in the system.\n    \n    Attributes:\n        username (str): Unique username for login\n        email (str): User's email address\n        is_active (bool): Whether account is active\n    \"\"\"\n    \n    def __init__(self, username: str, email: str):\n        \"\"\"Initialize a new user.\n        \n        Args:\n            username: Unique identifier for the user\n            email: Contact email address\n        \n        Raises:\n            ValueError: If username or email is empty\n        \"\"\"\n        if not username or not email:\n            raise ValueError(\"Username and email are required\")\n        \n        self.username = username\n        self.email = email\n        self.is_active = True\n    \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the user account.\n        \n        This prevents the user from logging in but preserves\n        their data for potential reactivation.\n        \"\"\"\n        self.is_active = False\n    \n    def send_notification(self, message: str) -> bool:\n        \"\"\"Send notification email to user.\n        \n        Args:\n            message: The notification message to send\n        \n        Returns:\n            True if notification sent successfully, False otherwise\n        \n        Note:\n            This simulates sending an email. In production,\n            integrate with actual email service.\n        \"\"\"\n        print(f\"[Email to {self.email}] {message}\")\n        return True\n\nprint(\"User class with comprehensive docstrings\")\nuser = User(\"alice\", \"alice@example.com\")\nprint(f\"Created user: {user.username}\")\nuser.send_notification(\"Welcome to the platform!\")\n\nprint(\"\\n=== Example 3: README.md Template ===\")\n\nreadme_template = '''\n# Project Name\n\nOne-line description of what this project does.\n\n## Features\n\n- Feature 1: Brief description\n- Feature 2: Brief description\n- Feature 3: Brief description\n\n## Installation\n\n```bash\n# Clone the repository\ngit clone https://github.com/username/project.git\ncd project\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\\\Scripts\\\\activate\n\n# Install dependencies\npip install -r requirements.txt\n```\n\n## Quick Start\n\n```python\nfrom project import MainClass\n\n# Basic usage example\nobj = MainClass()\nresult = obj.do_something()\nprint(result)\n```\n\n## Usage\n\n### Example 1: Basic Usage\n\n```python\n# Code example\n```\n\n### Example 2: Advanced Usage\n\n```python\n# More complex example\n```\n\n## Configuration\n\nCreate a `.env` file:\n\n```\nDATABASE_URL=postgresql://user:pass@localhost/db\nSECRET_KEY=your-secret-key\nDEBUG=False\n```\n\n## Running Tests\n\n```bash\npytest tests/\n```\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch (`git checkout -b feature/amazing-feature`)\n3. Commit your changes (`git commit -m 'Add amazing feature'`)\n4. Push to branch (`git push origin feature/amazing-feature`)\n5. Open a Pull Request\n\n## License\n\nMIT License - see LICENSE file for details\n\n## Contact\n\nYour Name - your.email@example.com\n\nProject Link: https://github.com/username/project\n'''\n\nprint(readme_template)\n\nprint(\"\\n=== Example 4: Code Quality Tools ===\")\n\nprint(\"\\n1. Black (Auto-formatter)\")\nprint(\"\"\"\n# Install\npip install black\n\n# Format all Python files\nblack .\n\n# Check without modifying\nblack --check .\n\n# Configuration: pyproject.toml\n[tool.black]\nline-length = 88\ntarget-version = ['py38']\n\"\"\")\n\nprint(\"\\n2. flake8 (Style checker)\")\nprint(\"\"\"\n# Install\npip install flake8\n\n# Check all files\nflake8 .\n\n# Configuration: .flake8\n[flake8]\nmax-line-length = 88\nexclude = .git,__pycache__,venv\nignore = E203, W503\n\"\"\")\n\nprint(\"\\n3. mypy (Type checker)\")\nprint(\"\"\"\n# Install\npip install mypy\n\n# Check types\nmypy src/\n\n# Configuration: mypy.ini\n[mypy]\npython_version = 3.8\nwarn_return_any = True\nwarn_unused_configs = True\n\"\"\")\n\nprint(\"\\n=== Example 5: Type Hints ===\")\n\ndef process_users(users: List[dict], active_only: bool = True) -> List[str]:\n    \"\"\"Extract usernames from user dictionaries.\n    \n    Args:\n        users: List of user dictionaries with 'username' and 'is_active' keys\n        active_only: If True, only return active users\n    \n    Returns:\n        List of usernames\n    \"\"\"\n    result = []\n    for user in users:\n        if not active_only or user.get('is_active', True):\n            result.append(user['username'])\n    return result\n\n# Better with type hints\nfrom typing import TypedDict\n\nclass UserDict(TypedDict):\n    username: str\n    email: str\n    is_active: bool\n\ndef process_users_typed(users: List[UserDict], active_only: bool = True) -> List[str]:\n    \"\"\"Extract usernames from user dictionaries (type-safe).\"\"\"\n    result = []\n    for user in users:\n        if not active_only or user['is_active']:\n            result.append(user['username'])\n    return result\n\nprint(\"\\nType hints make code more maintainable:\")\ntest_users: List[UserDict] = [\n    {'username': 'alice', 'email': 'alice@example.com', 'is_active': True},\n    {'username': 'bob', 'email': 'bob@example.com', 'is_active': False},\n]\n\nactive_users = process_users_typed(test_users, active_only=True)\nprint(f\"Active users: {active_users}\")",
      "explanation": "**Documentation best practices:**\n\n**Docstring format (Google style):**\n```python\ndef function(arg1, arg2):\n    \"\"\"Short description.\n    \n    Longer description if needed.\n    \n    Args:\n        arg1: Description of arg1\n        arg2: Description of arg2\n    \n    Returns:\n        Description of return value\n    \n    Raises:\n        ValueError: When this error occurs\n    \"\"\"\n```\n\n**Type hints:**\n```python\nfrom typing import List, Optional\n\ndef greet(name: str, times: int = 1) -> str:\n    return (\"Hello \" + name + \"! \") * times\n```\n\n**Comments:**\n- Explain WHY, not WHAT\n- Complex logic needs explanation\n- TODO/FIXME for future work\n\n**README sections:**\n1. What it does\n2. Installation\n3. Quick start\n4. Examples\n5. Configuration\n6. Contributing\n7. License",
      "output": "=== Example 1: Poor vs Good Documentation ===\n\nBAD function:\ncalc(10, 0.08, 3) = 32.4\nWhat does this do? ðŸ¤”\n\nGOOD function:\ncalculate_total_with_tax(10.00, 0.08, 3) = 32.4\nClear what this calculates! âœ“\n\n=== Example 2: Comprehensive Docstrings ===\nUser class with comprehensive docstrings\nCreated user: alice\n[Email to alice@example.com] Welcome to the platform!\n\n=== Example 3: README.md Template ===\n[Full README template displayed]\n\n=== Example 4: Code Quality Tools ===\n[Tool configurations displayed]\n\n=== Example 5: Type Hints ===\nType hints make code more maintainable:\nActive users: ['alice']"
    },
    {
      "type": "the_simplifier",
      "title": "Code Review Checklist",
      "content": "**Code review = Quality gate before merging**\n\n**What to look for:**\n\n**1. Functionality** âœ…\n- Does it work as intended?\n- Are edge cases handled?\n- Are errors handled properly?\n\n**2. Tests** ðŸ§ª\n- Are there tests?\n- Do tests cover edge cases?\n- Do all tests pass?\n\n**3. Code Quality** ðŸ’Ž\n- Is code readable?\n- Are names descriptive?\n- Is logic clear?\n- DRY (Don't Repeat Yourself)?\n\n**4. Documentation** ðŸ“š\n- Are functions documented?\n- Is README updated?\n- Are comments helpful?\n\n**5. Security** ðŸ”’\n- No hardcoded secrets?\n- Input validation?\n- SQL injection prevention?\n\n**6. Performance** âš¡\n- Efficient algorithms?\n- No unnecessary loops?\n- Database queries optimized?\n\n**Review comments:**\n\n**Good:**\n- \"Consider using a dict here for O(1) lookup\"\n- \"Great job handling this edge case!\"\n- \"Could we add a test for the error case?\"\n\n**Bad:**\n- \"This is wrong\"\n- \"Why did you do it this way?\"\n- \"Fix this\""
    },
    {
      "type": "the_coder",
      "title": "Interactive Exercise",
      "instruction": "Improve this poorly documented code:\n1. Add comprehensive docstrings\n2. Add type hints\n3. Improve variable names\n4. Add comments where needed\n5. Follow PEP 8 style",
      "starter_code": "def p(l):\n    r=[]\n    for i in l:\n        if i%2==0:\n            r.append(i*2)\n    return r\n\nclass C:\n    def __init__(self,n,a):\n        self.n=n\n        self.a=a\n    def g(self):\n        return self.n if self.a else None",
      "hint": "Use descriptive names. Add docstrings. Format with proper spacing. Add type hints."
    },
    {
      "type": "the_coder",
      "title": "Solution",
      "solution_code": "from typing import List, Optional\n\nprint(\"=== BEFORE: Poorly Documented Code ===\")\nprint(\"\"\"\ndef p(l):\n    r=[]\n    for i in l:\n        if i%2==0:\n            r.append(i*2)\n    return r\n\nclass C:\n    def __init__(self,n,a):\n        self.n=n\n        self.a=a\n    def g(self):\n        return self.n if self.a else None\n\"\"\")\n\nprint(\"\\n=== AFTER: Well-Documented Code ===\")\n\ndef double_even_numbers(numbers: List[int]) -> List[int]:\n    \"\"\"Double all even numbers in a list.\n    \n    Takes a list of integers and returns a new list containing\n    only the even numbers, each multiplied by 2.\n    \n    Args:\n        numbers: List of integers to process\n    \n    Returns:\n        List of doubled even numbers\n    \n    Example:\n        >>> double_even_numbers([1, 2, 3, 4, 5])\n        [4, 8]\n    \"\"\"\n    result = []\n    \n    for number in numbers:\n        if number % 2 == 0:  # Check if even\n            result.append(number * 2)\n    \n    return result\n\n# Alternative: Using list comprehension (more Pythonic)\ndef double_even_numbers_v2(numbers: List[int]) -> List[int]:\n    \"\"\"Double all even numbers in a list (list comprehension version).\n    \n    Args:\n        numbers: List of integers to process\n    \n    Returns:\n        List of doubled even numbers\n    \"\"\"\n    return [num * 2 for num in numbers if num % 2 == 0]\n\nclass Counter:\n    \"\"\"A simple counter that can be activated or deactivated.\n    \n    Attributes:\n        name (str): Identifier for this counter\n        is_active (bool): Whether the counter is currently active\n        _count (int): Internal count value (private)\n    \"\"\"\n    \n    def __init__(self, name: str, is_active: bool = True):\n        \"\"\"Initialize a new counter.\n        \n        Args:\n            name: Identifier for this counter\n            is_active: Initial activation state (default: True)\n        \"\"\"\n        self.name = name\n        self.is_active = is_active\n        self._count = 0\n    \n    def get_count(self) -> Optional[int]:\n        \"\"\"Get the current count if counter is active.\n        \n        Returns:\n            Current count if active, None if inactive\n        \"\"\"\n        if self.is_active:\n            return self._count\n        return None\n    \n    def increment(self) -> bool:\n        \"\"\"Increment counter if active.\n        \n        Returns:\n            True if incremented, False if counter inactive\n        \"\"\"\n        if self.is_active:\n            self._count += 1\n            return True\n        return False\n    \n    def reset(self) -> None:\n        \"\"\"Reset counter to zero.\"\"\"\n        self._count = 0\n    \n    def __repr__(self) -> str:\n        \"\"\"String representation of counter.\"\"\"\n        status = \"active\" if self.is_active else \"inactive\"\n        return f\"Counter('{self.name}', count={self._count}, {status})\"\n\nprint(\"\\n=== Testing Improved Code ===\")\n\nprint(\"\\n1. Testing double_even_numbers:\")\ntest_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nresult = double_even_numbers(test_numbers)\nprint(f\"Input: {test_numbers}\")\nprint(f\"Output: {result}\")\n\nprint(\"\\n2. Testing list comprehension version:\")\nresult_v2 = double_even_numbers_v2(test_numbers)\nprint(f\"Output: {result_v2}\")\nprint(f\"Same result: {result == result_v2}\")\n\nprint(\"\\n3. Testing Counter class:\")\ncounter = Counter(\"PageViews\", is_active=True)\nprint(f\"Created: {counter}\")\n\nprint(\"\\nIncrementing counter:\")\nfor i in range(5):\n    counter.increment()\n    print(f\"  Count: {counter.get_count()}\")\n\nprint(f\"\\nFinal state: {counter}\")\n\nprint(\"\\nDeactivating counter:\")\ncounter.is_active = False\nprint(f\"Count when inactive: {counter.get_count()}\")\nprint(f\"Can increment: {counter.increment()}\")\n\nprint(\"\\n=== Key Improvements ===\")\nimprovements = [\n    \"âœ“ Descriptive function and variable names\",\n    \"âœ“ Comprehensive docstrings with examples\",\n    \"âœ“ Type hints for all parameters and returns\",\n    \"âœ“ Proper spacing (PEP 8 compliance)\",\n    \"âœ“ Helpful comments explaining logic\",\n    \"âœ“ Alternative implementations shown\",\n    \"âœ“ Clear class structure with private variables\",\n    \"âœ“ __repr__ for better debugging\"\n]\n\nfor improvement in improvements:\n    print(improvement)\n\nprint(\"\\n=== Documentation Standards Checklist ===\")\n\nchecklist = {\n    \"Functions\": [\n        \"âœ“ Docstring with description\",\n        \"âœ“ Args section with types\",\n        \"âœ“ Returns section\",\n        \"âœ“ Examples where helpful\",\n        \"âœ“ Raises section for exceptions\"\n    ],\n    \"Classes\": [\n        \"âœ“ Class-level docstring\",\n        \"âœ“ Attributes documented\",\n        \"âœ“ __init__ documented\",\n        \"âœ“ All methods documented\",\n        \"âœ“ __repr__ for debugging\"\n    ],\n    \"Code Style\": [\n        \"âœ“ Descriptive names\",\n        \"âœ“ Consistent formatting\",\n        \"âœ“ Proper spacing\",\n        \"âœ“ Type hints\",\n        \"âœ“ Comments for complex logic\"\n    ]\n}\n\nfor category, items in checklist.items():\n    print(f\"\\n{category}:\")\n    for item in items:\n        print(f\"  {item}\")",
      "explanation": "**Transformation summary:**\n\n**Before:**\n- Single letter variables (p, l, r, i)\n- No documentation\n- No type hints\n- Poor formatting\n- Unclear purpose\n\n**After:**\n- Descriptive names (double_even_numbers, numbers, result)\n- Comprehensive docstrings\n- Type hints for safety\n- PEP 8 formatting\n- Clear purpose and examples\n\n**Benefits:**\n1. **Readability** - Anyone can understand\n2. **Maintainability** - Easy to modify\n3. **Type safety** - Catch errors early\n4. **Documentation** - Self-documenting code\n5. **Professionalism** - Production-ready\n\n**Tools that help:**\n- Black: Auto-format\n- flake8: Check style\n- mypy: Check types\n- pylint: Code quality\n- pydocstyle: Check docstrings",
      "output": "=== BEFORE: Poorly Documented Code ===\n[Poorly written code displayed]\n\n=== AFTER: Well-Documented Code ===\n[Improved code with full documentation]\n\n=== Testing Improved Code ===\n\n1. Testing double_even_numbers:\nInput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nOutput: [4, 8, 12, 16, 20]\n\n2. Testing list comprehension version:\nOutput: [4, 8, 12, 16, 20]\nSame result: True\n\n3. Testing Counter class:\nCreated: Counter('PageViews', count=0, active)\n\nIncrementing counter:\n  Count: 1\n  Count: 2\n  Count: 3\n  Count: 4\n  Count: 5\n\nFinal state: Counter('PageViews', count=5, active)\n\nDeactivating counter:\nCount when inactive: None\nCan increment: False\n\n=== Key Improvements ===\n[List of improvements displayed]\n\n=== Documentation Standards Checklist ===\n[Complete checklist displayed]",
      "common_mistakes": [
        "Using single-letter variable names (except in very short loops)",
        "No docstrings - code is harder to understand",
        "Missing type hints - no IDE autocomplete or type checking",
        "No examples in documentation",
        "Inconsistent formatting - use Black to fix"
      ]
    },
    {
      "type": "key_takeaways",
      "title": "Key Takeaways",
      "takeaways": [
        "**Code is read more than written** - Prioritize readability",
        "**Docstrings document functions** - Args, Returns, Raises, Examples",
        "**Type hints improve safety** - Catch errors before runtime",
        "**README is your first impression** - Clear installation and usage",
        "**PEP 8 is the Python style guide** - Consistent formatting matters",
        "**Black auto-formats code** - Never debate formatting again",
        "**Comments explain WHY** - Code shows WHAT, comments show WHY",
        "**Code review is quality control** - Catch issues before production"
      ]
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "What is the purpose of a docstring in Python?",
        "options": [
          "To comment out code",
          "To document what a function/class does, its parameters, and return value",
          "To format code automatically",
          "To check for syntax errors"
        ],
        "correct_answer": 1,
        "explanation": "Docstrings (triple-quoted strings) document functions, classes, and modules. They describe purpose, parameters, return values, and provide examples."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "What does PEP 8 define?",
        "options": [
          "Python's syntax rules",
          "Python's style guide for code formatting",
          "Python's performance benchmarks",
          "Python's testing framework"
        ],
        "correct_answer": 1,
        "explanation": "PEP 8 is Python's official style guide, defining conventions for naming, indentation, spacing, and code layout."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "What tool automatically formats Python code to be PEP 8 compliant?",
        "options": [
          "pytest",
          "flake8",
          "Black",
          "mypy"
        ],
        "correct_answer": 2,
        "explanation": "Black is an opinionated auto-formatter that formats Python code consistently. flake8 checks style, mypy checks types, pytest runs tests."
      }
    ]
  }
}
