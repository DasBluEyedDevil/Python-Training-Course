{
  "lesson_id": "14_02",
  "title": "Version Control with Git",
  "module_id": 14,
  "order_index": 2,
  "description": "Master Git version control system for tracking changes, collaborating with teams, and managing code history. Learn branching, merging, pull requests, and best practices.",
  "estimated_minutes": 40,
  "content_blocks": [
    {
      "type": "the_simplifier",
      "title": "The Concept: Time Machine for Code",
      "content": "**Git = Save points for your code**\n\n**Think of a video game:**\n- Save your progress before boss fight\n- Try different strategies\n- Go back if you fail\n- Keep multiple save files\n\n**Git does this for code!**\n\n**Key concepts:**\n\n1. **Repository (repo)** üìÅ\n   - Project folder with Git tracking\n   - Contains all history\n   - Local (your computer) + Remote (GitHub)\n\n2. **Commit** üíæ\n   - Save point in history\n   - Snapshot of all files\n   - Has message describing changes\n   - Permanent record\n\n3. **Branch** üå≥\n   - Parallel version of code\n   - Experiment without breaking main code\n   - Merge back when ready\n   - main/master = production code\n\n4. **Merge** üîÄ\n   - Combine branches\n   - Integrate features\n   - May have conflicts to resolve\n\n5. **Pull Request (PR)** ü§ù\n   - Request to merge your changes\n   - Code review\n   - Discussion before merging\n   - Quality control\n\n**Basic workflow:**\n```\n1. Clone repo (copy to your computer)\n2. Create branch (new feature)\n3. Make changes\n4. Commit changes (save point)\n5. Push to GitHub (backup)\n6. Create Pull Request\n7. Review + Merge\n```\n\n**Why use Git:**\n- Track every change ever made\n- Collaborate without overwriting others\n- Experiment safely\n- Revert mistakes\n- Required for professional development"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Git Basics",
      "code": "# Git commands demonstration (as comments)\n# Run these in your terminal, not Python\n\nprint(\"=== Git Setup (One-time) ===\")\n\"\"\"\n# Configure your identity\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# Check configuration\ngit config --list\n\"\"\"\n\nprint(\"\\n=== Creating a Repository ===\")\n\"\"\"\n# Method 1: Start new project\nmkdir my-project\ncd my-project\ngit init\n# Creates .git folder (hidden)\n\n# Method 2: Clone existing\ngit clone https://github.com/username/repo.git\ncd repo\n\"\"\"\n\nprint(\"\\n=== Basic Workflow ===\")\n\"\"\"\n# 1. Check status\ngit status\n# Shows: modified files, staged files, branch\n\n# 2. Stage files (prepare for commit)\ngit add file.py          # Specific file\ngit add .                # All files\ngit add *.py             # All Python files\n\n# 3. Commit changes\ngit commit -m \"Add user authentication\"\n# -m = message describing what changed\n\n# 4. View history\ngit log\ngit log --oneline        # Condensed view\ngit log --graph          # Visual branch graph\n\n# 5. Push to remote (GitHub)\ngit push origin main\n# origin = remote name (default)\n# main = branch name\n\"\"\"\n\nprint(\"\\n=== Working with Branches ===\")\n\"\"\"\n# Create new branch\ngit branch feature/login        # Create\ngit checkout feature/login      # Switch to it\n# Or combined:\ngit checkout -b feature/login   # Create + switch\n\n# List branches\ngit branch                      # Local branches\ngit branch -a                   # All (including remote)\n\n# Switch branches\ngit checkout main\ngit checkout feature/login\n\n# Delete branch\ngit branch -d feature/login     # Safe delete (merged only)\ngit branch -D feature/login     # Force delete\n\"\"\"\n\nprint(\"\\n=== Merging Branches ===\")\n\"\"\"\n# Merge feature into main\ngit checkout main               # Switch to main\ngit merge feature/login         # Merge feature in\n\n# If conflicts occur:\n# 1. Git marks conflicts in files:\n#    <<<<<<< HEAD\n#    code from main\n#    =======\n#    code from feature\n#    >>>>>>> feature/login\n#\n# 2. Manually resolve (edit file)\n# 3. Stage resolved files\n#    git add conflicted-file.py\n# 4. Commit the merge\n#    git commit -m \"Merge feature/login\"\n\"\"\"\n\nprint(\"\\n=== Undoing Changes ===\")\n\"\"\"\n# Discard changes in working directory\ngit checkout -- file.py         # Restore from last commit\n\n# Unstage files (undo git add)\ngit reset HEAD file.py\n\n# Undo last commit (keep changes)\ngit reset --soft HEAD~1\n\n# Undo last commit (discard changes)\ngit reset --hard HEAD~1\n# WARNING: Can't recover discarded changes!\n\n# Create new commit that undoes a previous commit\ngit revert <commit-hash>\n# Safer than reset, keeps history\n\"\"\"\n\nprint(\"\\n=== Remote Operations ===\")\n\"\"\"\n# View remotes\ngit remote -v\n\n# Add remote\ngit remote add origin https://github.com/username/repo.git\n\n# Fetch changes (download, don't merge)\ngit fetch origin\n\n# Pull changes (fetch + merge)\ngit pull origin main\n# Equivalent to:\n#   git fetch origin\n#   git merge origin/main\n\n# Push branch to remote\ngit push -u origin feature/login\n# -u sets upstream tracking\n# After this, just: git push\n\"\"\"\n\nprint(\"\\n=== .gitignore File ===\")\n\"\"\"\n# Create .gitignore in project root\n# Lists files/folders Git should ignore\n\nExample .gitignore:\n```\n# Environment\n.env\nvenv/\n__pycache__/\n*.pyc\n\n# IDE\n.vscode/\n.idea/\n*.swp\n\n# Database\n*.db\n*.sqlite\n\n# OS\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\n```\n\"\"\"\n\nprint(\"\\n=== Common Git Scenarios ===\")\n\n# Scenario demonstrations\nscenarios = [\n    {\n        \"title\": \"Start new feature\",\n        \"commands\": [\n            \"git checkout main\",\n            \"git pull origin main\",\n            \"git checkout -b feature/new-api\",\n            \"# Make changes...\",\n            \"git add .\",\n            \"git commit -m 'Add new API endpoint'\",\n            \"git push -u origin feature/new-api\"\n        ]\n    },\n    {\n        \"title\": \"Fix a bug\",\n        \"commands\": [\n            \"git checkout main\",\n            \"git checkout -b bugfix/login-error\",\n            \"# Fix the bug...\",\n            \"git add file.py\",\n            \"git commit -m 'Fix login validation error'\",\n            \"git push -u origin bugfix/login-error\"\n        ]\n    },\n    {\n        \"title\": \"Update from main\",\n        \"commands\": [\n            \"git checkout feature/my-branch\",\n            \"git fetch origin\",\n            \"git merge origin/main\",\n            \"# Resolve any conflicts...\",\n            \"git push\"\n        ]\n    }\n]\n\nfor scenario in scenarios:\n    print(f\"\\n{scenario['title']}:\")\n    for cmd in scenario['commands']:\n        if cmd.startswith('#'):\n            print(f\"  {cmd}\")\n        else:\n            print(f\"  $ {cmd}\")\n\nprint(\"\\n=== Git Best Practices ===\")\n\nbest_practices = [\n    \"‚úì Commit often, push daily\",\n    \"‚úì Write clear commit messages\",\n    \"‚úì One feature = one branch\",\n    \"‚úì Pull before you push\",\n    \"‚úì Never commit secrets (.env, passwords)\",\n    \"‚úì Keep commits focused (one logical change)\",\n    \"‚úì Review changes before committing (git diff)\",\n    \"‚úì Use branches for experiments\",\n    \"‚úì Delete merged branches\",\n    \"‚úì Don't rewrite public history (main branch)\"\n]\n\nfor practice in best_practices:\n    print(practice)",
      "explanation": "**Git workflow stages:**\n\n```\nWorking Directory  ‚Üí  Staging Area  ‚Üí  Repository\n   (changes)          (git add)         (git commit)\n```\n\n**Branch strategy:**\n```\nmain          ‚óã‚îÄ‚îÄ‚óã‚îÄ‚îÄ‚óã‚îÄ‚îÄ‚óã‚îÄ‚îÄ‚óã\n               \\      /\nfeature         ‚óã‚îÄ‚îÄ‚óã‚îÄ‚îÄ‚óã\n```\n\n**Commit message format:**\n```\nShort summary (50 chars max)\n\nLonger description if needed.\nExplain WHY, not what.\n```\n\n**Good commit messages:**\n- \"Add user authentication with JWT\"\n- \"Fix null pointer error in login\"\n- \"Refactor database queries for performance\"\n\n**Bad commit messages:**\n- \"Fix bug\"\n- \"Update\"\n- \"WIP\"\n- \"asdfghjkl\"",
      "output": "=== Git Setup (One-time) ===\n\n=== Creating a Repository ===\n\n=== Basic Workflow ===\n\n=== Working with Branches ===\n\n=== Merging Branches ===\n\n=== Undoing Changes ===\n\n=== Remote Operations ===\n\n=== .gitignore File ===\n\n=== Common Git Scenarios ===\n\nStart new feature:\n  $ git checkout main\n  $ git pull origin main\n  $ git checkout -b feature/new-api\n  # Make changes...\n  $ git add .\n  $ git commit -m 'Add new API endpoint'\n  $ git push -u origin feature/new-api\n\nFix a bug:\n  $ git checkout main\n  $ git checkout -b bugfix/login-error\n  # Fix the bug...\n  $ git add file.py\n  $ git commit -m 'Fix login validation error'\n  $ git push -u origin bugfix/login-error\n\nUpdate from main:\n  $ git checkout feature/my-branch\n  $ git fetch origin\n  $ git merge origin/main\n  # Resolve any conflicts...\n  $ git push\n\n=== Git Best Practices ===\n‚úì Commit often, push daily\n‚úì Write clear commit messages\n‚úì One feature = one branch\n‚úì Pull before you push\n‚úì Never commit secrets (.env, passwords)\n‚úì Keep commits focused (one logical change)\n‚úì Review changes before committing (git diff)\n‚úì Use branches for experiments\n‚úì Delete merged branches\n‚úì Don't rewrite public history (main branch)"
    },
    {
      "type": "the_simplifier",
      "title": "GitHub Workflow",
      "content": "**GitHub = Remote Git hosting + collaboration tools**\n\n**Key features:**\n\n**1. Pull Requests (PRs)**\n- Propose changes\n- Code review\n- Discussion\n- CI/CD checks\n\n**2. Issues**\n- Bug reports\n- Feature requests\n- Task tracking\n- Discussion\n\n**3. Forking**\n- Copy someone's repo\n- Make your changes\n- Contribute back via PR\n\n**Standard workflow:**\n\n```\n1. Fork repo (your copy on GitHub)\n2. Clone fork to your computer\n3. Create feature branch\n4. Make changes + commit\n5. Push to your fork\n6. Open Pull Request\n7. Address review comments\n8. PR gets merged\n9. Delete branch\n```\n\n**Pull Request description template:**\n```markdown\n## What\nBrief description of changes\n\n## Why  \nWhy this change is needed\n\n## How\nHow it was implemented\n\n## Testing\nHow to test these changes\n\n## Screenshots\n(if UI changes)\n```\n\n**Code review etiquette:**\n- Be respectful and constructive\n- Ask questions, don't demand\n- Praise good code\n- Suggest, don't command\n- Focus on code, not person"
    },
    {
      "type": "the_coder",
      "title": "Code Example: Python Git Automation",
      "code": "import subprocess\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\n\nprint(\"=== Git Automation with Python ===\")\n\nclass GitHelper:\n    \"\"\"Helper class for Git operations via Python\"\"\"\n    \n    def __init__(self, repo_path: str = \".\"):\n        self.repo_path = Path(repo_path)\n    \n    def run_command(self, command: List[str]) -> tuple:\n        \"\"\"Run git command and return output\"\"\"\n        try:\n            result = subprocess.run(\n                command,\n                cwd=self.repo_path,\n                capture_output=True,\n                text=True,\n                check=True\n            )\n            return True, result.stdout.strip()\n        except subprocess.CalledProcessError as e:\n            return False, e.stderr.strip()\n    \n    def get_status(self) -> str:\n        \"\"\"Get git status\"\"\"\n        success, output = self.run_command([\"git\", \"status\", \"--short\"])\n        return output if success else \"Error getting status\"\n    \n    def get_current_branch(self) -> str:\n        \"\"\"Get current branch name\"\"\"\n        success, output = self.run_command([\"git\", \"branch\", \"--show-current\"])\n        return output if success else \"unknown\"\n    \n    def get_last_commit(self) -> str:\n        \"\"\"Get last commit message\"\"\"\n        success, output = self.run_command(\n            [\"git\", \"log\", \"-1\", \"--pretty=format:%h - %s\"]\n        )\n        return output if success else \"No commits\"\n    \n    def list_branches(self) -> List[str]:\n        \"\"\"List all local branches\"\"\"\n        success, output = self.run_command([\"git\", \"branch\"])\n        if not success:\n            return []\n        \n        branches = [\n            line.strip().replace(\"* \", \"\")\n            for line in output.split(\"\\n\")\n            if line.strip()\n        ]\n        return branches\n    \n    def create_branch(self, branch_name: str) -> bool:\n        \"\"\"Create new branch\"\"\"\n        success, _ = self.run_command([\"git\", \"checkout\", \"-b\", branch_name])\n        return success\n    \n    def switch_branch(self, branch_name: str) -> bool:\n        \"\"\"Switch to existing branch\"\"\"\n        success, _ = self.run_command([\"git\", \"checkout\", branch_name])\n        return success\n    \n    def add_files(self, files: str = \".\") -> bool:\n        \"\"\"Stage files for commit\"\"\"\n        success, _ = self.run_command([\"git\", \"add\", files])\n        return success\n    \n    def commit(self, message: str) -> bool:\n        \"\"\"Commit staged changes\"\"\"\n        success, _ = self.run_command([\"git\", \"commit\", \"-m\", message])\n        return success\n    \n    def push(self, remote: str = \"origin\", branch: Optional[str] = None) -> bool:\n        \"\"\"Push to remote\"\"\"\n        if branch is None:\n            branch = self.get_current_branch()\n        \n        success, _ = self.run_command([\"git\", \"push\", remote, branch])\n        return success\n    \n    def pull(self, remote: str = \"origin\", branch: Optional[str] = None) -> bool:\n        \"\"\"Pull from remote\"\"\"\n        if branch is None:\n            branch = self.get_current_branch()\n        \n        success, _ = self.run_command([\"git\", \"pull\", remote, branch])\n        return success\n    \n    def get_modified_files(self) -> List[str]:\n        \"\"\"Get list of modified files\"\"\"\n        success, output = self.run_command([\"git\", \"diff\", \"--name-only\"])\n        if not success or not output:\n            return []\n        \n        return output.split(\"\\n\")\n    \n    def get_commit_count(self) -> int:\n        \"\"\"Get total commit count\"\"\"\n        success, output = self.run_command([\"git\", \"rev-list\", \"--count\", \"HEAD\"])\n        if success and output.isdigit():\n            return int(output)\n        return 0\n\nprint(\"\\n=== Using Git Helper ===\")\n\n# Note: This would work in a real Git repository\n# For demonstration, we'll show the usage pattern\n\nprint(\"\\nExample usage:\")\nprint(\"\"\"\ngit = GitHelper()\n\n# Check status\nstatus = git.get_status()\nprint(f\"Status: {status}\")\n\n# Get current branch\nbranch = git.get_current_branch()\nprint(f\"Current branch: {branch}\")\n\n# Create and switch to feature branch\nif git.create_branch('feature/new-feature'):\n    print(\"Branch created successfully\")\n\n# Make some changes to files...\n\n# Stage and commit\nif git.add_files('.'):\n    if git.commit('Add new feature'):\n        print(\"Changes committed\")\n\n# Push to remote\nif git.push():\n    print(\"Pushed to remote\")\n\n# List all branches\nbranches = git.list_branches()\nprint(f\"Branches: {branches}\")\n\n# Get commit count\ncount = git.get_commit_count()\nprint(f\"Total commits: {count}\")\n\"\"\")\n\nprint(\"\\n=== Pre-commit Hook Example ===\")\n\n# Example pre-commit hook script\npre_commit_hook = '''\n#!/usr/bin/env python3\n\"\"\"Pre-commit hook: Run checks before allowing commit\"\"\"\n\nimport subprocess\nimport sys\n\ndef run_tests():\n    \"\"\"Run test suite\"\"\"\n    result = subprocess.run(['pytest', 'tests/'], capture_output=True)\n    return result.returncode == 0\n\ndef check_code_style():\n    \"\"\"Check Python code style with flake8\"\"\"\n    result = subprocess.run(['flake8', '.'], capture_output=True)\n    return result.returncode == 0\n\ndef check_no_debug_prints():\n    \"\"\"Ensure no print() statements in production code\"\"\"\n    result = subprocess.run(\n        ['git', 'diff', '--cached', '--name-only'],\n        capture_output=True,\n        text=True\n    )\n    \n    for file in result.stdout.split():\n        if file.endswith('.py') and 'test' not in file:\n            with open(file) as f:\n                if 'print(' in f.read():\n                    print(f\"‚ùå Debug print() found in {file}\")\n                    return False\n    return True\n\nif __name__ == '__main__':\n    print(\"Running pre-commit checks...\")\n    \n    checks = [\n        (\"Tests\", run_tests),\n        (\"Code style\", check_code_style),\n        (\"No debug prints\", check_no_debug_prints)\n    ]\n    \n    for name, check_func in checks:\n        print(f\"Checking {name}...\", end=\" \")\n        if check_func():\n            print(\"‚úì\")\n        else:\n            print(\"‚úó\")\n            print(f\"\\n‚ùå {name} check failed. Commit aborted.\")\n            sys.exit(1)\n    \n    print(\"\\n‚úì All checks passed. Committing...\")\n    sys.exit(0)\n'''\n\nprint(\"Pre-commit hook script:\")\nprint(pre_commit_hook)\n\nprint(\"\\n=== Git Statistics Script ===\")\n\nstat_script = '''\nimport subprocess\nfrom collections import Counter\n\ndef get_git_stats():\n    \"\"\"Generate repository statistics\"\"\"\n    \n    # Total commits\n    result = subprocess.run(\n        ['git', 'rev-list', '--count', 'HEAD'],\n        capture_output=True,\n        text=True\n    )\n    total_commits = result.stdout.strip()\n    \n    # Contributors\n    result = subprocess.run(\n        ['git', 'shortlog', '-sn', '--all'],\n        capture_output=True,\n        text=True\n    )\n    contributors = result.stdout.strip().split('\\\\n')\n    \n    # Lines of code\n    result = subprocess.run(\n        ['git', 'ls-files'],\n        capture_output=True,\n        text=True\n    )\n    files = result.stdout.strip().split('\\\\n')\n    \n    print(f\"Total commits: {total_commits}\")\n    print(f\"Total files: {len(files)}\")\n    print(f\"\\\\nTop contributors:\")\n    for contributor in contributors[:5]:\n        print(f\"  {contributor}\")\n\nget_git_stats()\n'''\n\nprint(\"Git statistics script:\")\nprint(stat_script)",
      "explanation": "**Python + Git integration:**\n\n**Using subprocess:**\n```python\nimport subprocess\n\nresult = subprocess.run(\n    ['git', 'status'],\n    capture_output=True,\n    text=True\n)\nprint(result.stdout)\n```\n\n**Git hooks:**\n- Scripts that run on Git events\n- Located in `.git/hooks/`\n- Can prevent commits/pushes\n\n**Common hooks:**\n- `pre-commit`: Before commit\n- `commit-msg`: Validate commit message\n- `pre-push`: Before push\n- `post-commit`: After commit\n\n**Use cases:**\n- Run tests before commit\n- Check code style\n- Prevent committing secrets\n- Generate documentation\n- Notify team members",
      "output": "=== Git Automation with Python ===\n\n=== Using Git Helper ===\n\nExample usage:\n\ngit = GitHelper()\n\n# Check status\nstatus = git.get_status()\nprint(f\"Status: {status}\")\n\n# Get current branch\nbranch = git.get_current_branch()\nprint(f\"Current branch: {branch}\")\n\n# Create and switch to feature branch\nif git.create_branch('feature/new-feature'):\n    print(\"Branch created successfully\")\n\n# Make some changes to files...\n\n# Stage and commit\nif git.add_files('.'):\n    if git.commit('Add new feature'):\n        print(\"Changes committed\")\n\n# Push to remote\nif git.push():\n    print(\"Pushed to remote\")\n\n# List all branches\nbranches = git.list_branches()\nprint(f\"Branches: {branches}\")\n\n# Get commit count\ncount = git.get_commit_count()\nprint(f\"Total commits: {count}\")\n\n\n=== Pre-commit Hook Example ===\nPre-commit hook script:\n[Hook script content displayed]\n\n=== Git Statistics Script ===\nGit statistics script:\n[Statistics script content displayed]"
    },
    {
      "type": "the_coder",
      "title": "Interactive Exercise",
      "instruction": "Create a Python script that:\n1. Checks if you're in a Git repository\n2. Shows current branch and status\n3. Lists uncommitted changes\n4. Prompts to create a commit with validation\n5. Handles errors gracefully",
      "starter_code": "import subprocess\nfrom typing import Optional\n\nclass GitCommitHelper:\n    def is_git_repo(self) -> bool:\n        # TODO: Check if current directory is Git repo\n        # Hint: Run 'git rev-parse --is-inside-work-tree'\n        pass\n    \n    def get_status(self) -> str:\n        # TODO: Get git status\n        pass\n    \n    def get_branch(self) -> str:\n        # TODO: Get current branch name\n        pass\n    \n    def has_changes(self) -> bool:\n        # TODO: Check if there are uncommitted changes\n        pass\n    \n    def commit_changes(self, message: str) -> bool:\n        # TODO: Stage all changes and commit\n        # Validate message is not empty\n        pass\n\n# Test the helper\nhelper = GitCommitHelper()\nif helper.is_git_repo():\n    print(f\"Branch: {helper.get_branch()}\")\n    if helper.has_changes():\n        message = input(\"Commit message: \")\n        helper.commit_changes(message)",
      "hint": "Use subprocess.run() to execute git commands. Check return code for success/failure. Capture output with capture_output=True."
    },
    {
      "type": "the_coder",
      "title": "Solution",
      "solution_code": "import subprocess\nimport sys\nfrom typing import Optional, Tuple\n\nprint(\"=== Git Commit Helper ===\")\n\nclass GitCommitHelper:\n    \"\"\"Interactive helper for Git commits\"\"\"\n    \n    def run_git_command(self, args: list) -> Tuple[bool, str]:\n        \"\"\"Run git command and return success status and output\"\"\"\n        try:\n            result = subprocess.run(\n                ['git'] + args,\n                capture_output=True,\n                text=True,\n                check=True\n            )\n            return True, result.stdout.strip()\n        except subprocess.CalledProcessError as e:\n            return False, e.stderr.strip()\n        except FileNotFoundError:\n            return False, \"Git not found. Please install Git.\"\n    \n    def is_git_repo(self) -> bool:\n        \"\"\"Check if current directory is a Git repository\"\"\"\n        success, _ = self.run_git_command(\n            ['rev-parse', '--is-inside-work-tree']\n        )\n        return success\n    \n    def get_branch(self) -> str:\n        \"\"\"Get current branch name\"\"\"\n        success, output = self.run_git_command(\n            ['branch', '--show-current']\n        )\n        return output if success else \"unknown\"\n    \n    def get_status(self) -> str:\n        \"\"\"Get repository status\"\"\"\n        success, output = self.run_git_command(['status', '--short'])\n        return output if success else \"Error getting status\"\n    \n    def has_changes(self) -> bool:\n        \"\"\"Check if there are uncommitted changes\"\"\"\n        status = self.get_status()\n        return bool(status.strip())\n    \n    def get_changed_files(self) -> list:\n        \"\"\"Get list of changed files\"\"\"\n        status = self.get_status()\n        if not status:\n            return []\n        \n        files = []\n        for line in status.split('\\n'):\n            if line.strip():\n                # Status format: \" M file.py\" or \"?? file.py\"\n                parts = line.strip().split(maxsplit=1)\n                if len(parts) == 2:\n                    files.append((parts[0], parts[1]))\n        return files\n    \n    def validate_commit_message(self, message: str) -> Tuple[bool, Optional[str]]:\n        \"\"\"Validate commit message\"\"\"\n        message = message.strip()\n        \n        if not message:\n            return False, \"Commit message cannot be empty\"\n        \n        if len(message) < 10:\n            return False, \"Commit message too short (minimum 10 characters)\"\n        \n        if len(message) > 100:\n            return False, \"Commit message too long (maximum 100 characters)\"\n        \n        # Check for common bad messages\n        bad_messages = ['wip', 'test', 'fix', 'update', 'asdf']\n        if message.lower() in bad_messages:\n            return False, f\"Please write a more descriptive message\"\n        \n        return True, None\n    \n    def stage_all(self) -> bool:\n        \"\"\"Stage all changes\"\"\"\n        success, _ = self.run_git_command(['add', '.'])\n        return success\n    \n    def commit(self, message: str) -> bool:\n        \"\"\"Create a commit\"\"\"\n        success, output = self.run_git_command(['commit', '-m', message])\n        if success:\n            print(f\"‚úì Committed: {message}\")\n        else:\n            print(f\"‚úó Commit failed: {output}\")\n        return success\n    \n    def commit_changes(self, message: str) -> bool:\n        \"\"\"Validate message, stage changes, and commit\"\"\"\n        # Validate message\n        valid, error = self.validate_commit_message(message)\n        if not valid:\n            print(f\"‚úó Invalid commit message: {error}\")\n            return False\n        \n        # Stage all changes\n        print(\"Staging changes...\")\n        if not self.stage_all():\n            print(\"‚úó Failed to stage changes\")\n            return False\n        \n        # Commit\n        return self.commit(message)\n    \n    def show_status_summary(self):\n        \"\"\"Show formatted status summary\"\"\"\n        print(f\"\\nBranch: {self.get_branch()}\")\n        \n        changed_files = self.get_changed_files()\n        \n        if not changed_files:\n            print(\"Status: Clean (no changes)\")\n            return\n        \n        print(f\"\\nChanged files ({len(changed_files)}):\")\n        \n        status_symbols = {\n            'M': 'üìù Modified',\n            'A': '‚ûï Added',\n            'D': '‚ûñ Deleted',\n            '??': '‚ùì Untracked',\n            'MM': 'üìù Modified (staged + unstaged)'\n        }\n        \n        for status, filepath in changed_files:\n            symbol = status_symbols.get(status, status)\n            print(f\"  {symbol}: {filepath}\")\n    \n    def interactive_commit(self):\n        \"\"\"Interactive commit workflow\"\"\"\n        print(\"\\n\" + \"=\"*50)\n        print(\"Interactive Git Commit\")\n        print(\"=\"*50)\n        \n        # Check if Git repo\n        if not self.is_git_repo():\n            print(\"\\n‚úó Not a Git repository\")\n            print(\"  Run 'git init' to initialize a repository\")\n            return\n        \n        # Show status\n        self.show_status_summary()\n        \n        # Check for changes\n        if not self.has_changes():\n            print(\"\\n‚úì Nothing to commit (working tree clean)\")\n            return\n        \n        # Prompt for commit\n        print(\"\\n\" + \"-\"*50)\n        print(\"Ready to commit?\")\n        \n        while True:\n            message = input(\"\\nCommit message (or 'cancel' to abort): \").strip()\n            \n            if message.lower() == 'cancel':\n                print(\"\\n‚úó Commit cancelled\")\n                return\n            \n            # Validate and commit\n            valid, error = self.validate_commit_message(message)\n            \n            if valid:\n                if self.commit_changes(message):\n                    print(\"\\n‚úì Changes committed successfully!\")\n                    return\n                else:\n                    print(\"\\n‚úó Commit failed. Try again.\")\n            else:\n                print(f\"\\n‚úó {error}\")\n                print(\"  Please try again with a better message.\")\n\nprint(\"\\n=== Example Usage ===\")\n\n# Create helper instance\nhelper = GitCommitHelper()\n\n# Example 1: Check if Git repo\nprint(\"\\n1. Checking if Git repository...\")\nif helper.is_git_repo():\n    print(\"   ‚úì This is a Git repository\")\n    print(f\"   Branch: {helper.get_branch()}\")\nelse:\n    print(\"   ‚úó Not a Git repository\")\n\n# Example 2: Show status\nprint(\"\\n2. Repository status:\")\nhelper.show_status_summary()\n\n# Example 3: Validate commit messages\nprint(\"\\n3. Testing commit message validation:\")\n\ntest_messages = [\n    \"\",\n    \"fix\",\n    \"Fix authentication bug\",\n    \"Add user profile page with avatar upload and bio editing functionality that allows users to customize\",\n    \"Add comprehensive user authentication system\"\n]\n\nfor msg in test_messages:\n    valid, error = helper.validate_commit_message(msg)\n    status = \"‚úì Valid\" if valid else f\"‚úó Invalid: {error}\"\n    print(f\"   '{msg}' ‚Üí {status}\")\n\n# Example 4: Interactive mode\nprint(\"\\n4. Interactive commit mode:\")\nprint(\"   (In real usage, this would prompt for input)\")\nprint(\"   helper.interactive_commit()\")\n\nprint(\"\\n=== Advanced Features ===\")\n\nclass AdvancedGitHelper(GitCommitHelper):\n    \"\"\"Extended Git helper with more features\"\"\"\n    \n    def get_commit_history(self, count: int = 5) -> list:\n        \"\"\"Get recent commit history\"\"\"\n        success, output = self.run_git_command(\n            ['log', f'-{count}', '--pretty=format:%h|%s|%an|%ar']\n        )\n        \n        if not success:\n            return []\n        \n        commits = []\n        for line in output.split('\\n'):\n            if line:\n                hash_val, msg, author, date = line.split('|')\n                commits.append({\n                    'hash': hash_val,\n                    'message': msg,\n                    'author': author,\n                    'date': date\n                })\n        return commits\n    \n    def show_commit_history(self, count: int = 5):\n        \"\"\"Display commit history\"\"\"\n        commits = self.get_commit_history(count)\n        \n        if not commits:\n            print(\"No commits yet\")\n            return\n        \n        print(f\"\\nRecent commits:\")\n        for commit in commits:\n            print(f\"  {commit['hash']} - {commit['message']}\")\n            print(f\"    by {commit['author']}, {commit['date']}\")\n\nadvanced = AdvancedGitHelper()\n\nprint(\"\\nShowing commit history:\")\nprint(\"(Would show actual commits in a real repository)\")\nprint(\"\\nExample output:\")\nprint(\"  abc1234 - Add user authentication\")\nprint(\"    by Alice, 2 hours ago\")\nprint(\"  def5678 - Fix login bug\")\nprint(\"    by Bob, 1 day ago\")",
      "explanation": "**Complete Git commit helper with:**\n\n**Features:**\n1. **Repository detection** - Check if Git initialized\n2. **Status display** - Show changed files with icons\n3. **Message validation** - Enforce quality commit messages\n4. **Interactive mode** - User-friendly prompts\n5. **Error handling** - Graceful failure messages\n\n**Validation rules:**\n- Minimum 10 characters\n- Maximum 100 characters\n- No generic messages (\"fix\", \"wip\")\n- Must be descriptive\n\n**Status symbols:**\n- M: Modified\n- A: Added\n- D: Deleted\n- ??: Untracked\n\n**Real-world usage:**\n- Pre-commit validation\n- Team workflow enforcement\n- Automated Git operations\n- CI/CD integration",
      "output": "=== Git Commit Helper ===\n\n=== Example Usage ===\n\n1. Checking if Git repository...\n   (Output depends on current directory)\n\n2. Repository status:\n   (Shows current branch and changed files)\n\n3. Testing commit message validation:\n   '' ‚Üí ‚úó Invalid: Commit message cannot be empty\n   'fix' ‚Üí ‚úó Invalid: Commit message too short (minimum 10 characters)\n   'Fix authentication bug' ‚Üí ‚úì Valid\n   'Add user profile page with...' ‚Üí ‚úó Invalid: Commit message too long (maximum 100 characters)\n   'Add comprehensive user authentication system' ‚Üí ‚úì Valid\n\n4. Interactive commit mode:\n   (In real usage, this would prompt for input)\n   helper.interactive_commit()\n\n=== Advanced Features ===\n\nShowing commit history:\n(Would show actual commits in a real repository)\n\nExample output:\n  abc1234 - Add user authentication\n    by Alice, 2 hours ago\n  def5678 - Fix login bug\n    by Bob, 1 day ago",
      "common_mistakes": [
        "Not checking if Git is installed before running commands",
        "Ignoring subprocess errors - always handle CalledProcessError",
        "Weak commit message validation - enforce quality",
        "Not stripping whitespace from user input",
        "Forgetting to stage files before committing"
      ]
    },
    {
      "type": "key_takeaways",
      "title": "Key Takeaways",
      "takeaways": [
        "**Git tracks all changes** - Every commit is a save point in history",
        "**Branches = safe experimentation** - Work on features without breaking main",
        "**Commit often, push daily** - Small, focused commits are better",
        "**Write clear commit messages** - Future you will thank you",
        "**Pull before push** - Always sync with remote first",
        "**Never commit secrets** - Use .gitignore for .env, passwords, keys",
        "**GitHub = collaboration platform** - Pull requests enable code review",
        "**Python + Git** - Automate Git operations with subprocess module"
      ]
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "What does 'git add .' do?",
        "options": [
          "Commit all changes",
          "Stage all changes for commit",
          "Push to remote repository",
          "Create a new branch"
        ],
        "correct_answer": 1,
        "explanation": "'git add .' stages all changes in the current directory, preparing them to be committed. It doesn't commit or push anything."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "What is the purpose of branches in Git?",
        "options": [
          "To delete old code",
          "To work on features independently without affecting main code",
          "To compress file sizes",
          "To share code with others"
        ],
        "correct_answer": 1,
        "explanation": "Branches allow you to develop features, fix bugs, or experiment in isolation from the main codebase. Changes can be merged back when ready."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "What should NEVER be committed to a Git repository?",
        "options": [
          "Python source files",
          "README.md",
          ".env files with secrets and API keys",
          "requirements.txt"
        ],
        "correct_answer": 2,
        "explanation": "Sensitive files like .env containing secrets, passwords, or API keys should never be committed. Use .gitignore to exclude them."
      }
    ]
  }
}
