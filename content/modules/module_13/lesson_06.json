{
  "lesson_id": 6,
  "module_id": 13,
  "title": "Mini-Project: Complete Blog API with Authentication",
  "duration": "60 minutes",
  "objectives": [
    "Build a complete REST API from scratch",
    "Implement JWT-based authentication",
    "Integrate SQLite database with proper relationships",
    "Add comprehensive input validation and error handling",
    "Write a complete test suite with pytest",
    "Document API endpoints with examples"
  ],
  "prerequisites": [
    "Module 13 Lessons 1-5"
  ],
  "sections": [
    {
      "title": "The Simplifier: Concept",
      "content": "# Building a Complete Blog API\n\nYou're going to build a real-world REST API for a blog platform - the kind that powers sites like Medium or Dev.to!\n\n## What We're Building\n\nImagine you're creating the backend for a blogging platform. Your API needs to:\n\n### 1. User Management\n- Users can register accounts\n- Users can log in and get an authentication token\n- Passwords are securely hashed\n- Each user has their own profile\n\n### 2. Blog Posts\n- Authenticated users can create posts\n- Anyone can read posts (no login needed)\n- Only the author can edit or delete their posts\n- Posts have titles, content, and timestamps\n\n### 3. Comments\n- Authenticated users can comment on posts\n- Comments belong to both a user and a post\n- Only the comment author can delete their comments\n- Anyone can read comments\n\n### 4. Security\n- JWT token authentication\n- Password hashing with PBKDF2\n- Input validation (no empty posts, valid emails)\n- Authorization (can't delete someone else's post)\n\n### 5. Testing\n- Comprehensive test suite\n- Test all endpoints\n- Test authentication and authorization\n- Test error cases\n\n## Real-World Analogy: Running a Library\n\nThink of your API as a library system:\n\n**Registration (POST /api/register):**\n- Like getting a library card\n- Need valid email and strong password\n- Once registered, you're in the system\n\n**Login (POST /api/login):**\n- Like showing your library card\n- Get a token (temporary pass) that proves who you are\n- Use this token for authenticated actions\n\n**Creating Posts (POST /api/posts):**\n- Like writing a book and adding it to the library\n- Need to be registered (have a library card)\n- Your name is on the book as the author\n\n**Reading Posts (GET /api/posts):**\n- Like browsing books on the shelf\n- Anyone can read, no library card needed\n- See all books in chronological order\n\n**Editing Posts (PUT /api/posts/:id):**\n- Like correcting typos in your own book\n- Only the original author can edit\n- Can't edit someone else's book!\n\n**Deleting Posts (DELETE /api/posts/:id):**\n- Like removing your book from the library\n- Only the author can remove their book\n- Once deleted, it's gone\n\n**Comments (POST /api/posts/:id/comments):**\n- Like writing a review of a book\n- Need a library card to write reviews\n- Reviews stay attached to the book\n- Only you can delete your own reviews\n\n## The Architecture\n\n```\n┌─────────────────────────────────────────┐\n│          CLIENT (Browser/App)           │\n└─────────────────┬───────────────────────┘\n                  │\n                  │ HTTP Requests (JSON)\n                  │\n┌─────────────────▼───────────────────────┐\n│         FLASK API (Your Code)           │\n│  ┌───────────────────────────────────┐  │\n│  │    Routes & Authentication        │  │\n│  │  /api/register  /api/login        │  │\n│  │  /api/posts     /api/comments     │  │\n│  └─────────────┬─────────────────────┘  │\n│                │                         │\n│  ┌─────────────▼─────────────────────┐  │\n│  │      Business Logic               │  │\n│  │  - Validate input                 │  │\n│  │  - Hash passwords                 │  │\n│  │  - Check authorization            │  │\n│  │  - Generate JWT tokens            │  │\n│  └─────────────┬─────────────────────┘  │\n│                │                         │\n│  ┌─────────────▼─────────────────────┐  │\n│  │      Database Layer               │  │\n│  │  SQLite with 3 tables:            │  │\n│  │  - users                          │  │\n│  │  - posts                          │  │\n│  │  - comments                       │  │\n│  └───────────────────────────────────┘  │\n└─────────────────────────────────────────┘\n```\n\n## Database Schema\n\n```sql\nusers\n├── id (PRIMARY KEY)\n├── email (UNIQUE)\n├── password (hashed)\n├── name\n└── created_at\n\nposts\n├── id (PRIMARY KEY)\n├── title\n├── content\n├── author_id (FOREIGN KEY → users.id)\n├── created_at\n└── updated_at\n\ncomments\n├── id (PRIMARY KEY)\n├── content\n├── post_id (FOREIGN KEY → posts.id)\n├── user_id (FOREIGN KEY → users.id)\n└── created_at\n```\n\n## API Endpoints We'll Build\n\n### Authentication\n```\nPOST   /api/register     Register new user\nPOST   /api/login        Login and get JWT token\n```\n\n### Posts\n```\nGET    /api/posts        Get all posts (public)\nGET    /api/posts/:id    Get single post (public)\nPOST   /api/posts        Create post (authenticated)\nPUT    /api/posts/:id    Update post (author only)\nDELETE /api/posts/:id    Delete post (author only)\n```\n\n### Comments\n```\nGET    /api/posts/:id/comments     Get post's comments (public)\nPOST   /api/posts/:id/comments     Add comment (authenticated)\nDELETE /api/comments/:id           Delete comment (author only)\n```\n\n## Key Features\n\n### 1. JWT Authentication\n```python\ntoken_required decorator:\n- Checks for Authorization header\n- Verifies JWT token\n- Adds current_user to request\n- Returns 401 if invalid/missing\n```\n\n### 2. Authorization Checks\n```python\nis_author decorator:\n- Verifies user is the post/comment author\n- Returns 403 Forbidden if not\n- Works with token_required\n```\n\n### 3. Input Validation\n```python\n- Email format validation\n- Password strength requirements\n- Empty title/content rejection\n- SQL injection prevention\n```\n\n### 4. Error Handling\n```python\n- 400 Bad Request: Invalid input\n- 401 Unauthorized: No/invalid token\n- 403 Forbidden: Not authorized\n- 404 Not Found: Resource doesn't exist\n- 409 Conflict: Duplicate email\n- 422 Unprocessable Entity: Validation failed\n```\n\n## The Development Process\n\nWe'll build this step-by-step:\n\n**Step 1:** Set up project structure and database\n**Step 2:** Implement user authentication (register/login)\n**Step 3:** Build post management (CRUD operations)\n**Step 4:** Add commenting functionality\n**Step 5:** Write comprehensive tests\n**Step 6:** Document the API\n\n## Why This Project Matters\n\nThis isn't a toy example - it's a real REST API architecture used by production applications:\n\n1. **JWT Authentication** - Industry standard for APIs\n2. **RBAC** (Role-Based Access Control) - Only authors can edit their content\n3. **Relational Data** - Users → Posts → Comments\n4. **RESTful Design** - Follows REST conventions\n5. **Comprehensive Testing** - Production-ready test coverage\n6. **Security Best Practices** - Password hashing, input validation, SQL injection protection\n\nBy the end, you'll have built something you can actually deploy and use!\n\n## Success Criteria\n\nYour API is complete when:\n- ✅ Users can register and login\n- ✅ Authenticated users can create/edit/delete their posts\n- ✅ Anyone can read posts without authentication\n- ✅ Authenticated users can comment on posts\n- ✅ Users can only edit/delete their own content\n- ✅ All passwords are hashed\n- ✅ JWT tokens work correctly\n- ✅ Input validation prevents bad data\n- ✅ Tests cover all major functionality\n- ✅ API is documented with examples\n\nLet's build it!"
    },
    {
      "title": "The Coder: Code Example",
      "content": "# Complete Blog API Implementation\n\n## Project Structure\n\n```\nblog_api/\n├── app.py              # Main application\n├── conftest.py         # Test configuration\n├── test_blog_api.py    # Test suite\n├── requirements.txt    # Dependencies\n└── README.md          # API documentation\n```\n\n## Step 1: Install Dependencies\n\n```bash\n# requirements.txt\nFlask==3.0.0\nPyJWT==2.8.0\npytest==7.4.3\npytest-flask==1.3.0\n```\n\n```bash\npip install -r requirements.txt\n```\n\n## Step 2: Main Application (app.py)\n\n```python\n# app.py\nfrom flask import Flask, request, jsonify\nimport sqlite3\nimport hashlib\nimport os\nimport jwt\nimport re\nfrom functools import wraps\nfrom datetime import datetime, timedelta\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-secret-key-change-in-production'\napp.config['DATABASE'] = 'blog.db'\n\n# ==================== Database Setup ====================\n\ndef get_db():\n    \"\"\"Get database connection.\"\"\"\n    db = sqlite3.connect(app.config['DATABASE'])\n    db.row_factory = sqlite3.Row\n    return db\n\ndef init_db():\n    \"\"\"Initialize database with tables.\"\"\"\n    with app.app_context():\n        db = get_db()\n        \n        # Users table\n        db.execute('''CREATE TABLE IF NOT EXISTS users\n                      (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                       email TEXT UNIQUE NOT NULL,\n                       password BLOB NOT NULL,\n                       name TEXT NOT NULL,\n                       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n        \n        # Posts table\n        db.execute('''CREATE TABLE IF NOT EXISTS posts\n                      (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                       title TEXT NOT NULL,\n                       content TEXT NOT NULL,\n                       author_id INTEGER NOT NULL,\n                       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                       FOREIGN KEY (author_id) REFERENCES users(id))''')\n        \n        # Comments table\n        db.execute('''CREATE TABLE IF NOT EXISTS comments\n                      (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                       content TEXT NOT NULL,\n                       post_id INTEGER NOT NULL,\n                       user_id INTEGER NOT NULL,\n                       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                       FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,\n                       FOREIGN KEY (user_id) REFERENCES users(id))''')\n        \n        db.commit()\n\n# ==================== Utility Functions ====================\n\ndef hash_password(password):\n    \"\"\"Hash password using PBKDF2.\"\"\"\n    salt = os.urandom(32)\n    pwdhash = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'), salt, 100000)\n    return salt + pwdhash\n\ndef verify_password(stored_password, provided_password):\n    \"\"\"Verify password against stored hash.\"\"\"\n    salt = stored_password[:32]\n    stored_hash = stored_password[32:]\n    pwdhash = hashlib.pbkdf2_hmac('sha256', provided_password.encode('utf-8'), salt, 100000)\n    return pwdhash == stored_hash\n\ndef validate_email(email):\n    \"\"\"Validate email format.\"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\ndef validate_password(password):\n    \"\"\"Validate password strength.\"\"\"\n    if len(password) < 8:\n        return False, \"Password must be at least 8 characters\"\n    if not any(c.isupper() for c in password):\n        return False, \"Password must contain an uppercase letter\"\n    if not any(c.islower() for c in password):\n        return False, \"Password must contain a lowercase letter\"\n    if not any(c.isdigit() for c in password):\n        return False, \"Password must contain a digit\"\n    return True, \"Valid\"\n\ndef create_token(user_id):\n    \"\"\"Create JWT token for user.\"\"\"\n    payload = {\n        'user_id': user_id,\n        'exp': datetime.utcnow() + timedelta(days=1),\n        'iat': datetime.utcnow()\n    }\n    return jwt.encode(payload, app.config['SECRET_KEY'], algorithm='HS256')\n\n# ==================== Authentication Decorators ====================\n\ndef token_required(f):\n    \"\"\"Decorator to require valid JWT token.\"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = request.headers.get('Authorization')\n        \n        if not token:\n            return jsonify({'error': 'Token is missing'}), 401\n        \n        try:\n            # Remove 'Bearer ' prefix if present\n            if token.startswith('Bearer '):\n                token = token[7:]\n            \n            payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])\n            request.current_user = payload\n        except jwt.ExpiredSignatureError:\n            return jsonify({'error': 'Token has expired'}), 401\n        except jwt.InvalidTokenError:\n            return jsonify({'error': 'Invalid token'}), 401\n        \n        return f(*args, **kwargs)\n    \n    return decorated\n\ndef is_author(resource_type='post'):\n    \"\"\"Decorator to verify user is the author of the resource.\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            db = get_db()\n            user_id = request.current_user['user_id']\n            \n            if resource_type == 'post':\n                post_id = kwargs.get('post_id')\n                post = db.execute('SELECT author_id FROM posts WHERE id = ?', (post_id,)).fetchone()\n                \n                if not post:\n                    return jsonify({'error': 'Post not found'}), 404\n                \n                if post['author_id'] != user_id:\n                    return jsonify({'error': 'You are not authorized to modify this post'}), 403\n            \n            elif resource_type == 'comment':\n                comment_id = kwargs.get('comment_id')\n                comment = db.execute('SELECT user_id FROM comments WHERE id = ?', (comment_id,)).fetchone()\n                \n                if not comment:\n                    return jsonify({'error': 'Comment not found'}), 404\n                \n                if comment['user_id'] != user_id:\n                    return jsonify({'error': 'You are not authorized to modify this comment'}), 403\n            \n            return f(*args, **kwargs)\n        \n        return decorated\n    return decorator\n\n# ==================== Authentication Routes ====================\n\n@app.route('/api/register', methods=['POST'])\ndef register():\n    \"\"\"Register a new user.\"\"\"\n    data = request.get_json()\n    \n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    email = data.get('email', '').strip()\n    password = data.get('password', '')\n    name = data.get('name', '').strip()\n    \n    # Validate required fields\n    if not email or not password or not name:\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    # Validate email\n    if not validate_email(email):\n        return jsonify({'error': 'Invalid email format'}), 400\n    \n    # Validate password\n    is_valid, message = validate_password(password)\n    if not is_valid:\n        return jsonify({'error': message}), 422\n    \n    # Check if user exists\n    db = get_db()\n    existing_user = db.execute('SELECT id FROM users WHERE email = ?', (email,)).fetchone()\n    if existing_user:\n        return jsonify({'error': 'Email already registered'}), 409\n    \n    # Create user\n    hashed_password = hash_password(password)\n    cursor = db.execute('INSERT INTO users (email, password, name) VALUES (?, ?, ?)',\n                       (email, hashed_password, name))\n    db.commit()\n    \n    # Get created user\n    user = db.execute('SELECT id, email, name, created_at FROM users WHERE id = ?',\n                     (cursor.lastrowid,)).fetchone()\n    \n    return jsonify({\n        'id': user['id'],\n        'email': user['email'],\n        'name': user['name'],\n        'created_at': user['created_at']\n    }), 201\n\n@app.route('/api/login', methods=['POST'])\ndef login():\n    \"\"\"Login user and return JWT token.\"\"\"\n    data = request.get_json()\n    \n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    email = data.get('email', '').strip()\n    password = data.get('password', '')\n    \n    if not email or not password:\n        return jsonify({'error': 'Missing email or password'}), 400\n    \n    # Find user\n    db = get_db()\n    user = db.execute('SELECT * FROM users WHERE email = ?', (email,)).fetchone()\n    \n    if not user or not verify_password(user['password'], password):\n        return jsonify({'error': 'Invalid credentials'}), 401\n    \n    # Create token\n    token = create_token(user['id'])\n    \n    return jsonify({\n        'token': token,\n        'user': {\n            'id': user['id'],\n            'email': user['email'],\n            'name': user['name']\n        }\n    })\n\n# ==================== Post Routes ====================\n\n@app.route('/api/posts', methods=['GET'])\ndef get_posts():\n    \"\"\"Get all posts (public).\"\"\"\n    db = get_db()\n    posts = db.execute('''SELECT p.*, u.name as author_name, u.email as author_email\n                          FROM posts p\n                          JOIN users u ON p.author_id = u.id\n                          ORDER BY p.created_at DESC''').fetchall()\n    \n    return jsonify({\n        'posts': [{\n            'id': post['id'],\n            'title': post['title'],\n            'content': post['content'],\n            'author': {\n                'id': post['author_id'],\n                'name': post['author_name'],\n                'email': post['author_email']\n            },\n            'created_at': post['created_at'],\n            'updated_at': post['updated_at']\n        } for post in posts]\n    })\n\n@app.route('/api/posts/<int:post_id>', methods=['GET'])\ndef get_post(post_id):\n    \"\"\"Get single post (public).\"\"\"\n    db = get_db()\n    post = db.execute('''SELECT p.*, u.name as author_name, u.email as author_email\n                         FROM posts p\n                         JOIN users u ON p.author_id = u.id\n                         WHERE p.id = ?''', (post_id,)).fetchone()\n    \n    if not post:\n        return jsonify({'error': 'Post not found'}), 404\n    \n    return jsonify({\n        'id': post['id'],\n        'title': post['title'],\n        'content': post['content'],\n        'author': {\n            'id': post['author_id'],\n            'name': post['author_name'],\n            'email': post['author_email']\n        },\n        'created_at': post['created_at'],\n        'updated_at': post['updated_at']\n    })\n\n@app.route('/api/posts', methods=['POST'])\n@token_required\ndef create_post():\n    \"\"\"Create a new post (authenticated).\"\"\"\n    data = request.get_json()\n    \n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    title = data.get('title', '').strip()\n    content = data.get('content', '').strip()\n    \n    # Validate\n    if not title or not content:\n        return jsonify({'error': 'Title and content are required'}), 400\n    \n    if len(title) > 200:\n        return jsonify({'error': 'Title too long (max 200 characters)'}), 400\n    \n    # Create post\n    db = get_db()\n    user_id = request.current_user['user_id']\n    cursor = db.execute('INSERT INTO posts (title, content, author_id) VALUES (?, ?, ?)',\n                       (title, content, user_id))\n    db.commit()\n    \n    # Get created post\n    post = db.execute('''SELECT p.*, u.name as author_name, u.email as author_email\n                         FROM posts p\n                         JOIN users u ON p.author_id = u.id\n                         WHERE p.id = ?''', (cursor.lastrowid,)).fetchone()\n    \n    return jsonify({\n        'id': post['id'],\n        'title': post['title'],\n        'content': post['content'],\n        'author': {\n            'id': post['author_id'],\n            'name': post['author_name'],\n            'email': post['author_email']\n        },\n        'created_at': post['created_at'],\n        'updated_at': post['updated_at']\n    }), 201\n\n@app.route('/api/posts/<int:post_id>', methods=['PUT'])\n@token_required\n@is_author('post')\ndef update_post(post_id):\n    \"\"\"Update a post (author only).\"\"\"\n    data = request.get_json()\n    \n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    title = data.get('title', '').strip()\n    content = data.get('content', '').strip()\n    \n    # Validate\n    if not title or not content:\n        return jsonify({'error': 'Title and content are required'}), 400\n    \n    if len(title) > 200:\n        return jsonify({'error': 'Title too long (max 200 characters)'}), 400\n    \n    # Update post\n    db = get_db()\n    db.execute('''UPDATE posts \n                  SET title = ?, content = ?, updated_at = CURRENT_TIMESTAMP\n                  WHERE id = ?''', (title, content, post_id))\n    db.commit()\n    \n    # Get updated post\n    post = db.execute('''SELECT p.*, u.name as author_name, u.email as author_email\n                         FROM posts p\n                         JOIN users u ON p.author_id = u.id\n                         WHERE p.id = ?''', (post_id,)).fetchone()\n    \n    return jsonify({\n        'id': post['id'],\n        'title': post['title'],\n        'content': post['content'],\n        'author': {\n            'id': post['author_id'],\n            'name': post['author_name'],\n            'email': post['author_email']\n        },\n        'created_at': post['created_at'],\n        'updated_at': post['updated_at']\n    })\n\n@app.route('/api/posts/<int:post_id>', methods=['DELETE'])\n@token_required\n@is_author('post')\ndef delete_post(post_id):\n    \"\"\"Delete a post (author only).\"\"\"\n    db = get_db()\n    db.execute('DELETE FROM posts WHERE id = ?', (post_id,))\n    db.commit()\n    \n    return jsonify({'message': 'Post deleted successfully'})\n\n# ==================== Comment Routes ====================\n\n@app.route('/api/posts/<int:post_id>/comments', methods=['GET'])\ndef get_comments(post_id):\n    \"\"\"Get all comments for a post (public).\"\"\"\n    db = get_db()\n    \n    # Check if post exists\n    post = db.execute('SELECT id FROM posts WHERE id = ?', (post_id,)).fetchone()\n    if not post:\n        return jsonify({'error': 'Post not found'}), 404\n    \n    # Get comments\n    comments = db.execute('''SELECT c.*, u.name as author_name, u.email as author_email\n                            FROM comments c\n                            JOIN users u ON c.user_id = u.id\n                            WHERE c.post_id = ?\n                            ORDER BY c.created_at DESC''', (post_id,)).fetchall()\n    \n    return jsonify({\n        'comments': [{\n            'id': comment['id'],\n            'content': comment['content'],\n            'author': {\n                'id': comment['user_id'],\n                'name': comment['author_name'],\n                'email': comment['author_email']\n            },\n            'created_at': comment['created_at']\n        } for comment in comments]\n    })\n\n@app.route('/api/posts/<int:post_id>/comments', methods=['POST'])\n@token_required\ndef create_comment(post_id):\n    \"\"\"Create a comment on a post (authenticated).\"\"\"\n    db = get_db()\n    \n    # Check if post exists\n    post = db.execute('SELECT id FROM posts WHERE id = ?', (post_id,)).fetchone()\n    if not post:\n        return jsonify({'error': 'Post not found'}), 404\n    \n    data = request.get_json()\n    \n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    content = data.get('content', '').strip()\n    \n    if not content:\n        return jsonify({'error': 'Content is required'}), 400\n    \n    # Create comment\n    user_id = request.current_user['user_id']\n    cursor = db.execute('INSERT INTO comments (content, post_id, user_id) VALUES (?, ?, ?)',\n                       (content, post_id, user_id))\n    db.commit()\n    \n    # Get created comment\n    comment = db.execute('''SELECT c.*, u.name as author_name, u.email as author_email\n                           FROM comments c\n                           JOIN users u ON c.user_id = u.id\n                           WHERE c.id = ?''', (cursor.lastrowid,)).fetchone()\n    \n    return jsonify({\n        'id': comment['id'],\n        'content': comment['content'],\n        'post_id': comment['post_id'],\n        'author': {\n            'id': comment['user_id'],\n            'name': comment['author_name'],\n            'email': comment['author_email']\n        },\n        'created_at': comment['created_at']\n    }), 201\n\n@app.route('/api/comments/<int:comment_id>', methods=['DELETE'])\n@token_required\n@is_author('comment')\ndef delete_comment(comment_id):\n    \"\"\"Delete a comment (author only).\"\"\"\n    db = get_db()\n    db.execute('DELETE FROM comments WHERE id = ?', (comment_id,))\n    db.commit()\n    \n    return jsonify({'message': 'Comment deleted successfully'})\n\n# ==================== Main ====================\n\nif __name__ == '__main__':\n    init_db()\n    app.run(debug=True)\n```\n\n## Step 3: Run the Application\n\n```bash\npython app.py\n```\n\n## Step 4: Test the API Manually\n\n### Register a User\n```bash\ncurl -X POST http://localhost:5000/api/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"alice@example.com\",\"password\":\"SecurePass123\",\"name\":\"Alice\"}'\n```\n\n### Login\n```bash\ncurl -X POST http://localhost:5000/api/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"alice@example.com\",\"password\":\"SecurePass123\"}'\n```\n\nResponse:\n```json\n{\n  \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...\",\n  \"user\": {\n    \"id\": 1,\n    \"email\": \"alice@example.com\",\n    \"name\": \"Alice\"\n  }\n}\n```\n\n### Create a Post (use the token from login)\n```bash\ncurl -X POST http://localhost:5000/api/posts \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN_HERE\" \\\n  -d '{\"title\":\"My First Post\",\"content\":\"This is my first blog post!\"}'\n```\n\n### Get All Posts (no authentication needed)\n```bash\ncurl http://localhost:5000/api/posts\n```\n\n### Add a Comment\n```bash\ncurl -X POST http://localhost:5000/api/posts/1/comments \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer YOUR_TOKEN_HERE\" \\\n  -d '{\"content\":\"Great post!\"}'\n```\n\n## Output Examples\n\n**GET /api/posts:**\n```json\n{\n  \"posts\": [\n    {\n      \"id\": 1,\n      \"title\": \"My First Post\",\n      \"content\": \"This is my first blog post!\",\n      \"author\": {\n        \"id\": 1,\n        \"name\": \"Alice\",\n        \"email\": \"alice@example.com\"\n      },\n      \"created_at\": \"2025-01-15 10:30:00\",\n      \"updated_at\": \"2025-01-15 10:30:00\"\n    }\n  ]\n}\n```\n\n**GET /api/posts/1/comments:**\n```json\n{\n  \"comments\": [\n    {\n      \"id\": 1,\n      \"content\": \"Great post!\",\n      \"author\": {\n        \"id\": 1,\n        \"name\": \"Alice\",\n        \"email\": \"alice@example.com\"\n      },\n      \"created_at\": \"2025-01-15 10:35:00\"\n    }\n  ]\n}\n```"
    },
    {
      "title": "The Simplifier: Syntax Breakdown",
      "content": "# Understanding the Blog API Code\n\nLet's break down the key components of our Blog API.\n\n## 1. Database Relationships\n\n### Foreign Keys\n\n```python\ndb.execute('''CREATE TABLE IF NOT EXISTS posts\n              (id INTEGER PRIMARY KEY AUTOINCREMENT,\n               title TEXT NOT NULL,\n               content TEXT NOT NULL,\n               author_id INTEGER NOT NULL,\n               FOREIGN KEY (author_id) REFERENCES users(id))''')\n```\n\n**What this means:**\n```python\nauthor_id INTEGER NOT NULL,\n# This column stores which user wrote the post\n\nFOREIGN KEY (author_id) REFERENCES users(id)\n# author_id must match an id from the users table\n# Can't create a post with author_id=999 if user 999 doesn't exist\n```\n\n**Real-world analogy:**\n- Like a library book having the author's library card number\n- The card number must belong to a real registered member\n- Can't attribute a book to a non-existent member\n\n### Cascade Deletes\n\n```python\nFOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE\n```\n\n**What this means:**\n```python\nON DELETE CASCADE\n# If a post is deleted, automatically delete its comments\n# Like: if you remove a book, remove all reviews of that book too\n```\n\n**Without CASCADE:**\n```python\n# Delete post\nDELETE FROM posts WHERE id = 1\n# Error! Comments still reference this post\n# Must manually delete comments first\n```\n\n**With CASCADE:**\n```python\n# Delete post\nDELETE FROM posts WHERE id = 1\n# Success! Comments automatically deleted\n```\n\n## 2. JWT Authentication Decorator\n\n```python\ndef token_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = request.headers.get('Authorization')\n        \n        if not token:\n            return jsonify({'error': 'Token is missing'}), 401\n        \n        try:\n            if token.startswith('Bearer '):\n                token = token[7:]\n            \n            payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])\n            request.current_user = payload\n        except jwt.ExpiredSignatureError:\n            return jsonify({'error': 'Token has expired'}), 401\n        except jwt.InvalidTokenError:\n            return jsonify({'error': 'Invalid token'}), 401\n        \n        return f(*args, **kwargs)\n    \n    return decorated\n```\n\n**Breaking it down:**\n\n```python\ndef token_required(f):\n    # f is the function being decorated\n    # Example: create_post function\n```\n\n```python\n@wraps(f)\ndef decorated(*args, **kwargs):\n    # @wraps preserves original function's metadata\n    # decorated is the wrapper function that adds authentication\n```\n\n```python\ntoken = request.headers.get('Authorization')\n# Get token from HTTP header\n# Client sends: Authorization: Bearer eyJ0eXAi...\n```\n\n```python\nif token.startswith('Bearer '):\n    token = token[7:]\n# Remove 'Bearer ' prefix (7 characters)\n# 'Bearer eyJ0eXAi...' → 'eyJ0eXAi...'\n```\n\n```python\npayload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])\n# Decode and verify JWT token\n# If valid, payload = {'user_id': 1, 'exp': ..., 'iat': ...}\n# If invalid/expired, raises exception\n```\n\n```python\nrequest.current_user = payload\n# Attach user info to request object\n# Now the decorated function can access request.current_user\n```\n\n**Usage:**\n\n```python\n@app.route('/api/posts', methods=['POST'])\n@token_required  # ← Decorator applied here\ndef create_post():\n    # This only runs if token is valid\n    user_id = request.current_user['user_id']\n    # Can access authenticated user's ID\n```\n\n## 3. Authorization Decorator (is_author)\n\n```python\ndef is_author(resource_type='post'):\n    def decorator(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            db = get_db()\n            user_id = request.current_user['user_id']\n            \n            if resource_type == 'post':\n                post_id = kwargs.get('post_id')\n                post = db.execute('SELECT author_id FROM posts WHERE id = ?', \n                                 (post_id,)).fetchone()\n                \n                if not post:\n                    return jsonify({'error': 'Post not found'}), 404\n                \n                if post['author_id'] != user_id:\n                    return jsonify({'error': 'Not authorized'}), 403\n            \n            return f(*args, **kwargs)\n        return decorated\n    return decorator\n```\n\n**Breaking it down:**\n\n```python\ndef is_author(resource_type='post'):\n    # Factory function - creates custom decorator\n    # resource_type can be 'post' or 'comment'\n```\n\n```python\nuser_id = request.current_user['user_id']\n# Get current authenticated user's ID\n# This comes from @token_required decorator\n```\n\n```python\npost_id = kwargs.get('post_id')\n# Get post_id from URL parameter\n# /api/posts/5 → post_id = 5\n```\n\n```python\npost = db.execute('SELECT author_id FROM posts WHERE id = ?', \n                 (post_id,)).fetchone()\n# Get the post's author_id from database\n```\n\n```python\nif post['author_id'] != user_id:\n    return jsonify({'error': 'Not authorized'}), 403\n# Check: is current user the author?\n# If not, return 403 Forbidden\n```\n\n**Usage:**\n\n```python\n@app.route('/api/posts/<int:post_id>', methods=['DELETE'])\n@token_required          # ← First: check token is valid\n@is_author('post')       # ← Second: check user owns the post\ndef delete_post(post_id):\n    # Only runs if:\n    # 1. User is authenticated (has valid token)\n    # 2. User is the post's author\n```\n\n## 4. SQL Joins for Related Data\n\n```python\nposts = db.execute('''SELECT p.*, u.name as author_name, u.email as author_email\n                      FROM posts p\n                      JOIN users u ON p.author_id = u.id\n                      ORDER BY p.created_at DESC''').fetchall()\n```\n\n**Breaking it down:**\n\n```sql\nSELECT p.*, u.name as author_name, u.email as author_email\n```\n- `p.*` - All columns from posts table\n- `u.name as author_name` - User's name, renamed for clarity\n- `u.email as author_email` - User's email, renamed\n\n```sql\nFROM posts p\n```\n- Use `posts` table, give it alias `p` (shorthand)\n\n```sql\nJOIN users u ON p.author_id = u.id\n```\n- Join with `users` table (alias `u`)\n- Match where `posts.author_id` equals `users.id`\n- Get author information for each post\n\n```sql\nORDER BY p.created_at DESC\n```\n- Sort by creation date, newest first\n\n**Result:**\n```python\n# Each post now has author info!\n[\n  {\n    'id': 1,\n    'title': 'My Post',\n    'author_id': 5,\n    'author_name': 'Alice',      # ← From users table\n    'author_email': 'alice@...'  # ← From users table\n  }\n]\n```\n\n**Without JOIN (inefficient):**\n```python\n# Get all posts\nposts = db.execute('SELECT * FROM posts').fetchall()\n\n# For each post, get author info (N+1 query problem!)\nfor post in posts:\n    author = db.execute('SELECT * FROM users WHERE id = ?', \n                       (post['author_id'],)).fetchone()\n    # Lots of separate queries - slow!\n```\n\n**With JOIN (efficient):**\n```python\n# One query gets everything\nposts = db.execute('''SELECT p.*, u.name as author_name\n                      FROM posts p\n                      JOIN users u ON p.author_id = u.id''').fetchall()\n# Fast! All data in one query\n```\n\n## 5. Decorator Stacking Order\n\n```python\n@app.route('/api/posts/<int:post_id>', methods=['PUT'])\n@token_required\n@is_author('post')\ndef update_post(post_id):\n    # Function body\n```\n\n**Execution order (bottom to top):**\n\n1. **@app.route** - Defines URL endpoint\n2. **@token_required** - Checks authentication\n3. **@is_author** - Checks authorization\n4. **update_post** - Actual function runs\n\n**Think of it like security checkpoints:**\n\n```\nRequest → Route → Token Check → Author Check → Function\n          ↓         ↓              ↓             ↓\n         \"Is this   \"Do you have   \"Is this      \"Do the\n          the right  valid ID?\"     your post?\"   update\"\n          endpoint?\"\n```\n\n**If any checkpoint fails, request is rejected:**\n\n```python\n# Wrong URL → 404 Not Found (route doesn't match)\n# No token → 401 Unauthorized (token_required fails)\n# Not author → 403 Forbidden (is_author fails)\n# All pass → Function runs!\n```\n\n## 6. Request Flow Example\n\n### Creating a Post\n\n```python\n@app.route('/api/posts', methods=['POST'])\n@token_required\ndef create_post():\n    data = request.get_json()\n    user_id = request.current_user['user_id']\n    # ...\n```\n\n**Step-by-step:**\n\n1. **Client sends request:**\n```\nPOST /api/posts\nHeaders:\n  Authorization: Bearer eyJ0eXAi...\n  Content-Type: application/json\nBody:\n  {\"title\": \"My Post\", \"content\": \"Hello world!\"}\n```\n\n2. **@token_required runs:**\n```python\n# Extract token from Authorization header\ntoken = \"eyJ0eXAi...\"\n\n# Decode and verify\npayload = jwt.decode(token, SECRET_KEY)\n# payload = {'user_id': 5, 'exp': ...}\n\n# Attach to request\nrequest.current_user = payload\n```\n\n3. **create_post() runs:**\n```python\n# Get JSON data from request body\ndata = request.get_json()\n# data = {'title': 'My Post', 'content': 'Hello world!'}\n\n# Get authenticated user's ID\nuser_id = request.current_user['user_id']  # = 5\n\n# Create post in database\ndb.execute('INSERT INTO posts (title, content, author_id) VALUES (?, ?, ?)',\n          ('My Post', 'Hello world!', 5))\n```\n\n4. **Response sent:**\n```json\n{\n  \"id\": 10,\n  \"title\": \"My Post\",\n  \"content\": \"Hello world!\",\n  \"author\": {\n    \"id\": 5,\n    \"name\": \"Alice\"\n  }\n}\n```\n\n## Key Takeaways\n\n1. **Foreign keys** link tables and ensure data integrity\n2. **CASCADE** automatically cleans up related data\n3. **Decorators** add authentication/authorization without repeating code\n4. **JOINs** fetch related data efficiently in one query\n5. **Decorator order** matters - apply from general to specific\n6. **request.current_user** makes user info available after authentication"
    },
    {
      "title": "The Coder: Interactive Exercise",
      "content": "# Exercise: Complete the Blog API Test Suite\n\nNow it's your turn! Write a comprehensive test suite for the Blog API.\n\n## Your Task\n\nCreate `test_blog_api.py` with tests for all endpoints.\n\n## Part 1: Setup (conftest.py)\n\nFirst, create the test configuration:\n\n```python\n# conftest.py\nimport pytest\nimport os\nimport tempfile\nfrom app import app as flask_app, init_db\n\n@pytest.fixture\ndef app():\n    \"\"\"Create test app with temporary database.\"\"\"\n    # TODO: Create temporary database\n    # TODO: Configure app for testing\n    # TODO: Initialize database\n    # TODO: Yield app\n    # TODO: Cleanup\n    pass\n\n@pytest.fixture\ndef client(app):\n    \"\"\"Create test client.\"\"\"\n    # TODO: Return test client\n    pass\n\n@pytest.fixture\ndef registered_user(client):\n    \"\"\"Create and return a registered user.\"\"\"\n    # TODO: Register a user\n    # TODO: Return user data (email, password, response data)\n    pass\n\n@pytest.fixture\ndef auth_headers(client, registered_user):\n    \"\"\"Get authentication headers with valid JWT token.\"\"\"\n    # TODO: Login with registered_user credentials\n    # TODO: Extract token from response\n    # TODO: Return headers dict with Authorization\n    pass\n\n@pytest.fixture\ndef sample_post(client, auth_headers):\n    \"\"\"Create a sample post.\"\"\"\n    # TODO: Create a post using auth_headers\n    # TODO: Return post data\n    pass\n```\n\n## Part 2: Authentication Tests\n\nWrite these tests in a `TestAuthentication` class:\n\n### Test 1: Successful Registration\n```python\ndef test_successful_registration(self, client):\n    \"\"\"Test that valid registration works.\"\"\"\n    # Register with valid data\n    # Check status code is 201\n    # Check response contains id, email, name\n    # Check response does NOT contain password\n```\n\n### Test 2: Duplicate Email Rejected\n```python\ndef test_duplicate_email_rejected(self, client):\n    # Register first user\n    # Try to register with same email\n    # Check status code is 409\n    # Check error message\n```\n\n### Test 3: Invalid Email Rejected\n```python\ndef test_invalid_email_rejected(self, client):\n    # Try to register with invalid emails:\n    # - 'notanemail'\n    # - 'missing@domain'\n    # - '@nodomain.com'\n    # Check each returns 400\n```\n\n### Test 4: Weak Password Rejected\n```python\ndef test_weak_password_rejected(self, client):\n    # Try passwords:\n    # - 'short' (too short)\n    # - 'nouppercase1' (no uppercase)\n    # - 'NOLOWERCASE1' (no lowercase)\n    # - 'NoDigitsHere' (no digit)\n    # Check each returns 422\n```\n\n### Test 5: Successful Login\n```python\ndef test_successful_login(self, client, registered_user):\n    # Login with registered_user credentials\n    # Check status code is 200\n    # Check response contains token and user info\n```\n\n### Test 6: Invalid Credentials\n```python\ndef test_invalid_credentials(self, client, registered_user):\n    # Try login with wrong password\n    # Check status code is 401\n    # Try login with wrong email\n    # Check status code is 401\n```\n\n## Part 3: Post Tests\n\nWrite these tests in a `TestPosts` class:\n\n### Test 7: Create Post (Authenticated)\n```python\ndef test_create_post_authenticated(self, client, auth_headers):\n    # Create post with valid token\n    # Check status code is 201\n    # Check post data in response\n```\n\n### Test 8: Create Post (No Auth)\n```python\ndef test_create_post_no_auth(self, client):\n    # Try to create post without token\n    # Check status code is 401\n```\n\n### Test 9: Get All Posts (Public)\n```python\ndef test_get_all_posts_public(self, client, sample_post):\n    # Get all posts without authentication\n    # Check status code is 200\n    # Check posts array exists\n    # Check sample_post is in results\n```\n\n### Test 10: Get Single Post\n```python\ndef test_get_single_post(self, client, sample_post):\n    # Get specific post by ID\n    # Check status code is 200\n    # Check post data matches\n```\n\n### Test 11: Update Own Post\n```python\ndef test_update_own_post(self, client, auth_headers, sample_post):\n    # Update post with new title and content\n    # Check status code is 200\n    # Check updated data returned\n    # Verify updated_at changed\n```\n\n### Test 12: Update Someone Else's Post (Forbidden)\n```python\ndef test_update_others_post_forbidden(self, client, sample_post):\n    # Register a second user\n    # Login as second user\n    # Try to update sample_post (belongs to first user)\n    # Check status code is 403\n```\n\n### Test 13: Delete Own Post\n```python\ndef test_delete_own_post(self, client, auth_headers, sample_post):\n    # Delete sample_post\n    # Check status code is 200\n    # Try to GET deleted post\n    # Check returns 404\n```\n\n### Test 14: Delete Someone Else's Post (Forbidden)\n```python\ndef test_delete_others_post_forbidden(self, client, sample_post):\n    # Register second user and login\n    # Try to delete sample_post\n    # Check status code is 403\n```\n\n## Part 4: Comment Tests\n\nWrite these tests in a `TestComments` class:\n\n### Test 15: Add Comment to Post\n```python\ndef test_add_comment_authenticated(self, client, auth_headers, sample_post):\n    # Add comment to sample_post\n    # Check status code is 201\n    # Check comment data in response\n```\n\n### Test 16: Add Comment (No Auth)\n```python\ndef test_add_comment_no_auth(self, client, sample_post):\n    # Try to comment without authentication\n    # Check status code is 401\n```\n\n### Test 17: Get Post Comments\n```python\ndef test_get_post_comments(self, client, auth_headers, sample_post):\n    # Add 2 comments to sample_post\n    # Get comments for post\n    # Check status code is 200\n    # Check 2 comments returned\n```\n\n### Test 18: Delete Own Comment\n```python\ndef test_delete_own_comment(self, client, auth_headers, sample_post):\n    # Create comment\n    # Delete the comment\n    # Check status code is 200\n    # Verify comment is gone\n```\n\n### Test 19: Delete Someone Else's Comment (Forbidden)\n```python\ndef test_delete_others_comment_forbidden(self, client, auth_headers, sample_post):\n    # User 1 creates comment\n    # User 2 tries to delete it\n    # Check status code is 403\n```\n\n### Test 20: Comments Deleted with Post\n```python\ndef test_comments_cascade_delete(self, client, auth_headers, sample_post):\n    # Add comments to sample_post\n    # Delete the post\n    # Try to get post's comments\n    # Should return 404 (post doesn't exist)\n```\n\n## Part 5: Integration Tests\n\nWrite these tests in a `TestWorkflows` class:\n\n### Test 21: Complete Blog Workflow\n```python\ndef test_complete_blog_workflow(self, client):\n    # Register user\n    # Login\n    # Create post\n    # Add comment\n    # Update post\n    # Delete comment\n    # Delete post\n    # Verify all operations successful\n```\n\n### Test 22: Multiple Users, Multiple Posts\n```python\ndef test_multiple_users_posts(self, client):\n    # Register 2 users\n    # Each creates 2 posts\n    # User 1 comments on User 2's post\n    # User 2 comments on User 1's post\n    # Get all posts - should see 4\n    # User 1 can only delete their own posts\n    # User 2 can only delete their own posts\n```\n\n## Running Your Tests\n\n```bash\n# Run all tests\npytest test_blog_api.py -v\n\n# Run specific test class\npytest test_blog_api.py::TestAuthentication -v\n\n# Run with coverage\npytest test_blog_api.py --cov=app --cov-report=html\n```\n\n## Success Criteria\n\nYour test suite should:\n- ✅ Have at least 22 tests\n- ✅ All tests pass\n- ✅ Cover authentication, posts, comments\n- ✅ Test both success and failure cases\n- ✅ Test authorization (can't modify others' content)\n- ✅ Achieve 90%+ code coverage\n\n## Hints\n\n<details>\n<summary>Hint 1: Creating auth_headers fixture</summary>\n\n```python\n@pytest.fixture\ndef auth_headers(client, registered_user):\n    # Login\n    response = client.post('/api/login', json={\n        'email': registered_user['email'],\n        'password': registered_user['password']\n    })\n    token = response.get_json()['token']\n    \n    # Return headers with token\n    return {'Authorization': f'Bearer {token}'}\n```\n</details>\n\n<details>\n<summary>Hint 2: Making authenticated requests</summary>\n\n```python\ndef test_create_post(self, client, auth_headers):\n    response = client.post('/api/posts',\n                          headers=auth_headers,  # ← Include headers\n                          json={\n                              'title': 'Test Post',\n                              'content': 'Test content'\n                          })\n    assert response.status_code == 201\n```\n</details>\n\n<details>\n<summary>Hint 3: Testing forbidden access</summary>\n\n```python\ndef test_update_others_post(self, client, sample_post):\n    # Register second user\n    client.post('/api/register', json={\n        'email': 'user2@example.com',\n        'password': 'SecurePass123',\n        'name': 'User 2'\n    })\n    \n    # Login as second user\n    login_response = client.post('/api/login', json={\n        'email': 'user2@example.com',\n        'password': 'SecurePass123'\n    })\n    token = login_response.get_json()['token']\n    \n    # Try to update first user's post\n    response = client.put(f'/api/posts/{sample_post[\"id\"]}',\n                         headers={'Authorization': f'Bearer {token}'},\n                         json={'title': 'Hacked!', 'content': 'Hacked!'})\n    \n    assert response.status_code == 403\n```\n</details>\n\nTry to write all tests yourself first! This will solidify your understanding of API testing."
    },
    {
      "title": "The Coder: Solution with Common Mistakes",
      "content": "# Complete Solution: Blog API Test Suite\n\n## conftest.py - Test Configuration\n\n```python\nimport pytest\nimport os\nimport tempfile\nfrom app import app as flask_app, init_db\n\n@pytest.fixture\ndef app():\n    \"\"\"Create and configure a test app instance.\"\"\"\n    db_fd, db_path = tempfile.mkstemp()\n    \n    flask_app.config.update({\n        'TESTING': True,\n        'DATABASE': db_path,\n    })\n    \n    with flask_app.app_context():\n        init_db()\n    \n    yield flask_app\n    \n    os.close(db_fd)\n    os.unlink(db_path)\n\n@pytest.fixture\ndef client(app):\n    \"\"\"Create a test client for the app.\"\"\"\n    return app.test_client()\n\n@pytest.fixture\ndef registered_user(client):\n    \"\"\"Create and return a registered user.\"\"\"\n    user_data = {\n        'email': 'test@example.com',\n        'password': 'SecurePass123',\n        'name': 'Test User'\n    }\n    response = client.post('/api/register', json=user_data)\n    \n    return {\n        'email': user_data['email'],\n        'password': user_data['password'],\n        'data': response.get_json()\n    }\n\n@pytest.fixture\ndef auth_headers(client, registered_user):\n    \"\"\"Get authentication headers with valid JWT token.\"\"\"\n    response = client.post('/api/login', json={\n        'email': registered_user['email'],\n        'password': registered_user['password']\n    })\n    token = response.get_json()['token']\n    \n    return {'Authorization': f'Bearer {token}'}\n\n@pytest.fixture\ndef sample_post(client, auth_headers):\n    \"\"\"Create a sample post.\"\"\"\n    response = client.post('/api/posts',\n                          headers=auth_headers,\n                          json={\n                              'title': 'Sample Post',\n                              'content': 'This is a sample post for testing.'\n                          })\n    return response.get_json()\n```\n\n## test_blog_api.py - Complete Test Suite\n\n```python\nimport pytest\nimport json\nimport time\n\nclass TestAuthentication:\n    \"\"\"Test suite for authentication endpoints.\"\"\"\n    \n    def test_successful_registration(self, client):\n        \"\"\"Test that valid registration works.\"\"\"\n        response = client.post('/api/register', json={\n            'email': 'alice@example.com',\n            'password': 'SecurePass123',\n            'name': 'Alice'\n        })\n        \n        assert response.status_code == 201\n        data = response.get_json()\n        assert data['email'] == 'alice@example.com'\n        assert data['name'] == 'Alice'\n        assert 'id' in data\n        assert 'created_at' in data\n        assert 'password' not in data\n    \n    def test_duplicate_email_rejected(self, client):\n        \"\"\"Test that duplicate emails are rejected.\"\"\"\n        user_data = {\n            'email': 'duplicate@example.com',\n            'password': 'SecurePass123',\n            'name': 'User One'\n        }\n        \n        # Register first user\n        client.post('/api/register', json=user_data)\n        \n        # Try to register with same email\n        response = client.post('/api/register', json=user_data)\n        \n        assert response.status_code == 409\n        data = response.get_json()\n        assert 'error' in data\n        assert 'already registered' in data['error'].lower()\n    \n    def test_invalid_email_rejected(self, client):\n        \"\"\"Test that invalid email formats are rejected.\"\"\"\n        invalid_emails = ['notanemail', 'missing@domain', '@nodomain.com']\n        \n        for email in invalid_emails:\n            response = client.post('/api/register', json={\n                'email': email,\n                'password': 'SecurePass123',\n                'name': 'Test'\n            })\n            \n            assert response.status_code == 400\n            assert 'error' in response.get_json()\n    \n    def test_weak_password_rejected(self, client):\n        \"\"\"Test that weak passwords are rejected.\"\"\"\n        weak_passwords = [\n            'short',           # Too short\n            'nouppercase1',    # No uppercase\n            'NOLOWERCASE1',    # No lowercase\n            'NoDigitsHere',    # No digits\n        ]\n        \n        for password in weak_passwords:\n            response = client.post('/api/register', json={\n                'email': 'test@example.com',\n                'password': password,\n                'name': 'Test'\n            })\n            \n            assert response.status_code == 422\n            assert 'error' in response.get_json()\n    \n    def test_successful_login(self, client, registered_user):\n        \"\"\"Test that valid credentials allow login.\"\"\"\n        response = client.post('/api/login', json={\n            'email': registered_user['email'],\n            'password': registered_user['password']\n        })\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert 'token' in data\n        assert 'user' in data\n        assert data['user']['email'] == registered_user['email']\n    \n    def test_invalid_credentials(self, client, registered_user):\n        \"\"\"Test that invalid credentials are rejected.\"\"\"\n        # Wrong password\n        response = client.post('/api/login', json={\n            'email': registered_user['email'],\n            'password': 'WrongPassword123'\n        })\n        assert response.status_code == 401\n        \n        # Wrong email\n        response = client.post('/api/login', json={\n            'email': 'wrong@example.com',\n            'password': registered_user['password']\n        })\n        assert response.status_code == 401\n\nclass TestPosts:\n    \"\"\"Test suite for post endpoints.\"\"\"\n    \n    def test_create_post_authenticated(self, client, auth_headers):\n        \"\"\"Test creating a post with authentication.\"\"\"\n        response = client.post('/api/posts',\n                              headers=auth_headers,\n                              json={\n                                  'title': 'My First Post',\n                                  'content': 'This is the content of my first post.'\n                              })\n        \n        assert response.status_code == 201\n        data = response.get_json()\n        assert data['title'] == 'My First Post'\n        assert data['content'] == 'This is the content of my first post.'\n        assert 'id' in data\n        assert 'author' in data\n        assert 'created_at' in data\n    \n    def test_create_post_no_auth(self, client):\n        \"\"\"Test that creating post without auth is rejected.\"\"\"\n        response = client.post('/api/posts', json={\n            'title': 'Unauthorized Post',\n            'content': 'This should fail.'\n        })\n        \n        assert response.status_code == 401\n        data = response.get_json()\n        assert 'error' in data\n    \n    def test_create_post_empty_title(self, client, auth_headers):\n        \"\"\"Test that empty title is rejected.\"\"\"\n        response = client.post('/api/posts',\n                              headers=auth_headers,\n                              json={\n                                  'title': '',\n                                  'content': 'Content here'\n                              })\n        \n        assert response.status_code == 400\n    \n    def test_create_post_title_too_long(self, client, auth_headers):\n        \"\"\"Test that titles over 200 characters are rejected.\"\"\"\n        long_title = 'A' * 201\n        response = client.post('/api/posts',\n                              headers=auth_headers,\n                              json={\n                                  'title': long_title,\n                                  'content': 'Content'\n                              })\n        \n        assert response.status_code == 400\n    \n    def test_get_all_posts_public(self, client, sample_post):\n        \"\"\"Test that anyone can get all posts.\"\"\"\n        response = client.get('/api/posts')\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert 'posts' in data\n        assert len(data['posts']) > 0\n        \n        # Verify sample_post is in results\n        post_ids = [p['id'] for p in data['posts']]\n        assert sample_post['id'] in post_ids\n    \n    def test_get_single_post(self, client, sample_post):\n        \"\"\"Test getting a specific post.\"\"\"\n        response = client.get(f'/api/posts/{sample_post[\"id\"]}')\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert data['id'] == sample_post['id']\n        assert data['title'] == sample_post['title']\n    \n    def test_get_nonexistent_post(self, client):\n        \"\"\"Test getting a post that doesn't exist.\"\"\"\n        response = client.get('/api/posts/99999')\n        \n        assert response.status_code == 404\n        assert 'error' in response.get_json()\n    \n    def test_update_own_post(self, client, auth_headers, sample_post):\n        \"\"\"Test updating own post.\"\"\"\n        response = client.put(f'/api/posts/{sample_post[\"id\"]}',\n                             headers=auth_headers,\n                             json={\n                                 'title': 'Updated Title',\n                                 'content': 'Updated content here.'\n                             })\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert data['title'] == 'Updated Title'\n        assert data['content'] == 'Updated content here.'\n        # updated_at should be different from created_at\n        assert 'updated_at' in data\n    \n    def test_update_others_post_forbidden(self, client, sample_post):\n        \"\"\"Test that updating someone else's post is forbidden.\"\"\"\n        # Register second user\n        client.post('/api/register', json={\n            'email': 'user2@example.com',\n            'password': 'SecurePass123',\n            'name': 'User Two'\n        })\n        \n        # Login as second user\n        login_response = client.post('/api/login', json={\n            'email': 'user2@example.com',\n            'password': 'SecurePass123'\n        })\n        token = login_response.get_json()['token']\n        \n        # Try to update first user's post\n        response = client.put(f'/api/posts/{sample_post[\"id\"]}',\n                             headers={'Authorization': f'Bearer {token}'},\n                             json={\n                                 'title': 'Hacked!',\n                                 'content': 'This should not work.'\n                             })\n        \n        assert response.status_code == 403\n        data = response.get_json()\n        assert 'error' in data\n    \n    def test_delete_own_post(self, client, auth_headers, sample_post):\n        \"\"\"Test deleting own post.\"\"\"\n        response = client.delete(f'/api/posts/{sample_post[\"id\"]}',\n                                headers=auth_headers)\n        \n        assert response.status_code == 200\n        \n        # Verify post is deleted\n        get_response = client.get(f'/api/posts/{sample_post[\"id\"]}')\n        assert get_response.status_code == 404\n    \n    def test_delete_others_post_forbidden(self, client, sample_post):\n        \"\"\"Test that deleting someone else's post is forbidden.\"\"\"\n        # Register and login as second user\n        client.post('/api/register', json={\n            'email': 'user2@example.com',\n            'password': 'SecurePass123',\n            'name': 'User Two'\n        })\n        login_response = client.post('/api/login', json={\n            'email': 'user2@example.com',\n            'password': 'SecurePass123'\n        })\n        token = login_response.get_json()['token']\n        \n        # Try to delete first user's post\n        response = client.delete(f'/api/posts/{sample_post[\"id\"]}',\n                                headers={'Authorization': f'Bearer {token}'})\n        \n        assert response.status_code == 403\n\nclass TestComments:\n    \"\"\"Test suite for comment endpoints.\"\"\"\n    \n    def test_add_comment_authenticated(self, client, auth_headers, sample_post):\n        \"\"\"Test adding a comment with authentication.\"\"\"\n        response = client.post(f'/api/posts/{sample_post[\"id\"]}/comments',\n                              headers=auth_headers,\n                              json={'content': 'Great post!'})\n        \n        assert response.status_code == 201\n        data = response.get_json()\n        assert data['content'] == 'Great post!'\n        assert data['post_id'] == sample_post['id']\n        assert 'id' in data\n        assert 'author' in data\n    \n    def test_add_comment_no_auth(self, client, sample_post):\n        \"\"\"Test that commenting without auth is rejected.\"\"\"\n        response = client.post(f'/api/posts/{sample_post[\"id\"]}/comments',\n                              json={'content': 'Unauthorized comment'})\n        \n        assert response.status_code == 401\n    \n    def test_add_comment_to_nonexistent_post(self, client, auth_headers):\n        \"\"\"Test commenting on non-existent post.\"\"\"\n        response = client.post('/api/posts/99999/comments',\n                              headers=auth_headers,\n                              json={'content': 'Comment'})\n        \n        assert response.status_code == 404\n    \n    def test_add_comment_empty_content(self, client, auth_headers, sample_post):\n        \"\"\"Test that empty comment content is rejected.\"\"\"\n        response = client.post(f'/api/posts/{sample_post[\"id\"]}/comments',\n                              headers=auth_headers,\n                              json={'content': ''})\n        \n        assert response.status_code == 400\n    \n    def test_get_post_comments(self, client, auth_headers, sample_post):\n        \"\"\"Test getting all comments for a post.\"\"\"\n        # Add 2 comments\n        client.post(f'/api/posts/{sample_post[\"id\"]}/comments',\n                   headers=auth_headers,\n                   json={'content': 'First comment'})\n        client.post(f'/api/posts/{sample_post[\"id\"]}/comments',\n                   headers=auth_headers,\n                   json={'content': 'Second comment'})\n        \n        # Get comments\n        response = client.get(f'/api/posts/{sample_post[\"id\"]}/comments')\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert 'comments' in data\n        assert len(data['comments']) == 2\n    \n    def test_delete_own_comment(self, client, auth_headers, sample_post):\n        \"\"\"Test deleting own comment.\"\"\"\n        # Create comment\n        create_response = client.post(f'/api/posts/{sample_post[\"id\"]}/comments',\n                                     headers=auth_headers,\n                                     json={'content': 'My comment'})\n        comment = create_response.get_json()\n        \n        # Delete comment\n        response = client.delete(f'/api/comments/{comment[\"id\"]}',\n                                headers=auth_headers)\n        \n        assert response.status_code == 200\n        \n        # Verify comment count decreased\n        comments_response = client.get(f'/api/posts/{sample_post[\"id\"]}/comments')\n        comments = comments_response.get_json()['comments']\n        comment_ids = [c['id'] for c in comments]\n        assert comment['id'] not in comment_ids\n    \n    def test_delete_others_comment_forbidden(self, client, auth_headers, sample_post):\n        \"\"\"Test that deleting someone else's comment is forbidden.\"\"\"\n        # User 1 creates comment\n        create_response = client.post(f'/api/posts/{sample_post[\"id\"]}/comments',\n                                     headers=auth_headers,\n                                     json={'content': 'User 1 comment'})\n        comment = create_response.get_json()\n        \n        # Register and login as User 2\n        client.post('/api/register', json={\n            'email': 'user2@example.com',\n            'password': 'SecurePass123',\n            'name': 'User Two'\n        })\n        login_response = client.post('/api/login', json={\n            'email': 'user2@example.com',\n            'password': 'SecurePass123'\n        })\n        token = login_response.get_json()['token']\n        \n        # User 2 tries to delete User 1's comment\n        response = client.delete(f'/api/comments/{comment[\"id\"]}',\n                                headers={'Authorization': f'Bearer {token}'})\n        \n        assert response.status_code == 403\n    \n    def test_comments_cascade_delete(self, client, auth_headers):\n        \"\"\"Test that comments are deleted when post is deleted.\"\"\"\n        # Create post\n        post_response = client.post('/api/posts',\n                                   headers=auth_headers,\n                                   json={\n                                       'title': 'Post to Delete',\n                                       'content': 'This post will be deleted'\n                                   })\n        post = post_response.get_json()\n        \n        # Add comments\n        client.post(f'/api/posts/{post[\"id\"]}/comments',\n                   headers=auth_headers,\n                   json={'content': 'Comment 1'})\n        client.post(f'/api/posts/{post[\"id\"]}/comments',\n                   headers=auth_headers,\n                   json={'content': 'Comment 2'})\n        \n        # Delete post\n        client.delete(f'/api/posts/{post[\"id\"]}', headers=auth_headers)\n        \n        # Try to get comments - post doesn't exist\n        response = client.get(f'/api/posts/{post[\"id\"]}/comments')\n        assert response.status_code == 404\n\nclass TestWorkflows:\n    \"\"\"Integration tests for complete workflows.\"\"\"\n    \n    def test_complete_blog_workflow(self, client):\n        \"\"\"Test complete blog workflow from registration to deletion.\"\"\"\n        # Register\n        register_response = client.post('/api/register', json={\n            'email': 'workflow@example.com',\n            'password': 'SecurePass123',\n            'name': 'Workflow User'\n        })\n        assert register_response.status_code == 201\n        \n        # Login\n        login_response = client.post('/api/login', json={\n            'email': 'workflow@example.com',\n            'password': 'SecurePass123'\n        })\n        assert login_response.status_code == 200\n        token = login_response.get_json()['token']\n        headers = {'Authorization': f'Bearer {token}'}\n        \n        # Create post\n        post_response = client.post('/api/posts',\n                                   headers=headers,\n                                   json={\n                                       'title': 'My Journey',\n                                       'content': 'This is my story.'\n                                   })\n        assert post_response.status_code == 201\n        post = post_response.get_json()\n        \n        # Add comment\n        comment_response = client.post(f'/api/posts/{post[\"id\"]}/comments',\n                                      headers=headers,\n                                      json={'content': 'Great story!'})\n        assert comment_response.status_code == 201\n        comment = comment_response.get_json()\n        \n        # Update post\n        update_response = client.put(f'/api/posts/{post[\"id\"]}',\n                                    headers=headers,\n                                    json={\n                                        'title': 'My Updated Journey',\n                                        'content': 'Updated story.'\n                                    })\n        assert update_response.status_code == 200\n        \n        # Delete comment\n        delete_comment_response = client.delete(f'/api/comments/{comment[\"id\"]}',\n                                               headers=headers)\n        assert delete_comment_response.status_code == 200\n        \n        # Delete post\n        delete_post_response = client.delete(f'/api/posts/{post[\"id\"]}',\n                                            headers=headers)\n        assert delete_post_response.status_code == 200\n    \n    def test_multiple_users_posts(self, client):\n        \"\"\"Test multiple users creating and managing posts.\"\"\"\n        # Register User 1\n        client.post('/api/register', json={\n            'email': 'user1@example.com',\n            'password': 'SecurePass123',\n            'name': 'User One'\n        })\n        user1_login = client.post('/api/login', json={\n            'email': 'user1@example.com',\n            'password': 'SecurePass123'\n        })\n        user1_token = user1_login.get_json()['token']\n        user1_headers = {'Authorization': f'Bearer {user1_token}'}\n        \n        # Register User 2\n        client.post('/api/register', json={\n            'email': 'user2@example.com',\n            'password': 'SecurePass123',\n            'name': 'User Two'\n        })\n        user2_login = client.post('/api/login', json={\n            'email': 'user2@example.com',\n            'password': 'SecurePass123'\n        })\n        user2_token = user2_login.get_json()['token']\n        user2_headers = {'Authorization': f'Bearer {user2_token}'}\n        \n        # Each user creates 2 posts\n        user1_post1 = client.post('/api/posts', headers=user1_headers,\n                                 json={'title': 'User 1 Post 1', 'content': 'Content'}).get_json()\n        user1_post2 = client.post('/api/posts', headers=user1_headers,\n                                 json={'title': 'User 1 Post 2', 'content': 'Content'}).get_json()\n        user2_post1 = client.post('/api/posts', headers=user2_headers,\n                                 json={'title': 'User 2 Post 1', 'content': 'Content'}).get_json()\n        user2_post2 = client.post('/api/posts', headers=user2_headers,\n                                 json={'title': 'User 2 Post 2', 'content': 'Content'}).get_json()\n        \n        # Verify 4 posts exist\n        all_posts = client.get('/api/posts').get_json()\n        assert len(all_posts['posts']) == 4\n        \n        # User 1 comments on User 2's post\n        client.post(f'/api/posts/{user2_post1[\"id\"]}/comments',\n                   headers=user1_headers,\n                   json={'content': 'Nice post!'})\n        \n        # User 2 comments on User 1's post\n        client.post(f'/api/posts/{user1_post1[\"id\"]}/comments',\n                   headers=user2_headers,\n                   json={'content': 'Thanks for sharing!'})\n        \n        # User 1 can delete their own posts\n        response = client.delete(f'/api/posts/{user1_post1[\"id\"]}',\n                                headers=user1_headers)\n        assert response.status_code == 200\n        \n        # User 1 cannot delete User 2's posts\n        response = client.delete(f'/api/posts/{user2_post1[\"id\"]}',\n                                headers=user1_headers)\n        assert response.status_code == 403\n        \n        # User 2 can delete their own posts\n        response = client.delete(f'/api/posts/{user2_post2[\"id\"]}',\n                                headers=user2_headers)\n        assert response.status_code == 200\n```\n\n## Running the Complete Test Suite\n\n```bash\npytest test_blog_api.py -v\n```\n\n## Expected Output\n\n```\ntest_blog_api.py::TestAuthentication::test_successful_registration PASSED\ntest_blog_api.py::TestAuthentication::test_duplicate_email_rejected PASSED\ntest_blog_api.py::TestAuthentication::test_invalid_email_rejected PASSED\ntest_blog_api.py::TestAuthentication::test_weak_password_rejected PASSED\ntest_blog_api.py::TestAuthentication::test_successful_login PASSED\ntest_blog_api.py::TestAuthentication::test_invalid_credentials PASSED\ntest_blog_api.py::TestPosts::test_create_post_authenticated PASSED\ntest_blog_api.py::TestPosts::test_create_post_no_auth PASSED\ntest_blog_api.py::TestPosts::test_create_post_empty_title PASSED\ntest_blog_api.py::TestPosts::test_create_post_title_too_long PASSED\ntest_blog_api.py::TestPosts::test_get_all_posts_public PASSED\ntest_blog_api.py::TestPosts::test_get_single_post PASSED\ntest_blog_api.py::TestPosts::test_get_nonexistent_post PASSED\ntest_blog_api.py::TestPosts::test_update_own_post PASSED\ntest_blog_api.py::TestPosts::test_update_others_post_forbidden PASSED\ntest_blog_api.py::TestPosts::test_delete_own_post PASSED\ntest_blog_api.py::TestPosts::test_delete_others_post_forbidden PASSED\ntest_blog_api.py::TestComments::test_add_comment_authenticated PASSED\ntest_blog_api.py::TestComments::test_add_comment_no_auth PASSED\ntest_blog_api.py::TestComments::test_add_comment_to_nonexistent_post PASSED\ntest_blog_api.py::TestComments::test_add_comment_empty_content PASSED\ntest_blog_api.py::TestComments::test_get_post_comments PASSED\ntest_blog_api.py::TestComments::test_delete_own_comment PASSED\ntest_blog_api.py::TestComments::test_delete_others_comment_forbidden PASSED\ntest_blog_api.py::TestComments::test_comments_cascade_delete PASSED\ntest_blog_api.py::TestWorkflows::test_complete_blog_workflow PASSED\ntest_blog_api.py::TestWorkflows::test_multiple_users_posts PASSED\n\n=============== 27 passed in 1.23s ===============\n```\n\n## Common Mistakes and Solutions\n\n### Mistake 1: Not Including Authorization Header\n\n❌ **Wrong:**\n```python\ndef test_create_post(self, client):\n    # Missing auth headers!\n    response = client.post('/api/posts', json={'title': 'Post'})\n    assert response.status_code == 201  # Will be 401!\n```\n\n✅ **Correct:**\n```python\ndef test_create_post(self, client, auth_headers):\n    response = client.post('/api/posts',\n                          headers=auth_headers,  # ← Include headers\n                          json={'title': 'Post', 'content': 'Content'})\n    assert response.status_code == 201\n```\n\n### Mistake 2: Forgetting to Return User Credentials from Fixture\n\n❌ **Wrong:**\n```python\n@pytest.fixture\ndef registered_user(client):\n    response = client.post('/api/register', json={...})\n    return response.get_json()  # Lost the password!\n```\n\n✅ **Correct:**\n```python\n@pytest.fixture\ndef registered_user(client):\n    user_data = {\n        'email': 'test@example.com',\n        'password': 'SecurePass123',\n        'name': 'Test'\n    }\n    response = client.post('/api/register', json=user_data)\n    return {\n        'email': user_data['email'],\n        'password': user_data['password'],  # ← Keep password for login\n        'data': response.get_json()\n    }\n```\n\n### Mistake 3: Not Testing Authorization\n\n❌ **Wrong:**\n```python\n# Only test that endpoint works\ndef test_delete_post(self, client, auth_headers, sample_post):\n    response = client.delete(f'/api/posts/{sample_post[\"id\"]}',\n                            headers=auth_headers)\n    assert response.status_code == 200\n```\n\n✅ **Correct:**\n```python\n# Also test that others can't delete\ndef test_delete_others_post_forbidden(self, client, sample_post):\n    # Create second user\n    # Try to delete first user's post\n    # Should be 403 Forbidden\n```\n\n### Mistake 4: Sharing State Between Tests\n\n❌ **Wrong:**\n```python\nclass TestPosts:\n    post_id = None  # Class variable!\n    \n    def test_create_post(self, client, auth_headers):\n        response = client.post('/api/posts', ...)\n        self.post_id = response.get_json()['id']\n    \n    def test_update_post(self, client, auth_headers):\n        # Depends on test_create_post running first!\n        response = client.put(f'/api/posts/{self.post_id}', ...)\n```\n\n✅ **Correct:**\n```python\n# Use fixtures for shared setup\n@pytest.fixture\ndef sample_post(client, auth_headers):\n    response = client.post('/api/posts', ...)\n    return response.get_json()\n\ndef test_update_post(self, client, auth_headers, sample_post):\n    # Independent - uses fixture\n    response = client.put(f'/api/posts/{sample_post[\"id\"]}', ...)\n```\n\n### Mistake 5: Not Checking Response Data\n\n❌ **Wrong:**\n```python\ndef test_create_post(self, client, auth_headers):\n    response = client.post('/api/posts', ...)\n    assert response.status_code == 201  # Only check status\n```\n\n✅ **Correct:**\n```python\ndef test_create_post(self, client, auth_headers):\n    response = client.post('/api/posts',\n                          headers=auth_headers,\n                          json={'title': 'Test', 'content': 'Content'})\n    \n    assert response.status_code == 201\n    data = response.get_json()\n    assert data['title'] == 'Test'\n    assert data['content'] == 'Content'\n    assert 'id' in data\n    assert 'author' in data\n```\n\n## Key Takeaways\n\n1. **Use fixtures** for common setup (auth, test data)\n2. **Test both success and failure** - happy path and error cases\n3. **Test authorization** - verify users can't modify others' content\n4. **Keep tests independent** - no shared state\n5. **Check complete responses** - status code AND data\n6. **Organize logically** - group related tests in classes\n7. **Use descriptive names** - test names should explain what they test\n8. **Clean up after tests** - temporary database, etc."
    },
    {
      "title": "Key Takeaways",
      "content": "# Key Takeaways: Blog API Mini-Project\n\n## 1. REST API Architecture\n\nYou built a complete REST API following industry-standard patterns:\n\n### RESTful Routes\n```\nPOST   /api/register          Create user\nPOST   /api/login             Authenticate\nGET    /api/posts             List all posts\nPOST   /api/posts             Create post\nGET    /api/posts/:id         Get specific post\nPUT    /api/posts/:id         Update post\nDELETE /api/posts/:id         Delete post\nGET    /api/posts/:id/comments    List post's comments\nPOST   /api/posts/:id/comments    Create comment\nDELETE /api/comments/:id          Delete comment\n```\n\n**Key principles:**\n- Use HTTP methods correctly (GET for read, POST for create, etc.)\n- Use plural nouns for resources (/posts, not /post)\n- Nest resources logically (/posts/:id/comments)\n- Return appropriate status codes (201 for created, 404 for not found)\n\n## 2. Authentication vs Authorization\n\n### Authentication (Who are you?)\n```python\n@token_required\ndef create_post():\n    # Verifies: Is this request from a logged-in user?\n    # JWT token proves identity\n```\n\n### Authorization (What can you do?)\n```python\n@is_author('post')\ndef update_post(post_id):\n    # Verifies: Does this user own this post?\n    # Can't modify someone else's content\n```\n\n**Remember:** Authentication happens first, then authorization.\n\n## 3. Database Relationships\n\n### One-to-Many Relationships\n```\nUser (1) → Posts (Many)\n- One user can have many posts\n- Each post has one author\n\nPost (1) → Comments (Many)\n- One post can have many comments\n- Each comment belongs to one post\n```\n\n### Foreign Keys\n```python\nauthor_id INTEGER NOT NULL,\nFOREIGN KEY (author_id) REFERENCES users(id)\n# Ensures data integrity - can't have orphaned posts\n```\n\n### CASCADE Deletes\n```python\nFOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE\n# When post is deleted, its comments are automatically deleted\n```\n\n## 4. Security Best Practices\n\n### Password Security\n```python\n# ✅ GOOD: Hash with salt\nhashed = hash_password('SecurePass123')\n# Stored: salt + PBKDF2 hash (100,000 iterations)\n\n# ❌ BAD: Store plain text\npassword = 'SecurePass123'  # NEVER do this!\n```\n\n### JWT Tokens\n```python\n# Create token on login\ntoken = jwt.encode({\n    'user_id': user_id,\n    'exp': datetime.utcnow() + timedelta(days=1)\n}, SECRET_KEY)\n\n# Verify token on protected routes\npayload = jwt.decode(token, SECRET_KEY)\n```\n\n**Benefits:**\n- Stateless (no server-side session storage)\n- Self-contained (contains user info)\n- Expirable (tokens expire after 24 hours)\n\n### Input Validation\n```python\n# Validate email format\nif not validate_email(email):\n    return error(400, 'Invalid email')\n\n# Validate password strength\nif len(password) < 8:\n    return error(422, 'Password too weak')\n\n# Parameterized queries (prevent SQL injection)\ndb.execute('SELECT * FROM users WHERE id = ?', (user_id,))\n```\n\n## 5. SQL Joins for Efficiency\n\n### Without JOIN (N+1 Problem)\n```python\n# Get all posts\nposts = db.execute('SELECT * FROM posts').fetchall()\n\n# For each post, get author (100 posts = 101 queries!)\nfor post in posts:\n    author = db.execute('SELECT * FROM users WHERE id = ?',\n                       (post['author_id'],)).fetchone()\n```\n\n### With JOIN (1 Query)\n```python\n# Get everything in one query\nposts = db.execute('''SELECT p.*, u.name as author_name\n                      FROM posts p\n                      JOIN users u ON p.author_id = u.id''').fetchall()\n# Much faster!\n```\n\n## 6. Decorator Patterns\n\n### Token Required Decorator\n```python\n@token_required\ndef protected_route():\n    # Only runs if valid token provided\n    user_id = request.current_user['user_id']\n```\n\n**Benefits:**\n- Don't repeat authentication code\n- Clear which routes need authentication\n- Easy to add to new routes\n\n### Authorization Decorator\n```python\n@token_required\n@is_author('post')\ndef update_post(post_id):\n    # Only runs if:\n    # 1. User is authenticated\n    # 2. User owns the post\n```\n\n**Benefits:**\n- Separation of concerns\n- Reusable across different resources\n- Clean, readable code\n\n## 7. HTTP Status Codes\n\n```python\n200 OK              # Successful GET, PUT, DELETE\n201 Created         # Successful POST\n400 Bad Request     # Invalid input format\n401 Unauthorized    # Missing/invalid token\n403 Forbidden       # Valid token, but not allowed\n404 Not Found       # Resource doesn't exist\n409 Conflict        # Duplicate (email already exists)\n422 Unprocessable   # Validation failed (weak password)\n```\n\n**Use the right code:**\n- 401 = \"Who are you?\" (authentication)\n- 403 = \"I know who you are, but you can't do that\" (authorization)\n- 404 = \"That thing doesn't exist\"\n\n## 8. Testing Best Practices\n\n### Comprehensive Test Coverage\n```python\nclass TestPosts:\n    def test_create_post_success(self):        # Happy path\n    def test_create_post_no_auth(self):        # Error case\n    def test_create_post_empty_title(self):    # Validation\n    def test_update_own_post(self):            # Authorization\n    def test_update_others_post_forbidden(self): # Authorization\n```\n\n### Test Organization\n```python\nTestAuthentication   # Registration, login\nTestPosts           # Post CRUD operations\nTestComments        # Comment operations\nTestWorkflows       # Integration tests\n```\n\n### Fixtures for Reusability\n```python\n@pytest.fixture\ndef auth_headers(client, registered_user):\n    # Login and return headers\n    # Reused across many tests\n```\n\n## 9. API Design Patterns\n\n### Consistent Response Format\n```python\n# Success\n{\n  \"id\": 1,\n  \"title\": \"Post Title\",\n  \"author\": {...}\n}\n\n# Error\n{\n  \"error\": \"Descriptive error message\"\n}\n```\n\n### Include Related Data\n```python\n# Don't just return IDs\n{\n  \"post_id\": 1,\n  \"author_id\": 5  # User has to make another request\n}\n\n# Include nested data\n{\n  \"id\": 1,\n  \"title\": \"My Post\",\n  \"author\": {           # ← Related data included\n    \"id\": 5,\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\"\n  }\n}\n```\n\n## 10. Real-World Application\n\nWhat you built is production-ready architecture:\n\n### This Same Pattern Powers:\n- **Twitter** - Users create tweets, follow others, like/comment\n- **Medium** - Writers publish articles, readers comment\n- **Reddit** - Users post content, others vote/comment\n- **Instagram** - Users post photos, others like/comment\n\n### You Now Know How To:\n- ✅ Build secure authentication systems\n- ✅ Implement authorization (ownership checks)\n- ✅ Design RESTful APIs\n- ✅ Model database relationships\n- ✅ Write comprehensive tests\n- ✅ Hash passwords securely\n- ✅ Use JWT tokens\n- ✅ Validate user input\n- ✅ Prevent SQL injection\n- ✅ Handle errors gracefully\n\n## 11. Next Steps\n\n### Enhancements You Could Add:\n\n1. **Pagination**\n```python\nGET /api/posts?page=2&per_page=20\n# Don't return all posts at once\n```\n\n2. **Search**\n```python\nGET /api/posts?q=python&tag=tutorial\n# Search by title, content, tags\n```\n\n3. **Likes/Votes**\n```python\nPOST /api/posts/:id/like\nDELETE /api/posts/:id/like\n# Track user engagement\n```\n\n4. **File Uploads**\n```python\nPOST /api/posts/:id/image\n# Upload cover images\n```\n\n5. **Rate Limiting**\n```python\n@rate_limit(max_requests=10, window=60)\ndef create_post():\n    # Prevent spam\n```\n\n6. **Email Notifications**\n```python\n# Send email when someone comments on your post\n```\n\n7. **User Profiles**\n```python\nGET /api/users/:id/posts\n# See all posts by a user\n```\n\n## 12. Common Pitfalls to Avoid\n\n### Security\n- ❌ Storing passwords in plain text\n- ❌ Not validating input\n- ❌ Forgetting authorization checks\n- ❌ Exposing sensitive data in responses\n\n### Database\n- ❌ N+1 query problems (use JOINs)\n- ❌ Not using foreign keys\n- ❌ Forgetting CASCADE deletes\n- ❌ Not using parameterized queries\n\n### Testing\n- ❌ Only testing happy paths\n- ❌ Sharing state between tests\n- ❌ Not testing authorization\n- ❌ Not using fixtures\n\n### API Design\n- ❌ Inconsistent endpoint naming\n- ❌ Wrong HTTP methods\n- ❌ Unclear error messages\n- ❌ Missing status codes\n\n## Final Wisdom\n\n**You've built a complete, secure, tested REST API from scratch!**\n\nThis project demonstrates:\n- Professional software engineering practices\n- Security-first mindset\n- Clean, maintainable code\n- Comprehensive testing\n- RESTful design principles\n\n**This is the foundation for:**\n- Building any web application backend\n- Creating mobile app APIs\n- Microservices architecture\n- Full-stack development\n\n**You're now ready to:**\n- Build your own APIs for personal projects\n- Contribute to open-source API projects\n- Understand how real-world APIs work\n- Move on to advanced topics (GraphQL, WebSockets, etc.)\n\nCongratulations on completing this comprehensive module! 🎉"
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "question": "What is the difference between authentication and authorization?",
        "options": [
          "They are the same thing",
          "Authentication verifies identity, authorization verifies permissions",
          "Authorization happens before authentication",
          "Authentication is for APIs, authorization is for websites"
        ],
        "correct_answer": 1,
        "explanation": "Authentication answers 'Who are you?' (checking credentials/tokens). Authorization answers 'What can you do?' (checking if you own a resource). Authentication must happen first."
      },
      {
        "id": 2,
        "question": "Why use SQL JOINs instead of separate queries for related data?",
        "options": [
          "JOINs are easier to write",
          "JOINs prevent the N+1 query problem and are much faster",
          "JOINs are more secure",
          "You should always use separate queries"
        ],
        "correct_answer": 1,
        "explanation": "JOINs fetch related data in one query instead of N+1 queries. For 100 posts, separate queries = 101 database calls. With JOIN = 1 database call. Much faster!"
      },
      {
        "id": 3,
        "question": "What does ON DELETE CASCADE do in a foreign key relationship?",
        "options": [
          "It prevents the parent record from being deleted",
          "It automatically deletes child records when parent is deleted",
          "It cascades updates to all related tables",
          "It creates a backup before deletion"
        ],
        "correct_answer": 1,
        "explanation": "CASCADE means 'automatically delete related records'. When you delete a post, ON DELETE CASCADE automatically deletes all its comments. Prevents orphaned data."
      }
    ]
  }
}
