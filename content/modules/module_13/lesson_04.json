{
  "lesson_id": "13_04",
  "title": "Authentication and API Security",
  "module_id": 13,
  "order_index": 4,
  "description": "Implement authentication in Flask APIs using API keys, JWT tokens, and password hashing. Learn security best practices including CORS, rate limiting, and input validation.",
  "estimated_minutes": 45,
  "content_blocks": [
    {
      "type": "the_simplifier",
      "title": "The Concept: Securing Your API",
      "content": "**API Security = Protecting your data and endpoints**\n\n**Think of it like a building:**\n- **No Security:** Anyone can walk in and do anything\n- **API Key:** Guests need a key card to enter\n- **JWT Token:** Temporary access badge with permissions\n- **Password Hashing:** Storing passwords safely (not plain text)\n\n**Authentication Methods:**\n\n**1. API Keys** ðŸ”‘\n- Simple key in header\n- Good for: Server-to-server communication\n- Example: `X-API-Key: secret-key-123`\n\n**2. JWT (JSON Web Tokens)** ðŸŽ«\n- Encoded token with user info\n- Good for: User authentication\n- Expires after time limit\n- Contains: user ID, permissions, expiration\n\n**3. Basic Auth** ðŸ”’\n- Username:password in header\n- Simple but less secure\n- Should use HTTPS\n\n**Security Best Practices:**\n\n1. **Never store plain passwords** - Always hash\n2. **Use HTTPS** - Encrypt data in transit\n3. **Validate all input** - Prevent injection attacks\n4. **Rate limiting** - Prevent abuse\n5. **CORS** - Control which domains can access API\n6. **Token expiration** - Tokens should expire\n7. **Least privilege** - Give minimum permissions needed"
    },
    {
      "type": "the_coder",
      "title": "Code Example: API Key Authentication",
      "code": "from flask import Flask, jsonify, request\nfrom functools import wraps\nimport secrets\nimport hashlib\nfrom datetime import datetime, timedelta\n\napp = Flask(__name__)\n\n# Simulated API keys database\nAPI_KEYS = {\n    'dev-key-123': {'name': 'Development', 'permissions': ['read', 'write']},\n    'readonly-456': {'name': 'ReadOnly', 'permissions': ['read']}\n}\n\nprint(\"=== API Key Authentication ===\")\n\ndef require_api_key(f):\n    \"\"\"Decorator to require valid API key\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        api_key = request.headers.get('X-API-Key')\n        \n        if not api_key:\n            return jsonify({'error': 'API key required'}), 401\n        \n        if api_key not in API_KEYS:\n            return jsonify({'error': 'Invalid API key'}), 401\n        \n        # Store key info in request context\n        request.api_key_info = API_KEYS[api_key]\n        \n        return f(*args, **kwargs)\n    return decorated_function\n\ndef require_permission(permission):\n    \"\"\"Decorator to require specific permission\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if permission not in request.api_key_info['permissions']:\n                return jsonify({'error': f'Permission denied: {permission} required'}), 403\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\n@app.route('/api/public')\ndef public():\n    \"\"\"Public endpoint - no auth required\"\"\"\n    return jsonify({'message': 'This is public'})\n\n@app.route('/api/protected')\n@require_api_key\ndef protected():\n    \"\"\"Protected endpoint - requires API key\"\"\"\n    return jsonify({\n        'message': 'You have access!',\n        'key_name': request.api_key_info['name']\n    })\n\n@app.route('/api/admin')\n@require_api_key\n@require_permission('write')\ndef admin():\n    \"\"\"Admin endpoint - requires write permission\"\"\"\n    return jsonify({\n        'message': 'Admin access granted',\n        'permissions': request.api_key_info['permissions']\n    })\n\nprint(\"\\n=== Password Hashing ===\")\n\nimport hashlib\nimport os\n\ndef hash_password(password):\n    \"\"\"Hash password with salt\"\"\"\n    # Generate random salt\n    salt = os.urandom(32)\n    \n    # Hash password with salt\n    pwdhash = hashlib.pbkdf2_hmac(\n        'sha256',\n        password.encode('utf-8'),\n        salt,\n        100000  # Number of iterations\n    )\n    \n    # Return salt + hash\n    return salt + pwdhash\n\ndef verify_password(stored_password, provided_password):\n    \"\"\"Verify password against hash\"\"\"\n    # Extract salt (first 32 bytes)\n    salt = stored_password[:32]\n    stored_hash = stored_password[32:]\n    \n    # Hash provided password with same salt\n    pwdhash = hashlib.pbkdf2_hmac(\n        'sha256',\n        provided_password.encode('utf-8'),\n        salt,\n        100000\n    )\n    \n    # Compare hashes\n    return pwdhash == stored_hash\n\n# Demo password hashing\noriginal_password = \"MySecurePassword123!\"\nprint(f\"Original password: {original_password}\")\n\nhashed = hash_password(original_password)\nprint(f\"Hashed password length: {len(hashed)} bytes\")\nprint(f\"First 10 bytes (salt): {hashed[:10].hex()}...\")\n\n# Verify correct password\nif verify_password(hashed, original_password):\n    print(\"âœ“ Correct password verified\")\n\n# Verify wrong password\nif not verify_password(hashed, \"WrongPassword\"):\n    print(\"âœ— Wrong password rejected\")\n\nprint(\"\\n=== Rate Limiting ===\")\n\nfrom collections import defaultdict\nimport time\n\nclass RateLimiter:\n    \"\"\"Simple rate limiter\"\"\"\n    \n    def __init__(self, max_requests=10, window=60):\n        self.max_requests = max_requests\n        self.window = window  # Time window in seconds\n        self.requests = defaultdict(list)\n    \n    def is_allowed(self, key):\n        \"\"\"Check if request is allowed\"\"\"\n        now = time.time()\n        \n        # Remove old requests\n        self.requests[key] = [\n            req_time for req_time in self.requests[key]\n            if now - req_time < self.window\n        ]\n        \n        # Check limit\n        if len(self.requests[key]) >= self.max_requests:\n            return False\n        \n        # Record this request\n        self.requests[key].append(now)\n        return True\n\nrate_limiter = RateLimiter(max_requests=5, window=60)\n\ndef rate_limit(f):\n    \"\"\"Decorator for rate limiting\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        # Use API key or IP as identifier\n        api_key = request.headers.get('X-API-Key', 'anonymous')\n        \n        if not rate_limiter.is_allowed(api_key):\n            return jsonify({\n                'error': 'Rate limit exceeded',\n                'retry_after': 60\n            }), 429\n        \n        return f(*args, **kwargs)\n    return decorated_function\n\n@app.route('/api/limited')\n@rate_limit\ndef limited():\n    \"\"\"Rate limited endpoint\"\"\"\n    return jsonify({'message': 'Request successful'})\n\nprint(\"\\n=== CORS (Cross-Origin Resource Sharing) ===\")\n\nfrom flask_cors import CORS\n\n# Enable CORS for all routes\n# CORS(app)\n\n# Or enable for specific origins\n# CORS(app, origins=['https://yourdomain.com'])\n\n# Manual CORS headers\n@app.after_request\ndef add_cors_headers(response):\n    \"\"\"Add CORS headers to response\"\"\"\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'\n    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, X-API-Key'\n    return response\n\nprint(\"\\n=== Input Validation ===\")\n\nimport re\n\ndef validate_email(email):\n    \"\"\"Validate email format\"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n\ndef sanitize_input(text, max_length=200):\n    \"\"\"Sanitize user input\"\"\"\n    # Strip whitespace\n    text = text.strip()\n    \n    # Limit length\n    text = text[:max_length]\n    \n    # Remove potentially dangerous characters\n    # (In real app, use proper HTML escaping)\n    dangerous_chars = ['<', '>', '&', '\"', \"'\"]\n    for char in dangerous_chars:\n        text = text.replace(char, '')\n    \n    return text\n\n@app.route('/api/users', methods=['POST'])\n@require_api_key\ndef create_user():\n    \"\"\"Create user with validation\"\"\"\n    data = request.get_json()\n    \n    # Validate required fields\n    if not data or 'email' not in data or 'name' not in data:\n        return jsonify({'error': 'Email and name required'}), 400\n    \n    # Validate email\n    if not validate_email(data['email']):\n        return jsonify({'error': 'Invalid email format'}), 400\n    \n    # Sanitize inputs\n    name = sanitize_input(data['name'])\n    email = data['email'].lower().strip()\n    \n    return jsonify({\n        'message': 'User created',\n        'user': {'name': name, 'email': email}\n    }), 201\n\nif __name__ == '__main__':\n    print(\"\\n=== Security Features Demo ===\")\n    print(\"\\nFeatures implemented:\")\n    print(\"  âœ“ API key authentication\")\n    print(\"  âœ“ Permission-based access control\")\n    print(\"  âœ“ Password hashing (PBKDF2)\")\n    print(\"  âœ“ Rate limiting\")\n    print(\"  âœ“ CORS headers\")\n    print(\"  âœ“ Input validation and sanitization\")\n    print(\"\\nExample requests:\")\n    print(\"  curl -H 'X-API-Key: dev-key-123' http://localhost:5000/api/protected\")\n    print(\"  curl -H 'X-API-Key: readonly-456' http://localhost:5000/api/admin\")\n    print(\"\\nNote: Use flask-cors package for production CORS handling\")",
      "explanation": "**Security implementation patterns:**\n\n**1. API Key Authentication:**\n```python\n@require_api_key\ndef protected_route():\n    # Only accessible with valid API key\n    pass\n```\n\n**2. Password Hashing:**\n```python\n# NEVER store plain passwords!\nhashed = hash_password(password)  # Store this\nif verify_password(stored, provided):\n    # Password correct\n```\n\n**3. Rate Limiting:**\n- Track requests per time window\n- Return 429 when limit exceeded\n- Prevents abuse and DoS attacks\n\n**4. CORS:**\n- Controls which domains can access API\n- Required for browser-based clients\n- Set appropriate origins in production\n\n**5. Input Validation:**\n- Validate format (email, etc.)\n- Sanitize to prevent injection\n- Limit length to prevent overflow\n\n**6. Permission-based Access:**\n- Different API keys have different permissions\n- Check permissions before allowing actions",
      "output": "=== API Key Authentication ===\n\n=== Password Hashing ===\nOriginal password: MySecurePassword123!\nHashed password length: 64 bytes\nFirst 10 bytes (salt): a3f2c8b9e7...\nâœ“ Correct password verified\nâœ— Wrong password rejected\n\n=== Rate Limiting ===\n\n=== CORS (Cross-Origin Resource Sharing) ===\n\n=== Input Validation ===\n\n=== Security Features Demo ===\n\nFeatures implemented:\n  âœ“ API key authentication\n  âœ“ Permission-based access control\n  âœ“ Password hashing (PBKDF2)\n  âœ“ Rate limiting\n  âœ“ CORS headers\n  âœ“ Input validation and sanitization\n\nExample requests:\n  curl -H 'X-API-Key: dev-key-123' http://localhost:5000/api/protected\n  curl -H 'X-API-Key: readonly-456' http://localhost:5000/api/admin\n\nNote: Use flask-cors package for production CORS handling"
    },
    {
      "type": "the_simplifier",
      "title": "Syntax Breakdown",
      "content": "**API Key Authentication Pattern:**\n\n```python\ndef require_api_key(f):\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        key = request.headers.get('X-API-Key')\n        if key not in VALID_KEYS:\n            return jsonify({'error': 'Unauthorized'}), 401\n        return f(*args, **kwargs)\n    return wrapper\n\n@app.route('/protected')\n@require_api_key\ndef protected():\n    return jsonify({'data': 'secret'})\n```\n\n**Password Hashing:**\n\n```python\nimport hashlib\nimport os\n\n# Hash password with salt\nsalt = os.urandom(32)\nhashed = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\nstored = salt + hashed  # Store this\n\n# Verify password\nsalt = stored[:32]\nstored_hash = stored[32:]\ntest_hash = hashlib.pbkdf2_hmac('sha256', provided.encode(), salt, 100000)\nif test_hash == stored_hash:\n    # Password correct\n```\n\n**Rate Limiting:**\n\n```python\nfrom collections import defaultdict\nimport time\n\nrequests = defaultdict(list)\n\ndef is_rate_limited(key, max_requests=10, window=60):\n    now = time.time()\n    requests[key] = [t for t in requests[key] if now - t < window]\n    if len(requests[key]) >= max_requests:\n        return True\n    requests[key].append(now)\n    return False\n```\n\n**CORS Headers:**\n\n```python\n@app.after_request\ndef add_cors(response):\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    response.headers['Access-Control-Allow-Methods'] = 'GET, POST'\n    return response\n```"
    },
    {
      "type": "the_coder",
      "title": "Code Example: JWT Token Authentication",
      "code": "from flask import Flask, jsonify, request\nimport jwt\nfrom datetime import datetime, timedelta\nfrom functools import wraps\nimport hashlib\nimport os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-secret-key-change-this-in-production'\n\n# Simulated user database\nUSERS = {\n    'alice@example.com': {\n        'id': 1,\n        'name': 'Alice',\n        'password_hash': None,  # Will be set below\n        'role': 'admin'\n    },\n    'bob@example.com': {\n        'id': 2,\n        'name': 'Bob',\n        'password_hash': None,\n        'role': 'user'\n    }\n}\n\nprint(\"=== JWT Token Authentication ===\")\n\ndef hash_password(password):\n    \"\"\"Simple password hashing for demo\"\"\"\n    salt = b'demo-salt-change-in-production'\n    return hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\n\n# Set passwords\nUSERS['alice@example.com']['password_hash'] = hash_password('password123')\nUSERS['bob@example.com']['password_hash'] = hash_password('password456')\n\ndef create_token(user_id, role):\n    \"\"\"Create JWT token\"\"\"\n    payload = {\n        'user_id': user_id,\n        'role': role,\n        'exp': datetime.utcnow() + timedelta(hours=24),  # Expires in 24 hours\n        'iat': datetime.utcnow()  # Issued at\n    }\n    \n    token = jwt.encode(\n        payload,\n        app.config['SECRET_KEY'],\n        algorithm='HS256'\n    )\n    \n    return token\n\ndef decode_token(token):\n    \"\"\"Decode and validate JWT token\"\"\"\n    try:\n        payload = jwt.decode(\n            token,\n            app.config['SECRET_KEY'],\n            algorithms=['HS256']\n        )\n        return payload\n    except jwt.ExpiredSignatureError:\n        return None  # Token expired\n    except jwt.InvalidTokenError:\n        return None  # Invalid token\n\ndef token_required(f):\n    \"\"\"Decorator to require valid JWT token\"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = None\n        \n        # Get token from header\n        if 'Authorization' in request.headers:\n            auth_header = request.headers['Authorization']\n            # Format: \"Bearer <token>\"\n            parts = auth_header.split()\n            if len(parts) == 2 and parts[0] == 'Bearer':\n                token = parts[1]\n        \n        if not token:\n            return jsonify({'error': 'Token required'}), 401\n        \n        # Decode token\n        payload = decode_token(token)\n        if not payload:\n            return jsonify({'error': 'Invalid or expired token'}), 401\n        \n        # Store user info in request\n        request.current_user = payload\n        \n        return f(*args, **kwargs)\n    return decorated\n\ndef admin_required(f):\n    \"\"\"Decorator to require admin role\"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        if request.current_user.get('role') != 'admin':\n            return jsonify({'error': 'Admin access required'}), 403\n        return f(*args, **kwargs)\n    return decorated\n\n@app.route('/api/login', methods=['POST'])\ndef login():\n    \"\"\"Login endpoint - returns JWT token\"\"\"\n    data = request.get_json()\n    \n    if not data or 'email' not in data or 'password' not in data:\n        return jsonify({'error': 'Email and password required'}), 400\n    \n    email = data['email']\n    password = data['password']\n    \n    # Find user\n    user = USERS.get(email)\n    if not user:\n        return jsonify({'error': 'Invalid credentials'}), 401\n    \n    # Verify password\n    password_hash = hash_password(password)\n    if password_hash != user['password_hash']:\n        return jsonify({'error': 'Invalid credentials'}), 401\n    \n    # Create token\n    token = create_token(user['id'], user['role'])\n    \n    return jsonify({\n        'message': 'Login successful',\n        'token': token,\n        'user': {\n            'id': user['id'],\n            'name': user['name'],\n            'email': email,\n            'role': user['role']\n        }\n    })\n\n@app.route('/api/me', methods=['GET'])\n@token_required\ndef get_current_user():\n    \"\"\"Get current user info from token\"\"\"\n    return jsonify({\n        'user_id': request.current_user['user_id'],\n        'role': request.current_user['role']\n    })\n\n@app.route('/api/admin/users', methods=['GET'])\n@token_required\n@admin_required\ndef admin_get_users():\n    \"\"\"Admin only endpoint\"\"\"\n    users_list = [\n        {'id': u['id'], 'name': u['name'], 'role': u['role']}\n        for email, u in USERS.items()\n    ]\n    return jsonify({'users': users_list})\n\n@app.route('/api/refresh', methods=['POST'])\n@token_required\ndef refresh_token():\n    \"\"\"Refresh token endpoint\"\"\"\n    # Create new token with same user info\n    new_token = create_token(\n        request.current_user['user_id'],\n        request.current_user['role']\n    )\n    \n    return jsonify({\n        'message': 'Token refreshed',\n        'token': new_token\n    })\n\nprint(\"\\n=== Complete Security Example ===\")\n\nclass SecureAPI:\n    \"\"\"Complete API with all security features\"\"\"\n    \n    def __init__(self):\n        self.app = Flask(__name__)\n        self.app.config['SECRET_KEY'] = os.urandom(32)\n        self.users = {}\n        self.sessions = {}\n        self.setup_routes()\n    \n    def hash_password(self, password):\n        salt = os.urandom(32)\n        hash_obj = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\n        return salt + hash_obj\n    \n    def verify_password(self, stored, provided):\n        salt = stored[:32]\n        stored_hash = stored[32:]\n        test_hash = hashlib.pbkdf2_hmac('sha256', provided.encode(), salt, 100000)\n        return test_hash == stored_hash\n    \n    def create_session_token(self, user_id):\n        token = secrets.token_urlsafe(32)\n        self.sessions[token] = {\n            'user_id': user_id,\n            'created_at': datetime.utcnow(),\n            'expires_at': datetime.utcnow() + timedelta(hours=24)\n        }\n        return token\n    \n    def validate_session(self, token):\n        session = self.sessions.get(token)\n        if not session:\n            return None\n        if datetime.utcnow() > session['expires_at']:\n            del self.sessions[token]\n            return None\n        return session\n    \n    def setup_routes(self):\n        @self.app.route('/api/register', methods=['POST'])\n        def register():\n            data = request.get_json()\n            \n            # Validation\n            if not data or 'email' not in data or 'password' not in data:\n                return jsonify({'error': 'Email and password required'}), 400\n            \n            if len(data['password']) < 8:\n                return jsonify({'error': 'Password must be at least 8 characters'}), 400\n            \n            email = data['email'].lower().strip()\n            \n            if email in self.users:\n                return jsonify({'error': 'User already exists'}), 409\n            \n            # Create user\n            self.users[email] = {\n                'id': len(self.users) + 1,\n                'email': email,\n                'password_hash': self.hash_password(data['password']),\n                'created_at': datetime.utcnow().isoformat()\n            }\n            \n            return jsonify({\n                'message': 'User created successfully',\n                'user': {'id': self.users[email]['id'], 'email': email}\n            }), 201\n\nif __name__ == '__main__':\n    print(\"\\n=== JWT Authentication API ===\")\n    print(\"\\nEndpoints:\")\n    print(\"  POST /api/login        - Login and get token\")\n    print(\"  GET  /api/me           - Get current user (requires token)\")\n    print(\"  GET  /api/admin/users  - Admin only (requires admin token)\")\n    print(\"  POST /api/refresh      - Refresh token\")\n    print(\"\\nExample login:\")\n    print('  POST /api/login')\n    print('  {\"email\": \"alice@example.com\", \"password\": \"password123\"}')\n    print(\"\\nExample authenticated request:\")\n    print('  GET /api/me')\n    print('  Header: Authorization: Bearer <token>')\n    print(\"\\nSecurity features:\")\n    print(\"  âœ“ JWT tokens with expiration\")\n    print(\"  âœ“ Password hashing\")\n    print(\"  âœ“ Role-based access control\")\n    print(\"  âœ“ Token refresh mechanism\")\n    print(\"  âœ“ Decorator-based auth\")",
      "explanation": "**JWT Authentication Flow:**\n\n**1. Login:**\n```\nUser â†’ POST /api/login (email, password)\nAPI â†’ Verify credentials\nAPI â†’ Create JWT token\nAPI â†’ Return token to user\n```\n\n**2. Authenticated Request:**\n```\nUser â†’ GET /api/protected\nHeader: Authorization: Bearer <token>\nAPI â†’ Decode token\nAPI â†’ Verify signature and expiration\nAPI â†’ Process request\n```\n\n**3. Token Structure:**\n```json\n{\n  \"user_id\": 1,\n  \"role\": \"admin\",\n  \"exp\": 1234567890,  // Expiration timestamp\n  \"iat\": 1234567000   // Issued at timestamp\n}\n```\n\n**Security Benefits:**\n- Stateless (no server-side sessions)\n- Self-contained (user info in token)\n- Expires automatically\n- Can't be modified without secret key\n- Works across multiple servers\n\n**Best Practices:**\n- Short expiration (1-24 hours)\n- HTTPS only\n- Secure secret key\n- Include minimal info in payload\n- Implement token refresh",
      "output": "=== JWT Token Authentication ===\n\n=== Complete Security Example ===\n\n=== JWT Authentication API ===\n\nEndpoints:\n  POST /api/login        - Login and get token\n  GET  /api/me           - Get current user (requires token)\n  GET  /api/admin/users  - Admin only (requires admin token)\n  POST /api/refresh      - Refresh token\n\nExample login:\n  POST /api/login\n  {\"email\": \"alice@example.com\", \"password\": \"password123\"}\n\nExample authenticated request:\n  GET /api/me\n  Header: Authorization: Bearer <token>\n\nSecurity features:\n  âœ“ JWT tokens with expiration\n  âœ“ Password hashing\n  âœ“ Role-based access control\n  âœ“ Token refresh mechanism\n  âœ“ Decorator-based auth"
    },
    {
      "type": "the_coder",
      "title": "Interactive Exercise",
      "instruction": "Create a secure user registration and login system:\n- POST /api/register - Create user with hashed password\n- POST /api/login - Login with email/password, return JWT token\n- GET /api/profile - Get user profile (requires token)\n- Validate email format and password strength (min 8 chars)\n- Hash passwords before storing",
      "starter_code": "from flask import Flask, jsonify, request\nimport jwt\nimport hashlib\nimport os\nfrom datetime import datetime, timedelta\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'change-this-secret-key'\n\nusers = {}  # In-memory user storage\n\n# TODO: Implement password hashing\ndef hash_password(password):\n    pass\n\n# TODO: Implement password verification\ndef verify_password(stored_hash, provided_password):\n    pass\n\n# TODO: Implement JWT token creation\ndef create_token(user_id):\n    pass\n\n# TODO: Implement /api/register endpoint\n\n# TODO: Implement /api/login endpoint\n\n# TODO: Implement /api/profile endpoint with token verification\n\nif __name__ == '__main__':\n    app.run(debug=True)",
      "hint": "Use hashlib.pbkdf2_hmac for password hashing. Use jwt.encode() for tokens. Check Authorization header for Bearer token."
    },
    {
      "type": "the_coder",
      "title": "Solution",
      "solution_code": "from flask import Flask, jsonify, request\nimport jwt\nimport hashlib\nimport os\nimport re\nfrom datetime import datetime, timedelta\nfrom functools import wraps\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.urandom(32)  # Random secret key\n\nusers = {}  # In-memory user storage\n\ndef hash_password(password):\n    \"\"\"Hash password with random salt\"\"\"\n    salt = os.urandom(32)\n    pwd_hash = hashlib.pbkdf2_hmac(\n        'sha256',\n        password.encode('utf-8'),\n        salt,\n        100000\n    )\n    return salt + pwd_hash\n\ndef verify_password(stored_hash, provided_password):\n    \"\"\"Verify password against stored hash\"\"\"\n    salt = stored_hash[:32]\n    stored_pwd_hash = stored_hash[32:]\n    \n    test_hash = hashlib.pbkdf2_hmac(\n        'sha256',\n        provided_password.encode('utf-8'),\n        salt,\n        100000\n    )\n    \n    return test_hash == stored_pwd_hash\n\ndef validate_email(email):\n    \"\"\"Validate email format\"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n\ndef validate_password(password):\n    \"\"\"Validate password strength\"\"\"\n    errors = []\n    \n    if len(password) < 8:\n        errors.append('Password must be at least 8 characters')\n    \n    if not re.search(r'[A-Z]', password):\n        errors.append('Password must contain at least one uppercase letter')\n    \n    if not re.search(r'[a-z]', password):\n        errors.append('Password must contain at least one lowercase letter')\n    \n    if not re.search(r'\\d', password):\n        errors.append('Password must contain at least one digit')\n    \n    return errors\n\ndef create_token(user_id, email):\n    \"\"\"Create JWT token\"\"\"\n    payload = {\n        'user_id': user_id,\n        'email': email,\n        'exp': datetime.utcnow() + timedelta(hours=24),\n        'iat': datetime.utcnow()\n    }\n    \n    return jwt.encode(payload, app.config['SECRET_KEY'], algorithm='HS256')\n\ndef token_required(f):\n    \"\"\"Decorator to require valid token\"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = None\n        \n        if 'Authorization' in request.headers:\n            auth_header = request.headers['Authorization']\n            parts = auth_header.split()\n            \n            if len(parts) == 2 and parts[0] == 'Bearer':\n                token = parts[1]\n        \n        if not token:\n            return jsonify({'error': 'Token required'}), 401\n        \n        try:\n            payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])\n            request.current_user = payload\n        except jwt.ExpiredSignatureError:\n            return jsonify({'error': 'Token has expired'}), 401\n        except jwt.InvalidTokenError:\n            return jsonify({'error': 'Invalid token'}), 401\n        \n        return f(*args, **kwargs)\n    return decorated\n\n@app.route('/api/register', methods=['POST'])\ndef register():\n    \"\"\"Register new user\"\"\"\n    data = request.get_json()\n    \n    # Validation\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    if 'email' not in data or 'password' not in data:\n        return jsonify({'error': 'Email and password required'}), 400\n    \n    email = data['email'].lower().strip()\n    password = data['password']\n    name = data.get('name', '').strip()\n    \n    # Validate email\n    if not validate_email(email):\n        return jsonify({'error': 'Invalid email format'}), 400\n    \n    # Validate password\n    pwd_errors = validate_password(password)\n    if pwd_errors:\n        return jsonify({'error': 'Password validation failed', 'details': pwd_errors}), 400\n    \n    # Check if user exists\n    if email in users:\n        return jsonify({'error': 'User already exists'}), 409\n    \n    # Create user\n    user_id = len(users) + 1\n    users[email] = {\n        'id': user_id,\n        'email': email,\n        'name': name or email.split('@')[0],\n        'password_hash': hash_password(password),\n        'created_at': datetime.utcnow().isoformat()\n    }\n    \n    # Create token\n    token = create_token(user_id, email)\n    \n    return jsonify({\n        'message': 'User registered successfully',\n        'token': token,\n        'user': {\n            'id': user_id,\n            'email': email,\n            'name': users[email]['name']\n        }\n    }), 201\n\n@app.route('/api/login', methods=['POST'])\ndef login():\n    \"\"\"Login user\"\"\"\n    data = request.get_json()\n    \n    if not data or 'email' not in data or 'password' not in data:\n        return jsonify({'error': 'Email and password required'}), 400\n    \n    email = data['email'].lower().strip()\n    password = data['password']\n    \n    # Find user\n    user = users.get(email)\n    if not user:\n        return jsonify({'error': 'Invalid credentials'}), 401\n    \n    # Verify password\n    if not verify_password(user['password_hash'], password):\n        return jsonify({'error': 'Invalid credentials'}), 401\n    \n    # Create token\n    token = create_token(user['id'], email)\n    \n    return jsonify({\n        'message': 'Login successful',\n        'token': token,\n        'user': {\n            'id': user['id'],\n            'email': user['email'],\n            'name': user['name']\n        }\n    })\n\n@app.route('/api/profile', methods=['GET'])\n@token_required\ndef get_profile():\n    \"\"\"Get user profile (requires authentication)\"\"\"\n    email = request.current_user['email']\n    user = users.get(email)\n    \n    if not user:\n        return jsonify({'error': 'User not found'}), 404\n    \n    return jsonify({\n        'id': user['id'],\n        'email': user['email'],\n        'name': user['name'],\n        'created_at': user['created_at']\n    })\n\n@app.route('/api/profile', methods=['PUT'])\n@token_required\ndef update_profile():\n    \"\"\"Update user profile\"\"\"\n    email = request.current_user['email']\n    user = users.get(email)\n    \n    if not user:\n        return jsonify({'error': 'User not found'}), 404\n    \n    data = request.get_json()\n    \n    # Update name if provided\n    if 'name' in data:\n        user['name'] = data['name'].strip()\n    \n    return jsonify({\n        'message': 'Profile updated',\n        'user': {\n            'id': user['id'],\n            'email': user['email'],\n            'name': user['name']\n        }\n    })\n\n@app.route('/api/change-password', methods=['POST'])\n@token_required\ndef change_password():\n    \"\"\"Change user password\"\"\"\n    email = request.current_user['email']\n    user = users.get(email)\n    \n    if not user:\n        return jsonify({'error': 'User not found'}), 404\n    \n    data = request.get_json()\n    \n    if not data or 'current_password' not in data or 'new_password' not in data:\n        return jsonify({'error': 'Current and new password required'}), 400\n    \n    # Verify current password\n    if not verify_password(user['password_hash'], data['current_password']):\n        return jsonify({'error': 'Current password incorrect'}), 401\n    \n    # Validate new password\n    pwd_errors = validate_password(data['new_password'])\n    if pwd_errors:\n        return jsonify({'error': 'Password validation failed', 'details': pwd_errors}), 400\n    \n    # Update password\n    user['password_hash'] = hash_password(data['new_password'])\n    \n    return jsonify({'message': 'Password changed successfully'})\n\n@app.route('/')\ndef home():\n    return jsonify({\n        'name': 'Secure Auth API',\n        'version': '1.0',\n        'endpoints': {\n            'Register': 'POST /api/register',\n            'Login': 'POST /api/login',\n            'Get Profile': 'GET /api/profile (requires token)',\n            'Update Profile': 'PUT /api/profile (requires token)',\n            'Change Password': 'POST /api/change-password (requires token)'\n        }\n    })\n\nif __name__ == '__main__':\n    print(\"=== Secure Authentication API ===\")\n    print(\"\\nFeatures:\")\n    print(\"  âœ“ User registration with validation\")\n    print(\"  âœ“ Password hashing (PBKDF2 with salt)\")\n    print(\"  âœ“ Email validation\")\n    print(\"  âœ“ Password strength requirements\")\n    print(\"  âœ“ JWT token authentication\")\n    print(\"  âœ“ Protected routes\")\n    print(\"  âœ“ Profile management\")\n    print(\"  âœ“ Password change\")\n    print(\"\\nExample registration:\")\n    print('  POST /api/register')\n    print('  {\"email\": \"user@example.com\", \"password\": \"SecurePass123\", \"name\": \"User\"}')\n    print(\"\\nExample login:\")\n    print('  POST /api/login')\n    print('  {\"email\": \"user@example.com\", \"password\": \"SecurePass123\"}')\n    print(\"\\nExample authenticated request:\")\n    print('  GET /api/profile')\n    print('  Header: Authorization: Bearer <token>')\n    print(\"\\nPassword requirements:\")\n    print(\"  - At least 8 characters\")\n    print(\"  - At least one uppercase letter\")\n    print(\"  - At least one lowercase letter\")\n    print(\"  - At least one digit\")\n    \n    # Don't run the server, just show the structure\n    # app.run(debug=True)",
      "explanation": "**Complete secure authentication system:**\n\n**Security Features:**\n\n1. **Password Hashing:**\n   - PBKDF2 with random salt\n   - 100,000 iterations\n   - Never stores plain passwords\n\n2. **Password Validation:**\n   - Minimum 8 characters\n   - Requires uppercase, lowercase, digit\n   - Clear error messages\n\n3. **Email Validation:**\n   - Regex pattern matching\n   - Prevents invalid emails\n\n4. **JWT Tokens:**\n   - 24-hour expiration\n   - Contains user ID and email\n   - Verified on each request\n\n5. **Protected Routes:**\n   - @token_required decorator\n   - Auto-validates token\n   - Extracts user info\n\n6. **Password Change:**\n   - Verifies current password\n   - Validates new password\n   - Re-hashes and stores\n\n**Best Practices:**\n- Never log passwords\n- Use HTTPS in production\n- Rotate secret keys\n- Implement rate limiting\n- Add account lockout after failed attempts\n- Email verification (not shown)\n- Password reset flow (not shown)",
      "output": "=== Secure Authentication API ===\n\nFeatures:\n  âœ“ User registration with validation\n  âœ“ Password hashing (PBKDF2 with salt)\n  âœ“ Email validation\n  âœ“ Password strength requirements\n  âœ“ JWT token authentication\n  âœ“ Protected routes\n  âœ“ Profile management\n  âœ“ Password change\n\nExample registration:\n  POST /api/register\n  {\"email\": \"user@example.com\", \"password\": \"SecurePass123\", \"name\": \"User\"}\n\nExample login:\n  POST /api/login\n  {\"email\": \"user@example.com\", \"password\": \"SecurePass123\"}\n\nExample authenticated request:\n  GET /api/profile\n  Header: Authorization: Bearer <token>\n\nPassword requirements:\n  - At least 8 characters\n  - At least one uppercase letter\n  - At least one lowercase letter\n  - At least one digit",
      "common_mistakes": [
        "Storing passwords in plain text - ALWAYS hash them",
        "Using weak hashing (MD5, SHA1) - use PBKDF2, bcrypt, or Argon2",
        "Not using salt - makes rainbow table attacks possible",
        "Weak password requirements - enforce strength rules",
        "Not validating input - leads to injection attacks",
        "Long token expiration - tokens should expire",
        "Not using HTTPS - credentials sent in plain text",
        "Exposing detailed error messages - helps attackers"
      ]
    },
    {
      "type": "key_takeaways",
      "title": "Key Takeaways",
      "takeaways": [
        "**Never store plain passwords** - Always hash with salt (PBKDF2, bcrypt)",
        "**JWT tokens for authentication** - Self-contained, stateless, expire automatically",
        "**Use decorators for auth** - @require_api_key, @token_required",
        "**Validate all input** - Email format, password strength, data sanitization",
        "**Rate limiting prevents abuse** - Track requests per time window",
        "**CORS for browser clients** - Control which domains can access API",
        "**HTTPS in production** - Encrypt data in transit",
        "**Principle of least privilege** - Give minimum permissions needed"
      ]
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "Why should you never store passwords in plain text?",
        "options": [
          "It's slower",
          "If database is compromised, all passwords are exposed",
          "It uses more storage",
          "Plain text doesn't work"
        ],
        "correct_answer": 1,
        "explanation": "Storing plain passwords means if the database is breached, attackers get all passwords. Always hash passwords with salt."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "What does JWT stand for?",
        "options": [
          "JavaScript Web Technology",
          "JSON Web Token",
          "Java Web Template",
          "Just Working Token"
        ],
        "correct_answer": 1,
        "explanation": "JWT stands for JSON Web Token - a compact, URL-safe token format for securely transmitting information between parties."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "What HTTP status code should you return for unauthorized requests?",
        "options": [
          "400",
          "401",
          "403",
          "404"
        ],
        "correct_answer": 1,
        "explanation": "401 Unauthorized is for missing or invalid authentication. 403 Forbidden is for valid auth but insufficient permissions."
      }
    ]
  }
}
