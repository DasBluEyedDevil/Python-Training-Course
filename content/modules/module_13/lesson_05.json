{
  "lesson_id": 5,
  "module_id": 13,
  "title": "API Testing and Documentation",
  "duration": "45 minutes",
  "objectives": [
    "Write comprehensive tests for Flask APIs using pytest",
    "Test authentication and authorization flows",
    "Implement database testing strategies with fixtures",
    "Mock external API dependencies",
    "Document APIs with clear examples and specifications",
    "Measure and improve test coverage"
  ],
  "prerequisites": [
    "Module 13 Lessons 1-4",
    "Module 7 Lesson 1: Exception Handling"
  ],
  "sections": [
    {
      "title": "The Simplifier: Concept",
      "content": "# Understanding API Testing\n\nImagine you're a quality inspector at a factory that makes smartphones. You wouldn't just test if the phone turns on - you'd check if every button works, if the camera takes clear photos, if the battery charges properly, and if all features work together correctly. You'd also write a manual explaining exactly how to use each feature.\n\n**API testing is exactly like this quality inspection process:**\n\n## The Restaurant Kitchen Analogy\n\nThink of your API as a restaurant kitchen:\n\n**1. Unit Testing (Individual Dish Testing)**\n- Like tasting each ingredient separately\n- Test one endpoint at a time in isolation\n- \"Does the GET /users endpoint return the right data?\"\n- \"Does the POST /login validate passwords correctly?\"\n- Fast and focused\n\n**2. Integration Testing (Full Meal Testing)**\n- Like testing how dishes work together in a full meal\n- Test multiple endpoints working together\n- \"Can I register → login → get profile → update profile?\"\n- \"Does authentication work across all protected routes?\"\n- More realistic scenarios\n\n**3. Database Testing (Ingredient Storage)**\n- Like checking your refrigerator before and after cooking\n- Test that data is saved and retrieved correctly\n- Use a separate test database (don't mess with production!)\n- Clean up after each test (fresh start every time)\n\n**4. Mocking (Pretend Suppliers)**\n- Like using fake ingredients when testing a recipe\n- Replace external APIs with controlled fake responses\n- \"Let's pretend the payment API always succeeds\"\n- Test your code without depending on outside services\n\n**5. Documentation (The Menu)**\n- Like a menu that explains each dish clearly\n- Show exactly how to use each endpoint\n- Include request examples and expected responses\n- Help other developers (and future you!) understand the API\n\n## Why Testing Matters\n\n**Without tests:**\n```\nYou: \"I think the API works...\"\nUser: \"Login is broken!\"\nYou: \"It worked yesterday!\"\n*Spends 3 hours debugging*\n```\n\n**With tests:**\n```\nYou: *Makes a change*\nTests: \"ERROR: Login test failed!\"\nYou: \"Oops, caught it before users saw it!\"\n*Fixes in 5 minutes*\n```\n\n## The Testing Pyramid\n\n```\n       /\\           ← Few integration tests (slow, comprehensive)\n      /  \\          \n     /____\\         ← Some functional tests (medium speed)\n    /      \\        \n   /________\\       ← Many unit tests (fast, focused)\n  /__________\\      \n```\n\n**Bottom layer (Unit Tests):** Fast, many of them, test individual functions\n**Middle layer (Functional Tests):** Test features end-to-end\n**Top layer (Integration Tests):** Test entire workflows\n\n## Real-World Example\n\nTesting a user registration endpoint:\n\n```python\n# What we're testing\n@app.route('/api/register', methods=['POST'])\ndef register():\n    data = request.get_json()\n    # Does it validate email format?\n    # Does it reject weak passwords?\n    # Does it save to database?\n    # Does it return the right status code?\n    # Does it handle duplicate emails?\n```\n\n**Our tests will check ALL of these scenarios:**\n- ✅ Valid registration works\n- ✅ Invalid email is rejected\n- ✅ Weak password is rejected\n- ✅ Duplicate email is rejected\n- ✅ Missing fields are rejected\n- ✅ Database is updated correctly\n\n## The Testing Mindset\n\nGood API testing means thinking like a detective:\n\n1. **What should work?** (Happy path)\n   - \"User provides valid data → registration succeeds\"\n\n2. **What should fail gracefully?** (Error cases)\n   - \"User provides invalid email → clear error message\"\n   - \"Database is down → service unavailable message\"\n\n3. **What edge cases exist?** (Weird scenarios)\n   - \"Email is 500 characters long\"\n   - \"Password is empty string\"\n   - \"Two users register with same email simultaneously\"\n\n## Documentation: The User's Guide\n\nGood API documentation is like a good recipe:\n\n**Bad documentation:**\n```\nPOST /api/users\nCreates a user\n```\n\n**Good documentation:**\n```\nPOST /api/users\nCreates a new user account\n\nRequest:\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"SecurePass123\",\n  \"name\": \"John Doe\"\n}\n\nResponse (201 Created):\n{\n  \"id\": 123,\n  \"email\": \"user@example.com\",\n  \"name\": \"John Doe\",\n  \"created_at\": \"2025-01-15T10:30:00Z\"\n}\n\nErrors:\n- 400: Invalid email format\n- 409: Email already exists\n- 422: Password too weak\n```\n\n## Key Insight\n\nTesting isn't extra work that slows you down - it's insurance that speeds you up in the long run. Would you rather spend 10 minutes writing a test, or 3 hours debugging a production issue at 2 AM?\n\nDocumentation isn't a chore - it's a gift to your future self and other developers. Six months from now, you won't remember how your API works. Your documentation will save you."
    },
    {
      "title": "The Coder: Code Example",
      "content": "# Complete API Testing Example\n\nLet's build a complete testing suite for a User API.\n\n## Step 1: Install pytest and testing tools\n\n```bash\npip install pytest pytest-flask\n```\n\n## Step 2: Create the API to test\n\n```python\n# app.py\nfrom flask import Flask, request, jsonify\nimport sqlite3\nimport hashlib\nimport os\nfrom functools import wraps\n\napp = Flask(__name__)\napp.config['DATABASE'] = 'users.db'\n\ndef get_db():\n    db = sqlite3.connect(app.config['DATABASE'])\n    db.row_factory = sqlite3.Row\n    return db\n\ndef init_db():\n    with app.app_context():\n        db = get_db()\n        db.execute('''CREATE TABLE IF NOT EXISTS users\n                      (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                       email TEXT UNIQUE NOT NULL,\n                       password BLOB NOT NULL,\n                       name TEXT NOT NULL,\n                       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n        db.commit()\n\ndef hash_password(password):\n    salt = os.urandom(32)\n    pwdhash = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'), salt, 100000)\n    return salt + pwdhash\n\ndef verify_password(stored_password, provided_password):\n    salt = stored_password[:32]\n    stored_hash = stored_password[32:]\n    pwdhash = hashlib.pbkdf2_hmac('sha256', provided_password.encode('utf-8'), salt, 100000)\n    return pwdhash == stored_hash\n\ndef validate_email(email):\n    import re\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\ndef validate_password(password):\n    if len(password) < 8:\n        return False, \"Password must be at least 8 characters\"\n    if not any(c.isupper() for c in password):\n        return False, \"Password must contain uppercase letter\"\n    if not any(c.islower() for c in password):\n        return False, \"Password must contain lowercase letter\"\n    if not any(c.isdigit() for c in password):\n        return False, \"Password must contain a digit\"\n    return True, \"Valid\"\n\n@app.route('/api/register', methods=['POST'])\ndef register():\n    data = request.get_json()\n    \n    # Validate required fields\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    email = data.get('email', '').strip()\n    password = data.get('password', '')\n    name = data.get('name', '').strip()\n    \n    if not email or not password or not name:\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    # Validate email\n    if not validate_email(email):\n        return jsonify({'error': 'Invalid email format'}), 400\n    \n    # Validate password\n    is_valid, message = validate_password(password)\n    if not is_valid:\n        return jsonify({'error': message}), 422\n    \n    # Check if user already exists\n    db = get_db()\n    existing_user = db.execute('SELECT id FROM users WHERE email = ?', (email,)).fetchone()\n    if existing_user:\n        return jsonify({'error': 'Email already registered'}), 409\n    \n    # Hash password and create user\n    hashed_password = hash_password(password)\n    cursor = db.execute('INSERT INTO users (email, password, name) VALUES (?, ?, ?)',\n                       (email, hashed_password, name))\n    db.commit()\n    \n    # Get created user\n    user = db.execute('SELECT id, email, name, created_at FROM users WHERE id = ?',\n                     (cursor.lastrowid,)).fetchone()\n    \n    return jsonify({\n        'id': user['id'],\n        'email': user['email'],\n        'name': user['name'],\n        'created_at': user['created_at']\n    }), 201\n\n@app.route('/api/users/<int:user_id>', methods=['GET'])\ndef get_user(user_id):\n    db = get_db()\n    user = db.execute('SELECT id, email, name, created_at FROM users WHERE id = ?',\n                     (user_id,)).fetchone()\n    \n    if not user:\n        return jsonify({'error': 'User not found'}), 404\n    \n    return jsonify({\n        'id': user['id'],\n        'email': user['email'],\n        'name': user['name'],\n        'created_at': user['created_at']\n    })\n\n@app.route('/api/users', methods=['GET'])\ndef get_users():\n    db = get_db()\n    users = db.execute('SELECT id, email, name, created_at FROM users').fetchall()\n    \n    return jsonify({\n        'users': [{\n            'id': user['id'],\n            'email': user['email'],\n            'name': user['name'],\n            'created_at': user['created_at']\n        } for user in users]\n    })\n\n@app.route('/api/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    \n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    email = data.get('email', '').strip()\n    password = data.get('password', '')\n    \n    if not email or not password:\n        return jsonify({'error': 'Missing email or password'}), 400\n    \n    db = get_db()\n    user = db.execute('SELECT * FROM users WHERE email = ?', (email,)).fetchone()\n    \n    if not user or not verify_password(user['password'], password):\n        return jsonify({'error': 'Invalid credentials'}), 401\n    \n    return jsonify({\n        'message': 'Login successful',\n        'user': {\n            'id': user['id'],\n            'email': user['email'],\n            'name': user['name']\n        }\n    })\n\nif __name__ == '__main__':\n    init_db()\n    app.run(debug=True)\n```\n\n## Step 3: Create test configuration\n\n```python\n# conftest.py\nimport pytest\nimport os\nimport tempfile\nfrom app import app as flask_app, init_db\n\n@pytest.fixture\ndef app():\n    \"\"\"Create and configure a test app instance.\"\"\"\n    # Create a temporary file for the test database\n    db_fd, db_path = tempfile.mkstemp()\n    \n    flask_app.config.update({\n        'TESTING': True,\n        'DATABASE': db_path,\n    })\n    \n    # Initialize the database\n    with flask_app.app_context():\n        init_db()\n    \n    yield flask_app\n    \n    # Cleanup\n    os.close(db_fd)\n    os.unlink(db_path)\n\n@pytest.fixture\ndef client(app):\n    \"\"\"Create a test client for the app.\"\"\"\n    return app.test_client()\n\n@pytest.fixture\ndef runner(app):\n    \"\"\"Create a test CLI runner.\"\"\"\n    return app.test_cli_runner()\n```\n\n## Step 4: Write comprehensive tests\n\n```python\n# test_api.py\nimport pytest\nimport json\n\nclass TestUserRegistration:\n    \"\"\"Test suite for user registration endpoint.\"\"\"\n    \n    def test_successful_registration(self, client):\n        \"\"\"Test that valid user registration works.\"\"\"\n        response = client.post('/api/register',\n                              json={\n                                  'email': 'test@example.com',\n                                  'password': 'SecurePass123',\n                                  'name': 'Test User'\n                              })\n        \n        assert response.status_code == 201\n        data = response.get_json()\n        assert data['email'] == 'test@example.com'\n        assert data['name'] == 'Test User'\n        assert 'id' in data\n        assert 'created_at' in data\n        assert 'password' not in data  # Should never return password\n    \n    def test_duplicate_email_rejected(self, client):\n        \"\"\"Test that duplicate emails are rejected.\"\"\"\n        # Register first user\n        client.post('/api/register',\n                   json={\n                       'email': 'test@example.com',\n                       'password': 'SecurePass123',\n                       'name': 'User One'\n                   })\n        \n        # Try to register with same email\n        response = client.post('/api/register',\n                              json={\n                                  'email': 'test@example.com',\n                                  'password': 'DifferentPass456',\n                                  'name': 'User Two'\n                              })\n        \n        assert response.status_code == 409\n        data = response.get_json()\n        assert 'error' in data\n        assert 'already registered' in data['error'].lower()\n    \n    def test_invalid_email_rejected(self, client):\n        \"\"\"Test that invalid email formats are rejected.\"\"\"\n        invalid_emails = [\n            'notanemail',\n            'missing@domain',\n            '@nodomain.com',\n            'spaces in@email.com'\n        ]\n        \n        for email in invalid_emails:\n            response = client.post('/api/register',\n                                  json={\n                                      'email': email,\n                                      'password': 'SecurePass123',\n                                      'name': 'Test User'\n                                  })\n            \n            assert response.status_code == 400\n            data = response.get_json()\n            assert 'error' in data\n    \n    def test_weak_password_rejected(self, client):\n        \"\"\"Test that weak passwords are rejected.\"\"\"\n        weak_passwords = [\n            'short',           # Too short\n            'nouppercase1',    # No uppercase\n            'NOLOWERCASE1',    # No lowercase\n            'NoDigitsHere',    # No digits\n        ]\n        \n        for password in weak_passwords:\n            response = client.post('/api/register',\n                                  json={\n                                      'email': 'test@example.com',\n                                      'password': password,\n                                      'name': 'Test User'\n                                  })\n            \n            assert response.status_code == 422\n            data = response.get_json()\n            assert 'error' in data\n    \n    def test_missing_fields_rejected(self, client):\n        \"\"\"Test that missing required fields are rejected.\"\"\"\n        # Missing email\n        response = client.post('/api/register',\n                              json={\n                                  'password': 'SecurePass123',\n                                  'name': 'Test User'\n                              })\n        assert response.status_code == 400\n        \n        # Missing password\n        response = client.post('/api/register',\n                              json={\n                                  'email': 'test@example.com',\n                                  'name': 'Test User'\n                              })\n        assert response.status_code == 400\n        \n        # Missing name\n        response = client.post('/api/register',\n                              json={\n                                  'email': 'test@example.com',\n                                  'password': 'SecurePass123'\n                              })\n        assert response.status_code == 400\n    \n    def test_no_data_rejected(self, client):\n        \"\"\"Test that requests with no data are rejected.\"\"\"\n        response = client.post('/api/register')\n        assert response.status_code == 400\n\nclass TestUserRetrieval:\n    \"\"\"Test suite for user retrieval endpoints.\"\"\"\n    \n    @pytest.fixture\n    def sample_user(self, client):\n        \"\"\"Create a sample user for testing.\"\"\"\n        response = client.post('/api/register',\n                              json={\n                                  'email': 'sample@example.com',\n                                  'password': 'SecurePass123',\n                                  'name': 'Sample User'\n                              })\n        return response.get_json()\n    \n    def test_get_existing_user(self, client, sample_user):\n        \"\"\"Test retrieving an existing user.\"\"\"\n        response = client.get(f'/api/users/{sample_user[\"id\"]}')\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert data['id'] == sample_user['id']\n        assert data['email'] == sample_user['email']\n        assert data['name'] == sample_user['name']\n        assert 'password' not in data\n    \n    def test_get_nonexistent_user(self, client):\n        \"\"\"Test retrieving a non-existent user.\"\"\"\n        response = client.get('/api/users/99999')\n        \n        assert response.status_code == 404\n        data = response.get_json()\n        assert 'error' in data\n    \n    def test_get_all_users(self, client, sample_user):\n        \"\"\"Test retrieving all users.\"\"\"\n        # Create another user\n        client.post('/api/register',\n                   json={\n                       'email': 'another@example.com',\n                       'password': 'SecurePass123',\n                       'name': 'Another User'\n                   })\n        \n        response = client.get('/api/users')\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert 'users' in data\n        assert len(data['users']) == 2\n        \n        # Check that passwords are not included\n        for user in data['users']:\n            assert 'password' not in user\n\nclass TestLogin:\n    \"\"\"Test suite for login endpoint.\"\"\"\n    \n    @pytest.fixture\n    def registered_user(self, client):\n        \"\"\"Create a registered user for login tests.\"\"\"\n        client.post('/api/register',\n                   json={\n                       'email': 'login@example.com',\n                       'password': 'SecurePass123',\n                       'name': 'Login User'\n                   })\n        return {\n            'email': 'login@example.com',\n            'password': 'SecurePass123'\n        }\n    \n    def test_successful_login(self, client, registered_user):\n        \"\"\"Test that valid credentials allow login.\"\"\"\n        response = client.post('/api/login',\n                              json={\n                                  'email': registered_user['email'],\n                                  'password': registered_user['password']\n                              })\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert 'message' in data\n        assert 'user' in data\n        assert data['user']['email'] == registered_user['email']\n    \n    def test_invalid_email(self, client, registered_user):\n        \"\"\"Test that invalid email fails login.\"\"\"\n        response = client.post('/api/login',\n                              json={\n                                  'email': 'wrong@example.com',\n                                  'password': registered_user['password']\n                              })\n        \n        assert response.status_code == 401\n        data = response.get_json()\n        assert 'error' in data\n    \n    def test_invalid_password(self, client, registered_user):\n        \"\"\"Test that invalid password fails login.\"\"\"\n        response = client.post('/api/login',\n                              json={\n                                  'email': registered_user['email'],\n                                  'password': 'WrongPassword123'\n                              })\n        \n        assert response.status_code == 401\n        data = response.get_json()\n        assert 'error' in data\n    \n    def test_missing_credentials(self, client):\n        \"\"\"Test that missing credentials are rejected.\"\"\"\n        # Missing password\n        response = client.post('/api/login',\n                              json={'email': 'test@example.com'})\n        assert response.status_code == 400\n        \n        # Missing email\n        response = client.post('/api/login',\n                              json={'password': 'SecurePass123'})\n        assert response.status_code == 400\n\nclass TestDatabaseIntegration:\n    \"\"\"Test suite for database operations.\"\"\"\n    \n    def test_user_persists_in_database(self, client):\n        \"\"\"Test that registered user is actually saved to database.\"\"\"\n        # Register user\n        response = client.post('/api/register',\n                              json={\n                                  'email': 'persist@example.com',\n                                  'password': 'SecurePass123',\n                                  'name': 'Persist User'\n                              })\n        user_id = response.get_json()['id']\n        \n        # Retrieve user - should still exist\n        response = client.get(f'/api/users/{user_id}')\n        assert response.status_code == 200\n        \n        data = response.get_json()\n        assert data['email'] == 'persist@example.com'\n    \n    def test_password_hashed_in_database(self, client):\n        \"\"\"Test that passwords are hashed, not stored in plain text.\"\"\"\n        from app import get_db\n        \n        # Register user\n        client.post('/api/register',\n                   json={\n                       'email': 'hash@example.com',\n                       'password': 'SecurePass123',\n                       'name': 'Hash User'\n                   })\n        \n        # Check database directly\n        with client.application.app_context():\n            db = get_db()\n            user = db.execute('SELECT password FROM users WHERE email = ?',\n                            ('hash@example.com',)).fetchone()\n            \n            # Password should be binary (hashed)\n            assert isinstance(user['password'], bytes)\n            # Should not contain the plain text password\n            assert b'SecurePass123' not in user['password']\n```\n\n## Step 5: Run the tests\n\n```bash\n# Run all tests\npytest test_api.py -v\n\n# Run with coverage report\npytest test_api.py --cov=app --cov-report=html\n\n# Run specific test class\npytest test_api.py::TestUserRegistration -v\n\n# Run specific test\npytest test_api.py::TestUserRegistration::test_successful_registration -v\n```\n\n## Output:\n\n```\ntest_api.py::TestUserRegistration::test_successful_registration PASSED\ntest_api.py::TestUserRegistration::test_duplicate_email_rejected PASSED\ntest_api.py::TestUserRegistration::test_invalid_email_rejected PASSED\ntest_api.py::TestUserRegistration::test_weak_password_rejected PASSED\ntest_api.py::TestUserRegistration::test_missing_fields_rejected PASSED\ntest_api.py::TestUserRegistration::test_no_data_rejected PASSED\ntest_api.py::TestUserRetrieval::test_get_existing_user PASSED\ntest_api.py::TestUserRetrieval::test_get_nonexistent_user PASSED\ntest_api.py::TestUserRetrieval::test_get_all_users PASSED\ntest_api.py::TestLogin::test_successful_login PASSED\ntest_api.py::TestLogin::test_invalid_email PASSED\ntest_api.py::TestLogin::test_invalid_password PASSED\ntest_api.py::TestLogin::test_missing_credentials PASSED\ntest_api.py::TestDatabaseIntegration::test_user_persists_in_database PASSED\ntest_api.py::TestDatabaseIntegration::test_password_hashed_in_database PASSED\n\n=============== 15 passed in 0.45s ===============\n\nCoverage Report:\nName     Stmts   Miss  Cover\n----------------------------\napp.py      95      3    97%\n----------------------------\nTOTAL       95      3    97%\n```\n\n## Key Observations:\n\n1. **All 15 tests passed** - Our API works correctly!\n2. **97% code coverage** - Most of our code is tested\n3. **Fast execution** - 15 tests in under half a second\n4. **Organized test classes** - Easy to find and run specific tests\n5. **Each test is focused** - Tests one thing, easy to debug if it fails"
    },
    {
      "title": "The Simplifier: Syntax Breakdown",
      "content": "# Understanding API Testing Syntax\n\nLet's break down the testing code piece by piece.\n\n## pytest Basics\n\n### 1. Test Functions\n\n```python\ndef test_successful_registration(self, client):\n    \"\"\"Test that valid user registration works.\"\"\"\n    # Test code here\n```\n\n**Breakdown:**\n- `test_` prefix - pytest automatically finds functions starting with `test_`\n- Function name describes what we're testing\n- `client` parameter - pytest fixture (explained below)\n- Docstring - explains what this test does\n\n### 2. Fixtures\n\n```python\n@pytest.fixture\ndef app():\n    \"\"\"Create and configure a test app instance.\"\"\"\n    db_fd, db_path = tempfile.mkstemp()\n    \n    flask_app.config.update({\n        'TESTING': True,\n        'DATABASE': db_path,\n    })\n    \n    with flask_app.app_context():\n        init_db()\n    \n    yield flask_app\n    \n    os.close(db_fd)\n    os.unlink(db_path)\n```\n\n**What this does:**\n\n```python\n@pytest.fixture          # Mark as reusable test component\ndef app():               # Fixture name\n```\n\n```python\n    db_fd, db_path = tempfile.mkstemp()\n    # Create temporary database file\n    # db_fd = file descriptor (for closing later)\n    # db_path = path to temp file\n```\n\n```python\n    flask_app.config.update({\n        'TESTING': True,      # Enable test mode\n        'DATABASE': db_path,  # Use temp database\n    })\n    # Configure app for testing\n```\n\n```python\n    with flask_app.app_context():\n        init_db()\n    # Initialize database with tables\n```\n\n```python\n    yield flask_app\n    # Give the configured app to the test\n    # Tests run here...\n    # Then cleanup code below runs\n```\n\n```python\n    os.close(db_fd)\n    os.unlink(db_path)\n    # Cleanup: close and delete temp database\n```\n\n**Why use fixtures?**\n- Reusable setup code\n- Automatic cleanup (even if test fails)\n- Can depend on other fixtures\n\n### 3. Test Client\n\n```python\n@pytest.fixture\ndef client(app):\n    \"\"\"Create a test client for the app.\"\"\"\n    return app.test_client()\n```\n\n**Breakdown:**\n- `client(app)` - This fixture needs the `app` fixture\n- `app.test_client()` - Flask's built-in test client\n- Returns object that can make HTTP requests\n\n**Using the client:**\n\n```python\ndef test_something(client):\n    # Make GET request\n    response = client.get('/api/users')\n    \n    # Make POST request with JSON\n    response = client.post('/api/register',\n                          json={'email': 'test@example.com'})\n    \n    # Get response data\n    data = response.get_json()\n    \n    # Check status code\n    assert response.status_code == 200\n```\n\n## Assertions\n\n### Basic Assertions\n\n```python\nassert response.status_code == 201\n# Check that status code is exactly 201\n\nassert data['email'] == 'test@example.com'\n# Check that email matches expected value\n\nassert 'id' in data\n# Check that 'id' key exists in data\n\nassert 'password' not in data\n# Check that 'password' key does NOT exist\n```\n\n### What happens if assertion fails?\n\n```python\nassert response.status_code == 201\n# If actual status is 400, pytest shows:\n# AssertionError: assert 400 == 201\n```\n\n## Test Classes\n\n```python\nclass TestUserRegistration:\n    \"\"\"Test suite for user registration endpoint.\"\"\"\n    \n    def test_successful_registration(self, client):\n        # Test code\n    \n    def test_duplicate_email_rejected(self, client):\n        # Test code\n```\n\n**Why use classes?**\n- Organize related tests together\n- Share fixtures within the class\n- Easier to run all tests for one feature\n\n```bash\n# Run all registration tests\npytest test_api.py::TestUserRegistration\n\n# Run specific test\npytest test_api.py::TestUserRegistration::test_successful_registration\n```\n\n## Fixture Scope\n\n```python\n@pytest.fixture\ndef sample_user(self, client):\n    \"\"\"Create a sample user for testing.\"\"\"\n    response = client.post('/api/register',\n                          json={\n                              'email': 'sample@example.com',\n                              'password': 'SecurePass123',\n                              'name': 'Sample User'\n                          })\n    return response.get_json()\n```\n\n**How it works:**\n\n```python\ndef test_get_existing_user(self, client, sample_user):\n    # sample_user fixture runs first\n    # It creates a user and returns the data\n    # Now we can use that user in our test\n    \n    response = client.get(f'/api/users/{sample_user[\"id\"]}')\n    assert response.status_code == 200\n```\n\n**Execution order:**\n1. `app` fixture runs (creates test app)\n2. `client` fixture runs (creates test client from app)\n3. `sample_user` fixture runs (uses client to create user)\n4. Test function runs (uses sample_user data)\n5. Cleanup runs in reverse order\n\n## Testing Patterns\n\n### 1. Arrange-Act-Assert (AAA)\n\n```python\ndef test_successful_registration(self, client):\n    # ARRANGE - Set up test data\n    user_data = {\n        'email': 'test@example.com',\n        'password': 'SecurePass123',\n        'name': 'Test User'\n    }\n    \n    # ACT - Perform the action\n    response = client.post('/api/register', json=user_data)\n    \n    # ASSERT - Check the results\n    assert response.status_code == 201\n    data = response.get_json()\n    assert data['email'] == 'test@example.com'\n```\n\n### 2. Parametrized Tests\n\n```python\ndef test_invalid_email_rejected(self, client):\n    invalid_emails = [\n        'notanemail',\n        'missing@domain',\n        '@nodomain.com',\n    ]\n    \n    for email in invalid_emails:\n        response = client.post('/api/register',\n                              json={\n                                  'email': email,\n                                  'password': 'SecurePass123',\n                                  'name': 'Test User'\n                              })\n        \n        assert response.status_code == 400\n```\n\n**What this does:**\n- Test same logic with multiple inputs\n- If any email test fails, we know which one\n- Cleaner than writing 3 separate test functions\n\n### 3. Testing Errors\n\n```python\ndef test_get_nonexistent_user(self, client):\n    # Try to get user that doesn't exist\n    response = client.get('/api/users/99999')\n    \n    # Should return 404 Not Found\n    assert response.status_code == 404\n    \n    # Should return error message\n    data = response.get_json()\n    assert 'error' in data\n```\n\n**Key insight:** Test both success AND failure cases!\n\n## pytest Command Options\n\n```bash\n# Run all tests\npytest\n\n# Verbose output (show each test name)\npytest -v\n\n# Run specific file\npytest test_api.py\n\n# Run specific class\npytest test_api.py::TestUserRegistration\n\n# Run specific test\npytest test_api.py::TestUserRegistration::test_successful_registration\n\n# Stop on first failure\npytest -x\n\n# Show print statements\npytest -s\n\n# Coverage report\npytest --cov=app --cov-report=html\n```\n\n## Coverage Report Explained\n\n```\nName     Stmts   Miss  Cover\n----------------------------\napp.py      95      3    97%\n```\n\n- **Stmts:** Total lines of code\n- **Miss:** Lines NOT executed by tests\n- **Cover:** Percentage covered\n\n**97% coverage means:**\n- 92 out of 95 lines were executed during tests\n- 3 lines were never run (might need more tests)\n\n## Common Testing Patterns\n\n### Pattern 1: Test Happy Path\n\n```python\ndef test_successful_registration(self, client):\n    # Test that valid input works\n```\n\n### Pattern 2: Test Validation\n\n```python\ndef test_invalid_email_rejected(self, client):\n    # Test that invalid input is rejected\n\ndef test_weak_password_rejected(self, client):\n    # Test that bad data is caught\n```\n\n### Pattern 3: Test Edge Cases\n\n```python\ndef test_duplicate_email_rejected(self, client):\n    # Test boundary condition\n\ndef test_missing_fields_rejected(self, client):\n    # Test incomplete data\n```\n\n### Pattern 4: Test Integration\n\n```python\ndef test_user_persists_in_database(self, client):\n    # Test that changes actually save\n```\n\n## Key Takeaways\n\n1. **`test_` prefix** - pytest finds your tests\n2. **Fixtures** - Reusable setup with automatic cleanup\n3. **Test client** - Makes HTTP requests to your API\n4. **Assertions** - Check that results match expectations\n5. **Classes** - Organize related tests\n6. **AAA pattern** - Arrange, Act, Assert\n7. **Test both success and failure** - Happy path AND error cases"
    },
    {
      "title": "The Coder: Interactive Exercise",
      "content": "# Exercise: Build a Complete Test Suite for a Task API\n\nYou're building a task management API. Write comprehensive tests for it!\n\n## The API to Test\n\n```python\n# task_api.py\nfrom flask import Flask, request, jsonify\nimport sqlite3\nfrom datetime import datetime\n\napp = Flask(__name__)\napp.config['DATABASE'] = 'tasks.db'\n\ndef get_db():\n    db = sqlite3.connect(app.config['DATABASE'])\n    db.row_factory = sqlite3.Row\n    return db\n\ndef init_db():\n    with app.app_context():\n        db = get_db()\n        db.execute('''CREATE TABLE IF NOT EXISTS tasks\n                      (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                       title TEXT NOT NULL,\n                       description TEXT,\n                       status TEXT DEFAULT 'pending',\n                       priority TEXT DEFAULT 'medium',\n                       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                       completed_at TIMESTAMP)''')\n        db.commit()\n\n@app.route('/api/tasks', methods=['POST'])\ndef create_task():\n    data = request.get_json()\n    \n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    title = data.get('title', '').strip()\n    description = data.get('description', '').strip()\n    priority = data.get('priority', 'medium')\n    \n    # Validation\n    if not title:\n        return jsonify({'error': 'Title is required'}), 400\n    \n    if len(title) > 200:\n        return jsonify({'error': 'Title too long (max 200 characters)'}), 400\n    \n    if priority not in ['low', 'medium', 'high']:\n        return jsonify({'error': 'Invalid priority. Must be: low, medium, or high'}), 400\n    \n    # Create task\n    db = get_db()\n    cursor = db.execute(\n        'INSERT INTO tasks (title, description, priority) VALUES (?, ?, ?)',\n        (title, description, priority)\n    )\n    db.commit()\n    \n    # Get created task\n    task = db.execute('SELECT * FROM tasks WHERE id = ?', (cursor.lastrowid,)).fetchone()\n    \n    return jsonify({\n        'id': task['id'],\n        'title': task['title'],\n        'description': task['description'],\n        'status': task['status'],\n        'priority': task['priority'],\n        'created_at': task['created_at']\n    }), 201\n\n@app.route('/api/tasks/<int:task_id>', methods=['PUT'])\ndef update_task(task_id):\n    data = request.get_json()\n    \n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n    \n    db = get_db()\n    task = db.execute('SELECT * FROM tasks WHERE id = ?', (task_id,)).fetchone()\n    \n    if not task:\n        return jsonify({'error': 'Task not found'}), 404\n    \n    # Get fields to update\n    title = data.get('title', task['title']).strip()\n    description = data.get('description', task['description'])\n    status = data.get('status', task['status'])\n    priority = data.get('priority', task['priority'])\n    \n    # Validation\n    if not title:\n        return jsonify({'error': 'Title cannot be empty'}), 400\n    \n    if len(title) > 200:\n        return jsonify({'error': 'Title too long (max 200 characters)'}), 400\n    \n    if status not in ['pending', 'in_progress', 'completed']:\n        return jsonify({'error': 'Invalid status'}), 400\n    \n    if priority not in ['low', 'medium', 'high']:\n        return jsonify({'error': 'Invalid priority'}), 400\n    \n    # Set completed_at if status changed to completed\n    completed_at = None\n    if status == 'completed' and task['status'] != 'completed':\n        completed_at = datetime.utcnow().isoformat()\n    elif status != 'completed':\n        completed_at = None\n    else:\n        completed_at = task['completed_at']\n    \n    # Update task\n    db.execute(\n        '''UPDATE tasks \n           SET title = ?, description = ?, status = ?, priority = ?, completed_at = ?\n           WHERE id = ?''',\n        (title, description, status, priority, completed_at, task_id)\n    )\n    db.commit()\n    \n    # Get updated task\n    updated_task = db.execute('SELECT * FROM tasks WHERE id = ?', (task_id,)).fetchone()\n    \n    return jsonify({\n        'id': updated_task['id'],\n        'title': updated_task['title'],\n        'description': updated_task['description'],\n        'status': updated_task['status'],\n        'priority': updated_task['priority'],\n        'created_at': updated_task['created_at'],\n        'completed_at': updated_task['completed_at']\n    })\n\n@app.route('/api/tasks/<int:task_id>', methods=['DELETE'])\ndef delete_task(task_id):\n    db = get_db()\n    task = db.execute('SELECT * FROM tasks WHERE id = ?', (task_id,)).fetchone()\n    \n    if not task:\n        return jsonify({'error': 'Task not found'}), 404\n    \n    db.execute('DELETE FROM tasks WHERE id = ?', (task_id,))\n    db.commit()\n    \n    return jsonify({'message': 'Task deleted successfully'}), 200\n\n@app.route('/api/tasks', methods=['GET'])\ndef get_tasks():\n    status_filter = request.args.get('status')\n    priority_filter = request.args.get('priority')\n    \n    db = get_db()\n    query = 'SELECT * FROM tasks WHERE 1=1'\n    params = []\n    \n    if status_filter:\n        query += ' AND status = ?'\n        params.append(status_filter)\n    \n    if priority_filter:\n        query += ' AND priority = ?'\n        params.append(priority_filter)\n    \n    query += ' ORDER BY created_at DESC'\n    \n    tasks = db.execute(query, params).fetchall()\n    \n    return jsonify({\n        'tasks': [{\n            'id': task['id'],\n            'title': task['title'],\n            'description': task['description'],\n            'status': task['status'],\n            'priority': task['priority'],\n            'created_at': task['created_at'],\n            'completed_at': task['completed_at']\n        } for task in tasks]\n    })\n\n@app.route('/api/tasks/<int:task_id>', methods=['GET'])\ndef get_task(task_id):\n    db = get_db()\n    task = db.execute('SELECT * FROM tasks WHERE id = ?', (task_id,)).fetchone()\n    \n    if not task:\n        return jsonify({'error': 'Task not found'}), 404\n    \n    return jsonify({\n        'id': task['id'],\n        'title': task['title'],\n        'description': task['description'],\n        'status': task['status'],\n        'priority': task['priority'],\n        'created_at': task['created_at'],\n        'completed_at': task['completed_at']\n    })\n\nif __name__ == '__main__':\n    init_db()\n    app.run(debug=True)\n```\n\n## Your Task\n\nCreate a comprehensive test suite that tests:\n\n### Part 1: Create Task Tests\nWrite tests in a `TestTaskCreation` class:\n\n1. **test_create_task_success** - Test creating a task with valid data\n2. **test_create_task_minimal** - Test creating task with only title (description optional)\n3. **test_missing_title_rejected** - Test that empty title is rejected\n4. **test_title_too_long_rejected** - Test that titles over 200 chars are rejected\n5. **test_invalid_priority_rejected** - Test invalid priorities ('urgent', 'critical')\n6. **test_default_values** - Test that status defaults to 'pending' and priority to 'medium'\n\n### Part 2: Update Task Tests\nWrite tests in a `TestTaskUpdate` class:\n\n1. **test_update_task_title** - Test updating task title\n2. **test_update_task_status** - Test changing status to 'in_progress'\n3. **test_complete_task_sets_timestamp** - Test that completing task sets completed_at\n4. **test_update_nonexistent_task** - Test updating task that doesn't exist (404)\n5. **test_invalid_status_rejected** - Test invalid status values\n\n### Part 3: Delete Task Tests\nWrite tests in a `TestTaskDeletion` class:\n\n1. **test_delete_task_success** - Test deleting an existing task\n2. **test_delete_nonexistent_task** - Test deleting non-existent task (404)\n3. **test_deleted_task_not_retrievable** - After delete, GET should return 404\n\n### Part 4: Get Tasks Tests\nWrite tests in a `TestTaskRetrieval` class:\n\n1. **test_get_all_tasks** - Test retrieving all tasks\n2. **test_get_tasks_by_status** - Test filtering by status (?status=completed)\n3. **test_get_tasks_by_priority** - Test filtering by priority (?priority=high)\n4. **test_get_single_task** - Test retrieving specific task by ID\n5. **test_get_nonexistent_task** - Test getting task that doesn't exist\n\n### Part 5: Integration Tests\nWrite tests in a `TestTaskWorkflow` class:\n\n1. **test_complete_workflow** - Test create → update → complete → delete\n2. **test_multiple_tasks_independent** - Create 3 tasks, update one, delete another, verify third unchanged\n\n## Setup Code (conftest.py)\n\nYou'll need to create this file:\n\n```python\nimport pytest\nimport os\nimport tempfile\nfrom task_api import app as flask_app, init_db\n\n@pytest.fixture\ndef app():\n    # Your code here: create temp database, configure app, init db\n    pass\n\n@pytest.fixture\ndef client(app):\n    # Your code here: return test client\n    pass\n```\n\n## Requirements\n\n1. Use pytest fixtures for setup and cleanup\n2. Organize tests into logical classes\n3. Use descriptive test names\n4. Test both success and failure cases\n5. Verify status codes AND response data\n6. Include at least one integration test\n\n## Running Your Tests\n\n```bash\n# Should see at least 20 tests pass\npytest test_task_api.py -v\n\n# Check coverage (aim for 90%+)\npytest test_task_api.py --cov=task_api\n```\n\n## Hints\n\n<details>\n<summary>Hint 1: Creating conftest.py</summary>\n\n```python\nimport pytest\nimport os\nimport tempfile\nfrom task_api import app as flask_app, init_db\n\n@pytest.fixture\ndef app():\n    db_fd, db_path = tempfile.mkstemp()\n    \n    flask_app.config.update({\n        'TESTING': True,\n        'DATABASE': db_path,\n    })\n    \n    with flask_app.app_context():\n        init_db()\n    \n    yield flask_app\n    \n    os.close(db_fd)\n    os.unlink(db_path)\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n```\n</details>\n\n<details>\n<summary>Hint 2: Creating a sample task fixture</summary>\n\n```python\n@pytest.fixture\ndef sample_task(client):\n    response = client.post('/api/tasks',\n                          json={\n                              'title': 'Sample Task',\n                              'description': 'A sample task for testing',\n                              'priority': 'medium'\n                          })\n    return response.get_json()\n```\n</details>\n\n<details>\n<summary>Hint 3: Testing filtering</summary>\n\n```python\ndef test_get_tasks_by_status(client):\n    # Create tasks with different statuses\n    client.post('/api/tasks', json={'title': 'Pending Task'})\n    \n    task2 = client.post('/api/tasks', json={'title': 'Completed Task'}).get_json()\n    client.put(f'/api/tasks/{task2[\"id\"]}', json={'status': 'completed'})\n    \n    # Filter by completed\n    response = client.get('/api/tasks?status=completed')\n    data = response.get_json()\n    \n    assert len(data['tasks']) == 1\n    assert data['tasks'][0]['title'] == 'Completed Task'\n```\n</details>\n\nTry to write all the tests yourself first! This exercise covers all the key testing concepts you've learned."
    },
    {
      "title": "The Coder: Solution with Common Mistakes",
      "content": "# Complete Solution: Task API Test Suite\n\n## conftest.py - Test Configuration\n\n```python\nimport pytest\nimport os\nimport tempfile\nfrom task_api import app as flask_app, init_db\n\n@pytest.fixture\ndef app():\n    \"\"\"Create and configure a test app instance.\"\"\"\n    db_fd, db_path = tempfile.mkstemp()\n    \n    flask_app.config.update({\n        'TESTING': True,\n        'DATABASE': db_path,\n    })\n    \n    with flask_app.app_context():\n        init_db()\n    \n    yield flask_app\n    \n    os.close(db_fd)\n    os.unlink(db_path)\n\n@pytest.fixture\ndef client(app):\n    \"\"\"Create a test client for the app.\"\"\"\n    return app.test_client()\n\n@pytest.fixture\ndef sample_task(client):\n    \"\"\"Create a sample task for testing.\"\"\"\n    response = client.post('/api/tasks',\n                          json={\n                              'title': 'Sample Task',\n                              'description': 'A sample task for testing',\n                              'priority': 'medium'\n                          })\n    return response.get_json()\n```\n\n## test_task_api.py - Complete Test Suite\n\n```python\nimport pytest\nimport json\n\nclass TestTaskCreation:\n    \"\"\"Test suite for task creation endpoint.\"\"\"\n    \n    def test_create_task_success(self, client):\n        \"\"\"Test creating a task with valid data.\"\"\"\n        response = client.post('/api/tasks',\n                              json={\n                                  'title': 'Complete project',\n                                  'description': 'Finish the API testing module',\n                                  'priority': 'high'\n                              })\n        \n        assert response.status_code == 201\n        data = response.get_json()\n        assert data['title'] == 'Complete project'\n        assert data['description'] == 'Finish the API testing module'\n        assert data['priority'] == 'high'\n        assert data['status'] == 'pending'  # Default value\n        assert 'id' in data\n        assert 'created_at' in data\n    \n    def test_create_task_minimal(self, client):\n        \"\"\"Test creating task with only required fields.\"\"\"\n        response = client.post('/api/tasks',\n                              json={'title': 'Minimal Task'})\n        \n        assert response.status_code == 201\n        data = response.get_json()\n        assert data['title'] == 'Minimal Task'\n        assert data['description'] == ''  # Empty when not provided\n        assert data['priority'] == 'medium'  # Default\n        assert data['status'] == 'pending'  # Default\n    \n    def test_missing_title_rejected(self, client):\n        \"\"\"Test that tasks without title are rejected.\"\"\"\n        # Empty title\n        response = client.post('/api/tasks',\n                              json={'title': ''})\n        assert response.status_code == 400\n        data = response.get_json()\n        assert 'error' in data\n        \n        # Missing title\n        response = client.post('/api/tasks',\n                              json={'description': 'No title'})\n        assert response.status_code == 400\n    \n    def test_title_too_long_rejected(self, client):\n        \"\"\"Test that titles over 200 characters are rejected.\"\"\"\n        long_title = 'A' * 201  # 201 characters\n        response = client.post('/api/tasks',\n                              json={'title': long_title})\n        \n        assert response.status_code == 400\n        data = response.get_json()\n        assert 'too long' in data['error'].lower()\n    \n    def test_invalid_priority_rejected(self, client):\n        \"\"\"Test that invalid priority values are rejected.\"\"\"\n        invalid_priorities = ['urgent', 'critical', 'super_high', 'LOW']\n        \n        for priority in invalid_priorities:\n            response = client.post('/api/tasks',\n                                  json={\n                                      'title': 'Test Task',\n                                      'priority': priority\n                                  })\n            \n            assert response.status_code == 400\n            data = response.get_json()\n            assert 'priority' in data['error'].lower()\n    \n    def test_default_values(self, client):\n        \"\"\"Test that default values are set correctly.\"\"\"\n        response = client.post('/api/tasks',\n                              json={'title': 'Default Test'})\n        \n        data = response.get_json()\n        assert data['status'] == 'pending'\n        assert data['priority'] == 'medium'\n        assert data['description'] == ''\n        assert data['completed_at'] is None\n\nclass TestTaskUpdate:\n    \"\"\"Test suite for task update endpoint.\"\"\"\n    \n    def test_update_task_title(self, client, sample_task):\n        \"\"\"Test updating task title.\"\"\"\n        response = client.put(f'/api/tasks/{sample_task[\"id\"]}',\n                             json={'title': 'Updated Title'})\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert data['title'] == 'Updated Title'\n        # Other fields should remain unchanged\n        assert data['description'] == sample_task['description']\n        assert data['priority'] == sample_task['priority']\n    \n    def test_update_task_status(self, client, sample_task):\n        \"\"\"Test changing task status.\"\"\"\n        response = client.put(f'/api/tasks/{sample_task[\"id\"]}',\n                             json={'status': 'in_progress'})\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert data['status'] == 'in_progress'\n    \n    def test_complete_task_sets_timestamp(self, client, sample_task):\n        \"\"\"Test that completing a task sets completed_at timestamp.\"\"\"\n        # Initially, completed_at should be None\n        assert sample_task['completed_at'] is None\n        \n        # Mark as completed\n        response = client.put(f'/api/tasks/{sample_task[\"id\"]}',\n                             json={'status': 'completed'})\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert data['status'] == 'completed'\n        assert data['completed_at'] is not None\n    \n    def test_uncomplete_task_clears_timestamp(self, client, sample_task):\n        \"\"\"Test that changing status from completed clears timestamp.\"\"\"\n        # First, complete the task\n        client.put(f'/api/tasks/{sample_task[\"id\"]}',\n                  json={'status': 'completed'})\n        \n        # Then change back to pending\n        response = client.put(f'/api/tasks/{sample_task[\"id\"]}',\n                             json={'status': 'pending'})\n        \n        data = response.get_json()\n        assert data['status'] == 'pending'\n        assert data['completed_at'] is None\n    \n    def test_update_nonexistent_task(self, client):\n        \"\"\"Test updating a task that doesn't exist.\"\"\"\n        response = client.put('/api/tasks/99999',\n                             json={'title': 'Updated'})\n        \n        assert response.status_code == 404\n        data = response.get_json()\n        assert 'error' in data\n    \n    def test_invalid_status_rejected(self, client, sample_task):\n        \"\"\"Test that invalid status values are rejected.\"\"\"\n        invalid_statuses = ['done', 'finished', 'COMPLETED', 'in progress']\n        \n        for status in invalid_statuses:\n            response = client.put(f'/api/tasks/{sample_task[\"id\"]}',\n                                 json={'status': status})\n            \n            assert response.status_code == 400\n            data = response.get_json()\n            assert 'status' in data['error'].lower()\n    \n    def test_update_multiple_fields(self, client, sample_task):\n        \"\"\"Test updating multiple fields at once.\"\"\"\n        response = client.put(f'/api/tasks/{sample_task[\"id\"]}',\n                             json={\n                                 'title': 'New Title',\n                                 'description': 'New Description',\n                                 'priority': 'high',\n                                 'status': 'in_progress'\n                             })\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert data['title'] == 'New Title'\n        assert data['description'] == 'New Description'\n        assert data['priority'] == 'high'\n        assert data['status'] == 'in_progress'\n\nclass TestTaskDeletion:\n    \"\"\"Test suite for task deletion endpoint.\"\"\"\n    \n    def test_delete_task_success(self, client, sample_task):\n        \"\"\"Test deleting an existing task.\"\"\"\n        response = client.delete(f'/api/tasks/{sample_task[\"id\"]}')\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert 'message' in data\n    \n    def test_delete_nonexistent_task(self, client):\n        \"\"\"Test deleting a task that doesn't exist.\"\"\"\n        response = client.delete('/api/tasks/99999')\n        \n        assert response.status_code == 404\n        data = response.get_json()\n        assert 'error' in data\n    \n    def test_deleted_task_not_retrievable(self, client, sample_task):\n        \"\"\"Test that deleted task cannot be retrieved.\"\"\"\n        task_id = sample_task['id']\n        \n        # Delete the task\n        response = client.delete(f'/api/tasks/{task_id}')\n        assert response.status_code == 200\n        \n        # Try to get the deleted task\n        response = client.get(f'/api/tasks/{task_id}')\n        assert response.status_code == 404\n    \n    def test_delete_task_removed_from_list(self, client, sample_task):\n        \"\"\"Test that deleted task doesn't appear in task list.\"\"\"\n        # Get all tasks before delete\n        response = client.get('/api/tasks')\n        before_count = len(response.get_json()['tasks'])\n        \n        # Delete task\n        client.delete(f'/api/tasks/{sample_task[\"id\"]}')\n        \n        # Get all tasks after delete\n        response = client.get('/api/tasks')\n        after_count = len(response.get_json()['tasks'])\n        \n        assert after_count == before_count - 1\n\nclass TestTaskRetrieval:\n    \"\"\"Test suite for task retrieval endpoints.\"\"\"\n    \n    def test_get_all_tasks(self, client):\n        \"\"\"Test retrieving all tasks.\"\"\"\n        # Create multiple tasks\n        client.post('/api/tasks', json={'title': 'Task 1'})\n        client.post('/api/tasks', json={'title': 'Task 2'})\n        client.post('/api/tasks', json={'title': 'Task 3'})\n        \n        response = client.get('/api/tasks')\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert 'tasks' in data\n        assert len(data['tasks']) == 3\n    \n    def test_get_tasks_by_status(self, client):\n        \"\"\"Test filtering tasks by status.\"\"\"\n        # Create tasks with different statuses\n        task1 = client.post('/api/tasks', json={'title': 'Pending Task'}).get_json()\n        task2 = client.post('/api/tasks', json={'title': 'In Progress Task'}).get_json()\n        task3 = client.post('/api/tasks', json={'title': 'Completed Task'}).get_json()\n        \n        # Update statuses\n        client.put(f'/api/tasks/{task2[\"id\"]}', json={'status': 'in_progress'})\n        client.put(f'/api/tasks/{task3[\"id\"]}', json={'status': 'completed'})\n        \n        # Filter by completed\n        response = client.get('/api/tasks?status=completed')\n        data = response.get_json()\n        \n        assert len(data['tasks']) == 1\n        assert data['tasks'][0]['title'] == 'Completed Task'\n        assert data['tasks'][0]['status'] == 'completed'\n    \n    def test_get_tasks_by_priority(self, client):\n        \"\"\"Test filtering tasks by priority.\"\"\"\n        # Create tasks with different priorities\n        client.post('/api/tasks', json={'title': 'Low Priority', 'priority': 'low'})\n        client.post('/api/tasks', json={'title': 'High Priority', 'priority': 'high'})\n        client.post('/api/tasks', json={'title': 'Medium Priority', 'priority': 'medium'})\n        \n        # Filter by high priority\n        response = client.get('/api/tasks?priority=high')\n        data = response.get_json()\n        \n        assert len(data['tasks']) == 1\n        assert data['tasks'][0]['title'] == 'High Priority'\n        assert data['tasks'][0]['priority'] == 'high'\n    \n    def test_get_tasks_by_status_and_priority(self, client):\n        \"\"\"Test filtering by multiple criteria.\"\"\"\n        # Create various tasks\n        task1 = client.post('/api/tasks', \n                           json={'title': 'High & Pending', 'priority': 'high'}).get_json()\n        task2 = client.post('/api/tasks', \n                           json={'title': 'High & Completed', 'priority': 'high'}).get_json()\n        client.post('/api/tasks', json={'title': 'Low & Pending', 'priority': 'low'})\n        \n        # Complete one high priority task\n        client.put(f'/api/tasks/{task2[\"id\"]}', json={'status': 'completed'})\n        \n        # Filter by high priority AND completed status\n        response = client.get('/api/tasks?priority=high&status=completed')\n        data = response.get_json()\n        \n        assert len(data['tasks']) == 1\n        assert data['tasks'][0]['title'] == 'High & Completed'\n    \n    def test_get_single_task(self, client, sample_task):\n        \"\"\"Test retrieving a specific task by ID.\"\"\"\n        response = client.get(f'/api/tasks/{sample_task[\"id\"]}')\n        \n        assert response.status_code == 200\n        data = response.get_json()\n        assert data['id'] == sample_task['id']\n        assert data['title'] == sample_task['title']\n    \n    def test_get_nonexistent_task(self, client):\n        \"\"\"Test retrieving a task that doesn't exist.\"\"\"\n        response = client.get('/api/tasks/99999')\n        \n        assert response.status_code == 404\n        data = response.get_json()\n        assert 'error' in data\n    \n    def test_tasks_ordered_by_creation(self, client):\n        \"\"\"Test that tasks are returned in reverse chronological order.\"\"\"\n        # Create tasks in sequence\n        task1 = client.post('/api/tasks', json={'title': 'First'}).get_json()\n        task2 = client.post('/api/tasks', json={'title': 'Second'}).get_json()\n        task3 = client.post('/api/tasks', json={'title': 'Third'}).get_json()\n        \n        # Get all tasks\n        response = client.get('/api/tasks')\n        tasks = response.get_json()['tasks']\n        \n        # Should be in reverse order (newest first)\n        assert tasks[0]['title'] == 'Third'\n        assert tasks[1]['title'] == 'Second'\n        assert tasks[2]['title'] == 'First'\n\nclass TestTaskWorkflow:\n    \"\"\"Integration tests for complete task workflows.\"\"\"\n    \n    def test_complete_workflow(self, client):\n        \"\"\"Test a complete task lifecycle: create → update → complete → delete.\"\"\"\n        # CREATE\n        response = client.post('/api/tasks',\n                              json={\n                                  'title': 'Complete Project',\n                                  'description': 'Finish the API',\n                                  'priority': 'high'\n                              })\n        assert response.status_code == 201\n        task = response.get_json()\n        task_id = task['id']\n        \n        # Verify initial state\n        assert task['status'] == 'pending'\n        assert task['completed_at'] is None\n        \n        # UPDATE - Start work\n        response = client.put(f'/api/tasks/{task_id}',\n                             json={'status': 'in_progress'})\n        assert response.status_code == 200\n        task = response.get_json()\n        assert task['status'] == 'in_progress'\n        \n        # UPDATE - Complete task\n        response = client.put(f'/api/tasks/{task_id}',\n                             json={'status': 'completed'})\n        assert response.status_code == 200\n        task = response.get_json()\n        assert task['status'] == 'completed'\n        assert task['completed_at'] is not None\n        \n        # DELETE\n        response = client.delete(f'/api/tasks/{task_id}')\n        assert response.status_code == 200\n        \n        # Verify deletion\n        response = client.get(f'/api/tasks/{task_id}')\n        assert response.status_code == 404\n    \n    def test_multiple_tasks_independent(self, client):\n        \"\"\"Test that operations on one task don't affect others.\"\"\"\n        # Create 3 tasks\n        task1 = client.post('/api/tasks', json={'title': 'Task 1'}).get_json()\n        task2 = client.post('/api/tasks', json={'title': 'Task 2'}).get_json()\n        task3 = client.post('/api/tasks', json={'title': 'Task 3'}).get_json()\n        \n        # Update task 1\n        client.put(f'/api/tasks/{task1[\"id\"]}',\n                  json={'status': 'completed', 'priority': 'high'})\n        \n        # Delete task 2\n        client.delete(f'/api/tasks/{task2[\"id\"]}')\n        \n        # Verify task 3 is unchanged\n        response = client.get(f'/api/tasks/{task3[\"id\"]}')\n        task3_current = response.get_json()\n        \n        assert task3_current['title'] == 'Task 3'\n        assert task3_current['status'] == 'pending'\n        assert task3_current['priority'] == 'medium'\n    \n    def test_concurrent_task_management(self, client):\n        \"\"\"Test managing multiple tasks with different priorities and statuses.\"\"\"\n        # Create a mix of tasks\n        tasks = [\n            {'title': 'Bug Fix', 'priority': 'high'},\n            {'title': 'Feature Request', 'priority': 'low'},\n            {'title': 'Documentation', 'priority': 'medium'},\n            {'title': 'Testing', 'priority': 'high'},\n        ]\n        \n        created_tasks = []\n        for task_data in tasks:\n            response = client.post('/api/tasks', json=task_data)\n            created_tasks.append(response.get_json())\n        \n        # Complete high priority tasks\n        for task in created_tasks:\n            if task['priority'] == 'high':\n                client.put(f'/api/tasks/{task[\"id\"]}',\n                          json={'status': 'completed'})\n        \n        # Verify high priority tasks are completed\n        response = client.get('/api/tasks?priority=high&status=completed')\n        completed_high = response.get_json()['tasks']\n        assert len(completed_high) == 2\n        \n        # Verify low and medium priority tasks still pending\n        response = client.get('/api/tasks?status=pending')\n        pending = response.get_json()['tasks']\n        assert len(pending) == 2\n```\n\n## Running the Tests\n\n```bash\n# Run all tests with verbose output\npytest test_task_api.py -v\n\n# Run specific test class\npytest test_task_api.py::TestTaskCreation -v\n\n# Run with coverage\npytest test_task_api.py --cov=task_api --cov-report=html\n\n# Run and stop on first failure\npytest test_task_api.py -x\n```\n\n## Expected Output\n\n```\ntest_task_api.py::TestTaskCreation::test_create_task_success PASSED\ntest_task_api.py::TestTaskCreation::test_create_task_minimal PASSED\ntest_task_api.py::TestTaskCreation::test_missing_title_rejected PASSED\ntest_task_api.py::TestTaskCreation::test_title_too_long_rejected PASSED\ntest_task_api.py::TestTaskCreation::test_invalid_priority_rejected PASSED\ntest_task_api.py::TestTaskCreation::test_default_values PASSED\ntest_task_api.py::TestTaskUpdate::test_update_task_title PASSED\ntest_task_api.py::TestTaskUpdate::test_update_task_status PASSED\ntest_task_api.py::TestTaskUpdate::test_complete_task_sets_timestamp PASSED\ntest_task_api.py::TestTaskUpdate::test_uncomplete_task_clears_timestamp PASSED\ntest_task_api.py::TestTaskUpdate::test_update_nonexistent_task PASSED\ntest_task_api.py::TestTaskUpdate::test_invalid_status_rejected PASSED\ntest_task_api.py::TestTaskUpdate::test_update_multiple_fields PASSED\ntest_task_api.py::TestTaskDeletion::test_delete_task_success PASSED\ntest_task_api.py::TestTaskDeletion::test_delete_nonexistent_task PASSED\ntest_task_api.py::TestTaskDeletion::test_deleted_task_not_retrievable PASSED\ntest_task_api.py::TestTaskDeletion::test_delete_task_removed_from_list PASSED\ntest_task_api.py::TestTaskRetrieval::test_get_all_tasks PASSED\ntest_task_api.py::TestTaskRetrieval::test_get_tasks_by_status PASSED\ntest_task_api.py::TestTaskRetrieval::test_get_tasks_by_priority PASSED\ntest_task_api.py::TestTaskRetrieval::test_get_tasks_by_status_and_priority PASSED\ntest_task_api.py::TestTaskRetrieval::test_get_single_task PASSED\ntest_task_api.py::TestTaskRetrieval::test_get_nonexistent_task PASSED\ntest_task_api.py::TestTaskRetrieval::test_tasks_ordered_by_creation PASSED\ntest_task_api.py::TestTaskWorkflow::test_complete_workflow PASSED\ntest_task_api.py::TestTaskWorkflow::test_multiple_tasks_independent PASSED\ntest_task_api.py::TestTaskWorkflow::test_concurrent_task_management PASSED\n\n=============== 27 passed in 0.68s ===============\n\nCoverage Report:\nName           Stmts   Miss  Cover\n----------------------------------\ntask_api.py      142      4    97%\n----------------------------------\nTOTAL            142      4    97%\n```\n\n## Common Mistakes and How to Avoid Them\n\n### Mistake 1: Forgetting to Clean Up Test Data\n\n❌ **Wrong:**\n```python\n@pytest.fixture\ndef app():\n    flask_app.config['DATABASE'] = 'test.db'\n    init_db()\n    return flask_app\n    # Database file remains after tests!\n```\n\n✅ **Correct:**\n```python\n@pytest.fixture\ndef app():\n    db_fd, db_path = tempfile.mkstemp()\n    flask_app.config['DATABASE'] = db_path\n    \n    yield flask_app\n    \n    os.close(db_fd)\n    os.unlink(db_path)  # Clean up!\n```\n\n### Mistake 2: Not Testing Error Cases\n\n❌ **Wrong:**\n```python\ndef test_create_task(self, client):\n    # Only test happy path\n    response = client.post('/api/tasks', json={'title': 'Task'})\n    assert response.status_code == 201\n```\n\n✅ **Correct:**\n```python\ndef test_create_task_success(self, client):\n    # Test happy path\n    response = client.post('/api/tasks', json={'title': 'Task'})\n    assert response.status_code == 201\n\ndef test_create_task_missing_title(self, client):\n    # Test error case\n    response = client.post('/api/tasks', json={})\n    assert response.status_code == 400\n```\n\n### Mistake 3: Testing Multiple Things in One Test\n\n❌ **Wrong:**\n```python\ndef test_everything(self, client):\n    # Create task\n    task = client.post('/api/tasks', json={'title': 'Task'}).get_json()\n    # Update task\n    client.put(f'/api/tasks/{task[\"id\"]}', json={'status': 'completed'})\n    # Delete task\n    client.delete(f'/api/tasks/{task[\"id\"]}')\n    # If any part fails, hard to know which!\n```\n\n✅ **Correct:**\n```python\ndef test_create_task(self, client):\n    response = client.post('/api/tasks', json={'title': 'Task'})\n    assert response.status_code == 201\n\ndef test_update_task(self, client, sample_task):\n    response = client.put(f'/api/tasks/{sample_task[\"id\"]}', \n                         json={'status': 'completed'})\n    assert response.status_code == 200\n\ndef test_delete_task(self, client, sample_task):\n    response = client.delete(f'/api/tasks/{sample_task[\"id\"]}')\n    assert response.status_code == 200\n```\n\n### Mistake 4: Not Checking Response Data\n\n❌ **Wrong:**\n```python\ndef test_create_task(self, client):\n    response = client.post('/api/tasks', json={'title': 'Task'})\n    assert response.status_code == 201  # Only check status code\n```\n\n✅ **Correct:**\n```python\ndef test_create_task(self, client):\n    response = client.post('/api/tasks', json={'title': 'Task'})\n    assert response.status_code == 201\n    \n    data = response.get_json()\n    assert data['title'] == 'Task'\n    assert 'id' in data\n    assert data['status'] == 'pending'\n```\n\n### Mistake 5: Sharing State Between Tests\n\n❌ **Wrong:**\n```python\nclass TestTasks:\n    task_id = None  # Class variable shared between tests!\n    \n    def test_create(self, client):\n        task = client.post('/api/tasks', json={'title': 'Task'}).get_json()\n        self.task_id = task['id']\n    \n    def test_update(self, client):\n        # Depends on test_create running first!\n        client.put(f'/api/tasks/{self.task_id}', json={'status': 'completed'})\n```\n\n✅ **Correct:**\n```python\nclass TestTasks:\n    def test_create(self, client):\n        task = client.post('/api/tasks', json={'title': 'Task'}).get_json()\n        assert task['id'] is not None\n    \n    def test_update(self, client, sample_task):\n        # Uses fixture - independent of other tests\n        response = client.put(f'/api/tasks/{sample_task[\"id\"]}',\n                             json={'status': 'completed'})\n        assert response.status_code == 200\n```\n\n### Mistake 6: Vague Test Names\n\n❌ **Wrong:**\n```python\ndef test_task1(self, client):\ndef test_task2(self, client):\ndef test_edge_case(self, client):\n```\n\n✅ **Correct:**\n```python\ndef test_create_task_with_valid_data(self, client):\ndef test_create_task_rejects_empty_title(self, client):\ndef test_create_task_rejects_duplicate_id(self, client):\n```\n\n### Mistake 7: Not Using Fixtures for Common Setup\n\n❌ **Wrong:**\n```python\ndef test_update_task(self, client):\n    # Create task every time\n    task = client.post('/api/tasks', json={'title': 'Task'}).get_json()\n    response = client.put(f'/api/tasks/{task[\"id\"]}', json={'status': 'completed'})\n\ndef test_delete_task(self, client):\n    # Duplicate setup code!\n    task = client.post('/api/tasks', json={'title': 'Task'}).get_json()\n    response = client.delete(f'/api/tasks/{task[\"id\"]}')\n```\n\n✅ **Correct:**\n```python\n@pytest.fixture\ndef sample_task(client):\n    response = client.post('/api/tasks', json={'title': 'Task'})\n    return response.get_json()\n\ndef test_update_task(self, client, sample_task):\n    response = client.put(f'/api/tasks/{sample_task[\"id\"]}',\n                         json={'status': 'completed'})\n\ndef test_delete_task(self, client, sample_task):\n    response = client.delete(f'/api/tasks/{sample_task[\"id\"]}')\n```\n\n## Key Takeaways\n\n1. **Always clean up test data** - Use temporary databases and cleanup in fixtures\n2. **Test both success and failure** - Don't just test the happy path\n3. **One test, one thing** - Each test should verify one specific behavior\n4. **Check status codes AND data** - Verify the complete response\n5. **Use fixtures for reusable setup** - Don't repeat yourself\n6. **Make tests independent** - Each test should run in isolation\n7. **Use descriptive names** - Test names should explain what they test\n8. **Organize with classes** - Group related tests together"
    },
    {
      "title": "Key Takeaways",
      "content": "# Key Takeaways: API Testing and Documentation\n\n## 1. The Testing Pyramid\n\n```\n       /\\           ← Few integration tests\n      /  \\          \n     /____\\         ← Some functional tests\n    /      \\        \n   /________\\       ← Many unit tests (fast!)\n```\n\n- **Unit tests:** Test individual endpoints in isolation (fast, many)\n- **Integration tests:** Test multiple components together (slower, fewer)\n- **End-to-end tests:** Test complete user workflows (slowest, fewest)\n\n## 2. pytest Essentials\n\n### Test Discovery\n```python\ndef test_something():  # Must start with test_\n    assert 1 + 1 == 2\n```\n\npytest automatically finds:\n- Files starting with `test_`\n- Functions starting with `test_`\n- Classes starting with `Test`\n\n### Fixtures for Setup and Cleanup\n```python\n@pytest.fixture\ndef resource():\n    # Setup\n    r = create_resource()\n    yield r  # Give to test\n    # Cleanup (always runs)\n    r.cleanup()\n```\n\n**Key insight:** Fixtures ensure cleanup happens even if test fails!\n\n### Assertions\n```python\nassert response.status_code == 200\nassert 'id' in data\nassert data['email'] == 'test@example.com'\n```\n\nIf assertion fails, pytest shows exactly what went wrong.\n\n## 3. Flask Test Client\n\n```python\nclient = app.test_client()\n\n# GET request\nresponse = client.get('/api/users')\n\n# POST with JSON\nresponse = client.post('/api/users', json={'name': 'Alice'})\n\n# Check response\nassert response.status_code == 201\ndata = response.get_json()\n```\n\nThe test client lets you make HTTP requests without running a server!\n\n## 4. Test Organization\n\n### Organize by Feature\n```python\nclass TestUserRegistration:\n    def test_valid_registration(self, client):\n        # Test happy path\n    \n    def test_duplicate_email_rejected(self, client):\n        # Test error case\n    \n    def test_invalid_email_rejected(self, client):\n        # Test validation\n```\n\n### Use Descriptive Names\n- ✅ `test_registration_rejects_weak_password`\n- ❌ `test_password`\n- ✅ `test_login_returns_jwt_token`\n- ❌ `test_login`\n\n## 5. What to Test\n\n### Happy Path (Things That Should Work)\n```python\ndef test_create_user_with_valid_data(client):\n    response = client.post('/api/users', json={\n        'email': 'valid@example.com',\n        'password': 'SecurePass123'\n    })\n    assert response.status_code == 201\n```\n\n### Error Cases (Things That Should Fail Gracefully)\n```python\ndef test_create_user_with_invalid_email(client):\n    response = client.post('/api/users', json={\n        'email': 'not-an-email',\n        'password': 'SecurePass123'\n    })\n    assert response.status_code == 400\n    assert 'error' in response.get_json()\n```\n\n### Edge Cases (Weird But Possible Scenarios)\n```python\ndef test_create_user_with_extremely_long_email(client):\n    email = 'a' * 500 + '@example.com'\n    response = client.post('/api/users', json={'email': email})\n    # Should handle gracefully, not crash\n```\n\n## 6. Database Testing\n\n### Use Temporary Test Database\n```python\n@pytest.fixture\ndef app():\n    db_fd, db_path = tempfile.mkstemp()\n    app.config['DATABASE'] = db_path  # Test database\n    \n    yield app\n    \n    os.close(db_fd)\n    os.unlink(db_path)  # Delete after test\n```\n\n**Never test against production database!**\n\n### Verify Data Persistence\n```python\ndef test_user_saved_to_database(client):\n    # Create user\n    response = client.post('/api/users', json={'name': 'Alice'})\n    user_id = response.get_json()['id']\n    \n    # Retrieve user - should still exist\n    response = client.get(f'/api/users/{user_id}')\n    assert response.status_code == 200\n```\n\n## 7. Testing Patterns\n\n### Arrange-Act-Assert (AAA)\n```python\ndef test_something(client):\n    # ARRANGE - Set up test data\n    data = {'email': 'test@example.com'}\n    \n    # ACT - Perform action\n    response = client.post('/api/register', json=data)\n    \n    # ASSERT - Check results\n    assert response.status_code == 201\n```\n\n### Use Fixtures for Common Data\n```python\n@pytest.fixture\ndef registered_user(client):\n    response = client.post('/api/register', json={\n        'email': 'user@example.com',\n        'password': 'SecurePass123'\n    })\n    return response.get_json()\n\ndef test_login(client, registered_user):\n    # Use the fixture\n    response = client.post('/api/login', json={\n        'email': registered_user['email'],\n        'password': 'SecurePass123'\n    })\n    assert response.status_code == 200\n```\n\n## 8. Coverage Matters (But Not Everything)\n\n```bash\npytest --cov=app --cov-report=html\n```\n\n**Coverage report shows:**\n- Which lines of code were executed during tests\n- Which lines were never tested\n\n**Aim for 80%+ coverage, but:**\n- 100% coverage ≠ perfect tests\n- Better to have meaningful tests than just high coverage\n- Focus on testing critical paths and edge cases\n\n## 9. Running Tests\n\n```bash\n# All tests\npytest\n\n# Verbose (show each test name)\npytest -v\n\n# Stop on first failure\npytest -x\n\n# Run specific test\npytest test_api.py::test_registration\n\n# Run specific class\npytest test_api.py::TestUserRegistration\n\n# Show print statements\npytest -s\n\n# Coverage report\npytest --cov=app --cov-report=html\n```\n\n## 10. API Documentation Best Practices\n\n### Include Complete Examples\n```markdown\n## POST /api/users\nCreate a new user account.\n\n**Request:**\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"SecurePass123\",\n  \"name\": \"John Doe\"\n}\n\n**Success Response (201 Created):**\n{\n  \"id\": 123,\n  \"email\": \"user@example.com\",\n  \"name\": \"John Doe\",\n  \"created_at\": \"2025-01-15T10:30:00Z\"\n}\n\n**Error Responses:**\n- 400 Bad Request - Invalid email format\n- 409 Conflict - Email already registered\n- 422 Unprocessable Entity - Password too weak\n```\n\n### Document All Endpoints\n- Method (GET, POST, PUT, DELETE)\n- URL path with parameters\n- Request body format\n- Response format\n- Possible status codes\n- Error messages\n\n## 11. Common Testing Mistakes to Avoid\n\n1. **❌ Not cleaning up test data**\n   - Use fixtures with cleanup code\n\n2. **❌ Tests depend on each other**\n   - Each test should be independent\n\n3. **❌ Only testing happy path**\n   - Test errors and edge cases too\n\n4. **❌ Vague test names**\n   - Names should explain what's being tested\n\n5. **❌ Testing too many things at once**\n   - One test, one behavior\n\n6. **❌ Not checking response data**\n   - Verify status code AND content\n\n7. **❌ Using production database**\n   - Always use a test database\n\n## 12. The Testing Mindset\n\n**Think like a user:**\n- What should work? (Test it)\n- What should fail? (Test it fails gracefully)\n- What weird input might someone try? (Test edge cases)\n\n**Think like a maintainer:**\n- If I change this code, which tests should fail?\n- Do my test names explain what they test?\n- Can someone else understand these tests?\n\n**Think like a debugger:**\n- If this test fails, will I know exactly what's wrong?\n- Are my error messages helpful?\n\n## 13. When to Write Tests\n\n**Write tests:**\n- ✅ Before deploying to production\n- ✅ When fixing bugs (test the fix!)\n- ✅ For critical features (authentication, payments)\n- ✅ For complex logic (calculations, validations)\n\n**Tests save time by:**\n- Catching bugs before users do\n- Preventing regressions (old bugs coming back)\n- Making refactoring safer\n- Serving as documentation\n\n## Final Wisdom\n\n> \"Testing shows the presence of bugs, not their absence.\" - Edsger Dijkstra\n\nTests can't prove your code is perfect, but they can:\n- Catch most common bugs\n- Prevent regressions\n- Give you confidence to make changes\n- Document how your API should work\n\n**The best test is the one you write today that prevents a bug tomorrow!**"
    }
  ],
  "checkpoint_quiz": {
    "questions": [
      {
        "id": 1,
        "question": "What is the main purpose of pytest fixtures?",
        "options": [
          "To make tests run faster",
          "To provide reusable setup code with automatic cleanup",
          "To generate test data randomly",
          "To skip tests that might fail"
        ],
        "correct_answer": 1,
        "explanation": "Fixtures provide reusable setup code and ensure cleanup happens even if tests fail. They're perfect for creating test databases, sample data, or test clients."
      },
      {
        "id": 2,
        "question": "Why should you use a temporary database for testing instead of your production database?",
        "options": [
          "Production databases are too slow",
          "Tests modify/delete data - you don't want to corrupt production!",
          "Temporary databases are more secure",
          "pytest requires temporary databases"
        ],
        "correct_answer": 1,
        "explanation": "Tests create, modify, and delete data. Running tests against production would corrupt real user data! Always use a separate test database that gets created fresh for each test run."
      },
      {
        "id": 3,
        "question": "What does the test client in Flask allow you to do?",
        "options": [
          "Deploy your API to production",
          "Make HTTP requests to your API without running a server",
          "Generate API documentation automatically",
          "Monitor API performance in production"
        ],
        "correct_answer": 1,
        "explanation": "Flask's test client lets you make HTTP requests (GET, POST, etc.) to your API during tests without starting a web server. This makes tests fast and reliable."
      }
    ]
  }
}
